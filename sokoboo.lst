------- FILE ./sokoboo.asm LEVEL 1 PASS 3
      1  8000 ????						;    Sokoboo - a Sokoban implementation
      2  8000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  8000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  8000 ????						;
      5  8000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  8000 ????						;
      7  8000 ????						;    Code related to the generic tile-based display engine was developed by
      8  8000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  8000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  8000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  8000 ????						;
     12  8000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  8000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  8000 ????						;    directory for Apache licensing details.
     15  8000 ????						;
     16  8000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  8000 ????						;    See the copyright notices in the License directory for a list of level
     18  8000 ????						;    contributors.
     19  8000 ????						;
     20  8000 ????						;    Except where otherwise indicated, this software is released under the
     21  8000 ????						;    following licensing arrangement...
     22  8000 ????						;
     23  8000 ????						;    This program is free software: you can redistribute it and/or modify
     24  8000 ????						;    it under the terms of the GNU General Public License as published by
     25  8000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  8000 ????						;    (at your option) any later version.
     27  8000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  8000 ????
     29  8000 ????						;    This program is distributed in the hope that it will be useful,
     30  8000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  8000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  8000 ????						;    GNU General Public License for more details.
     33  8000 ????
     34  8000 ????
     35  8000 ????
     36  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
     37  8000 ????
     38  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 3
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; This file defines hardware registers and memory mapping for the
      7  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  8000 ????						; available at at http://www.atari2600.org/dasm
     10  8000 ????						;
     11  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  8000 ????						; with your views.  Please contribute, if you think you can improve this
     15  8000 ????						; file!
     16  8000 ????						;
     17  8000 ????						; Latest Revisions...
     18  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  8000 ????						;			    This will allow conditional code to verify VCS.H being
     21  8000 ????						;			    used for code assembly.
     22  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  8000 ????						;			 mirrored reading/writing differences.	This is more a
     25  8000 ????						;			 readability issue, and binary compatibility with disassembled
     26  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  8000 ????						;			 which was broken by the use of segments in this file, as
     29  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  8000 ????						;						   it is safe to leave it undefined, and the base address will
     34  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  8000 ????						;			  - register definitions are now generated through assignment
     37  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     38  8000 ????						;			    address architecture.
     39  8000 ????						; 1.0	22/MAR/2003		Initial release
     40  8000 ????
     41  8000 ????
     42  8000 ????						;-------------------------------------------------------------------------------
     43  8000 ????
     44  8000 ????						; TIA_BASE_ADDRESS
     45  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  8000 ????						; Normally 0, the base address should (externally, before including this file)
     47  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  8000 ????						; < $40 as a bankswitch.
     50  8000 ????
     51  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  8000 ????			  -TIA_BASE_ADDRESS =	0
     53  8000 ????				      ENDIF
     54  8000 ????
     55  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  8000 ????						; *OR* by declaring the label before including this file, eg:
     58  8000 ????						; TIA_BASE_ADDRESS = $40
     59  8000 ????						;   include "vcs.h"
     60  8000 ????
     61  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  8000 ????						; for the mirrored ROM hardware registers.
     64  8000 ????
     65  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  8000 ????
     69  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  8000 ????				      ENDIF
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????						;-------------------------------------------------------------------------------
     78  8000 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./sokoboo.asm
------- FILE macro.h LEVEL 2 PASS 3
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./sokoboo.asm
     41  0000 ????
     42  0000 ????			   ORIGIN     SET	0
     43  0000 ????			   ORIGIN_RAM SET	0
     44  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	segtime_c
     89  0000 ????			   {1}	      SET	({2}+32)/64 + 2
     90  0000 ????			   TEST_{1}   =	0
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_DIRECT, 361 + CYCLES_DRAWANOTHER	;✅ @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_DIRECT SET	(361 + CYCLES_DRAWANOTHER+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_DIRECT =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_QUICK, 344 + CYCLES_DRAWANOTHER	;✅ @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_QUICK SET	(344 + CYCLES_DRAWANOTHER+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_QUICK =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_SLOW, 676 + CYCLES_DRAWANOTHER	;✅ @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_SLOW SET	(676 + CYCLES_DRAWANOTHER+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_SLOW =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_PF0, 88 + CYCLES_DRAWANOTHER	;✅ @ 4/8/2019 ??
      1  0000 ????			   SEGTIME_SCD_PF0 SET	(88 + CYCLES_DRAWANOTHER+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_PF0 =	0
     98  0000 ????
     99  0000 ????						;---------------------------------------------------------------------------------------------------
    100  0000 ????						; Pathways
    101  0000 ????						; StealPart3, not enough time for SCD_SLOW --> 79✅
    102  0000 ????						; if QuickDraw does immediate exit, 58✅
    103  0000 ????
    104  0000 ????
    105  0000 ????	       00 04	   SEGTIME_SCD_MIN =	SEGTIME_SCD_PF0
    106  0000 ????
    107  0000 ????						;    SEGTIME_C SEGTIME_SCD_MIN, SEGTIME_SCD_PF0
    108  0000 ????						;---------------------------------------------------------------------------------------------------
    109  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_BDF, 2512	;✅
      1  0000 ????			   SEGTIME_BDF SET	(2512+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_BDF =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_BDS, 68	;✅
      1  0000 ????			   SEGTIME_BDS SET	(68+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_BDS =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_DSL, 127	;✅
      1  0000 ????			   SEGTIME_DSL SET	(127+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_DSL =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SWITCHOBJECTS,46	;✅
      1  0000 ????			   SEGTIME_SWITCHOBJECTS SET	(46+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_SWITCHOBJECTS =	0
    114  0000 ????
      0  0000 ????				      SEGTIME_C	MINIMUM_SEGTIME, 95	;✅ processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	(95+32)/64 + 2
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_MINIMUM_TIMESLICE, 54	;✅ abort time maximum requirement for timeslice
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	(54+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    117  0000 ????
    118  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    119  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    120  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    121  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    122  0000 ????						; uses ...
    123  0000 ????
    124  0000 ????
    125  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    126  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    127  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    128  0000 ????
    129  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    130  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    131  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,22	;18 ;12	  ;NFI
      1  0000 ????			   SEGTIME_MAN SET	22
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
------- FILE ./sokoboo.asm
     46  0000 ????
     47  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     48  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     49  0000 ????	       78 00	   FIXED_BANK =	15 * 2048	; ->> 32K
     50  0000 ????						;FIXED_BANK		 = 31 * 2048	       ; ->> 64K
     51  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     52  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     53  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     54  0000 ????
     55  0000 ????	       00 01	   YES	      =	1
     56  0000 ????	       00 00	   NO	      =	0
     57  0000 ????
     58  0000 ????						;===================================
     59  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     60  0000 ????						;===================================
     61  0000 ????
     62  0000 ????						;-------------------------------------------------------------------------------
     63  0000 ????						; The following are optional YES/NO depending on phase of the moon
     64  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     65  0000 ????						;-------------------------------------------------------------------------------
     66  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     67  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     68  0000 ????			  -	      IF	FINAL_VERSION = YES
     69  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     70  0000 ????				      ENDIF
     71  0000 ????
     72  0000 ????						;-------------------------------------------------------------------------------
     73  0000 ????
     74  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     75  0000 ????	       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
     76  0000 ????
     77  0000 ????	       00 02	   PALETTE_INTENSITY_ADJUST =	2
     78  0000 ????	       00 06	   PUSH_LIMIT =	6	; slowdown when pushing on a BOX
     79  0000 ????
     80  0000 ????						; time bonus countdown constants:
     81  0000 ????	       00 ff	   EXTRA_LIFE_TIMER =	255	; Cosmic Ark star effect on extra life. Should be 5 seconds like in original
     82  0000 ????	       00 3c	   SCORING_TIMER =	60	; ~1.0 second
     83  0000 ????	       00 96	   SCORING_TIMER_FIRST =	150	; begin level timer is long to show level/lives clearly
     84  0000 ????
     85  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
     86  0000 ????
     87  0000 ????	       00 a0	   MAX_THROTTLE =	160	; must be small enough to allow ~2 * max add value overflow (<256 - 2*max throttle value!)
     88  0000 ????
     89  0000 ????						;scoring flags contants:
     90  0000 ????	       00 03	   DISPLAY_FLAGS =	%11
     91  0000 ????	       00 00	   DISPLAY_TIME =	%00
     92  0000 ????	       00 01	   DISPLAY_SCORE =	%01
     93  0000 ????	       00 02	   DISPLAY_LIVES =	%10
     94  0000 ????	       00 03	   DISPLAY_HIGH =	%11
     95  0000 ????
     96  0000 ????						;------------------------------------------------------------------------------
     97  0000 ????
     98  0000 ????	       00 00	   DIGITS     =	NO
     99  0000 ????	       00 01	   WAIT_FOR_INITIAL_DRAW =	YES	; blank until all initial tiles drawn
    100  0000 ????
    101  0000 ????						;------------------------------------------------------------------------------
    102  0000 ????
    103  0000 ????	       00 0a	   SCREEN_WIDTH =	10	; board characters per line (DIFFICULT TO CHANGE)
    104  0000 ????
    105  0000 ????	       00 08	   SCREEN_LINES =	8	; number of scanlines in screen buffer
    106  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    107  0000 ????
    108  0000 ????	       00 50	   SCREEN_ARRAY_SIZE =	SCREEN_WIDTH * SCREEN_LINES
    109  0000 ????
    110  0000 ????
    111  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    112  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    113  0000 ????
    114  0000 ????
    115  0000 ????						; color constants:
    116  0000 ????	       00 0e	   WHITE      =	$0e	; bright white, for NTSC and PAL
    117  0000 ????
    118  0000 ????	       10 00	   RAM_3E     =	$1000
    119  0000 ????	       04 00	   RAM_SIZE   =	$400
    120  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
    121  0000 ????
    122  0000 ????	       00 b4	   RND_EOR_VAL =	$b4
    123  0000 ????
    124  0000 ????
    125  0000 ????						; Platform constants:
    126  0000 ????	       00 02	   PAL	      =	%10
    127  0000 ????	       00 02	   PAL_50     =	PAL|0
    128  0000 ????	       00 03	   PAL_60     =	PAL|1
    129  0000 ????
    130  0000 ????
    131  0000 ????				      IF	L276
    132  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    133  0000 ????			  -	      ELSE
    134  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    135  0000 ????				      ENDIF
    136  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    137  0000 ????
    138  0000 ????				      IF	L276
    139  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    140  0000 ????			  -	      ELSE
    141  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    142  0000 ????				      ENDIF
    143  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    144  0000 ????
    145  0000 ????				      IF	L276
    146  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    147  0000 ????			  -	      ELSE
    148  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    149  0000 ????				      ENDIF
    150  0000 ????	       01 38	   SCANLINES_PAL =	312
    151  0000 ????
    152  0000 ????
    153  0000 ????						;------------------------------------------------------------------------------
    154  0000 ????						; MACRO definitions
    155  0000 ????
------- FILE macro2.h LEVEL 2 PASS 3
      0  0000 ????				      include	"macro2.h"
      1  0000 ????						; macros
      2  0000 ????
      3  0000 ????				      MAC	ntsc_to_pal
      4  0000 ????				      IF	{1} = 0
      5  0000 ????				      .byte	{1}+{2}
      6  0000 ????				      ENDIF
      7  0000 ????				      IF	{1} = $10
      8  0000 ????				      .byte	$20+{2}
      9  0000 ????				      ENDIF
     10  0000 ????				      IF	{1} = $20
     11  0000 ????				      .byte	$40+{2}
     12  0000 ????				      ENDIF
     13  0000 ????				      IF	{1} = $30
     14  0000 ????				      .byte	$40+{2}
     15  0000 ????				      ENDIF
     16  0000 ????				      IF	{1} = $40
     17  0000 ????				      .byte	$60+{2}
     18  0000 ????				      ENDIF
     19  0000 ????				      IF	{1} = $50
     20  0000 ????				      .byte	$80+{2}
     21  0000 ????				      ENDIF
     22  0000 ????				      IF	{1} = $60
     23  0000 ????				      .byte	$C0+{2}
     24  0000 ????				      ENDIF
     25  0000 ????				      IF	{1} = $70
     26  0000 ????				      .byte	$D0+{2}
     27  0000 ????				      ENDIF
     28  0000 ????				      IF	{1} = $80
     29  0000 ????				      .byte	$B0+{2}
     30  0000 ????				      ENDIF
     31  0000 ????				      IF	{1} = $90
     32  0000 ????				      .byte	$90+{2}
     33  0000 ????				      ENDIF
     34  0000 ????				      IF	{1} = $A0
     35  0000 ????				      .byte	$70+{2}
     36  0000 ????				      ENDIF
     37  0000 ????				      IF	{1} = $B0
     38  0000 ????				      .byte	$50+{2}
     39  0000 ????				      ENDIF
     40  0000 ????				      IF	{1} = $C0
     41  0000 ????				      .byte	$30+{2}
     42  0000 ????				      ENDIF
     43  0000 ????				      IF	{1} = $D0
     44  0000 ????				      .byte	$30+{2}
     45  0000 ????				      ENDIF
     46  0000 ????				      IF	{1} = $E0
     47  0000 ????				      .byte	$20+{2}
     48  0000 ????				      ENDIF
     49  0000 ????				      IF	{1} = $F0
     50  0000 ????				      .byte	$40+{2}
     51  0000 ????				      ENDIF
     52  0000 ????				      ENDM		; {col} {intensity}
------- FILE ./sokoboo.asm
    157  0000 ????
    158  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    159  0000 ????
    160  0000 ????				      MAC	newbank
    161  0000 ????				      SEG	{1}
    162  0000 ????				      ORG	ORIGIN
    163  0000 ????				      RORG	$F000
    164  0000 ????			   BANK_START SET	*
    165  0000 ????			   {1}	      SET	ORIGIN / 2048
    166  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    167  0000 ????			   _CURRENT_BANK SET	{1}
    168  0000 ????				      ENDM		; bank name
    169  0000 ????
    170  0000 ????				      MAC	define_1k_segment
    171  0000 ????				      ALIGN	$400
    172  0000 ????			   SEGMENT_{1} SET	*
    173  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    174  0000 ????				      ENDM		; {seg name}
    175  0000 ????
    176  0000 ????				      MAC	check_bank_size
    177  0000 ????			   .TEMP      =	* - BANK_START
    178  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    179  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE
    180  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    181  0000 ????				      ERR
    182  0000 ????				      endif
    183  0000 ????				      ENDM		; name
    184  0000 ????
    185  0000 ????
    186  0000 ????				      MAC	check_half_bank_size
    187  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    188  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    189  0000 ????			   .TEMP      =	* - BANK_START
    190  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    191  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE/2
    192  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    193  0000 ????				      ERR
    194  0000 ????				      endif
    195  0000 ????				      ENDM		; name
    196  0000 ????
    197  0000 ????
    198  0000 ????				      MAC	overlay
    199  0000 ????				      SEG.U	OVERLAY_{1}
    200  0000 ????				      org	Overlay
    201  0000 ????				      ENDM		; {name}
    202  0000 ????
    203  0000 ????						;--------------------------------------------------------------------------
    204  0000 ????
    205  0000 ????				      MAC	validate_overlay
    206  0000 ????				      LIST	OFF
    207  0000 ????				      if	* - Overlay > OVERLAY_SIZE
    208  0000 ????				      ECHO	"Overlay ", {1}, "too big"
    209  0000 ????				      ERR
    210  0000 ????				      endif
    211  0000 ????				      LIST	ON
    212  0000 ????				      ENDM
    213  0000 ????
    214  0000 ????						;--------------------------------------------------------------------------
    215  0000 ????						; Macro inserts a page break if the object would overlap a page
    216  0000 ????
    217  0000 ????				      MAC	optional_pagebreak
    218  0000 ????				      LIST	OFF
    219  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    220  0000 ????			   EARLY_LOCATION SET	*
    221  0000 ????				      ALIGN	256
    222  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR ", {1}
    223  0000 ????				      ECHO	"REQUESTED SIZE = ", {2}
    224  0000 ????				      ECHO	"WASTED SPACE = ", *-EARLY_LOCATION
    225  0000 ????				      ECHO	"PAGEBREAK LOCATION = ", *
    226  0000 ????				      ENDIF
    227  0000 ????				      LIST	ON
    228  0000 ????				      ENDM		; { string, size }
    229  0000 ????
    230  0000 ????
    231  0000 ????				      MAC	check_page_crossing
    232  0000 ????				      LIST	OFF
    233  0000 ????				      if	( >BLOCK_END != >BLOCK_START )
    234  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    235  0000 ????				      endif
    236  0000 ????				      LIST	ON
    237  0000 ????				      ENDM
    238  0000 ????
    239  0000 ????				      MAC	checkpage
    240  0000 ????				      LIST	OFF
    241  0000 ????				      IF	>. != >{1}
    242  0000 ????				      ECHO	""
    243  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    244  0000 ????				      ECHO	""
    245  0000 ????				      ERR
    246  0000 ????				      ENDIF
    247  0000 ????				      LIST	ON
    248  0000 ????				      ENDM
    249  0000 ????
    250  0000 ????				      MAC	checkpagex
    251  0000 ????				      LIST	OFF
    252  0000 ????				      IF	>. != >{1}
    253  0000 ????				      ECHO	""
    254  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    255  0000 ????				      ECHO	{2}
    256  0000 ????				      ECHO	""
    257  0000 ????				      ERR
    258  0000 ????				      ENDIF
    259  0000 ????				      LIST	ON
    260  0000 ????				      ENDM
    261  0000 ????
    262  0000 ????
    263  0000 ????				      MAC	checkpage_bne
    264  0000 ????				      LIST	OFF
    265  0000 ????				      IF	0	;>(. + 2) != >{1}
    266  0000 ????				      ECHO	""
    267  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    268  0000 ????				      ECHO	""
    269  0000 ????				      ERR
    270  0000 ????				      ENDIF
    271  0000 ????				      LIST	ON
    272  0000 ????				      bne	{1}
    273  0000 ????				      ENDM
    274  0000 ????
    275  0000 ????				      MAC	checkpage_bpl
    276  0000 ????				      LIST	OFF
    277  0000 ????				      IF	(>(.+2 )) != >{1}
    278  0000 ????				      ECHO	""
    279  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    280  0000 ????				      ECHO	""
    281  0000 ????				      ERR
    282  0000 ????				      ENDIF
    283  0000 ????				      LIST	ON
    284  0000 ????				      bpl	{1}
    285  0000 ????				      ENDM
    286  0000 ????
    287  0000 ????				      MAC	align_free
    288  0000 ????			   FREE       SET	FREE - .
    289  0000 ????				      align	{1}
    290  0000 ????			   FREE       SET	FREE + .
    291  0000 ????				      echo	"@", ., ":", FREE
    292  0000 ????				      ENDM
    293  0000 ????
    294  0000 ????						;--------------------------------------------------------------------------
    295  0000 ????
    296  0000 ????				      MAC	vector
    297  0000 ????				      .word	{1}
    298  0000 ????				      ENDM		; just a word pointer to code
    299  0000 ????
    300  0000 ????
    301  0000 ????				      MAC	define_subroutine
    302  0000 ????			   BANK_{1}   =	_CURRENT_BANK	; bank in which this subroutine resides
    303  0000 ????				      SUBROUTINE		; keep everything local
    304  0000 ????			   {1}			; entry point
    305  0000 ????				      ENDM		; name of subroutine
    306  0000 ????
    307  0000 ????
    308  0000 ????
    309  0000 ????						;--------------------------------------------------------------------------
    310  0000 ????
    311  0000 ????				      MAC	newrambank
    312  0000 ????				      SEG.U	{1}
    313  0000 ????				      ORG	ORIGIN_RAM
    314  0000 ????				      RORG	RAM_3E
    315  0000 ????			   BANK_START SET	*
    316  0000 ????			   {1}	      SET	ORIGIN_RAM / RAM_SIZE
    317  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    318  0000 ????				      ENDM		; bank name
    319  0000 ????
    320  0000 ????				      MAC	validate_ram_size
    321  0000 ????				      if	* - RAM_3E > RAM_SIZE
    322  0000 ????				      ERR
    323  0000 ????				      endif
    324  0000 ????				      ENDM
    325  0000 ????
    326  0000 ????				      MAC	next_random
    327  0000 ????						; update random value:
    328  0000 ????				      lda	rnd	; 3
    329  0000 ????				      lsr		; 2
    330  0000 ????				      IFCONST	rndHi
    331  0000 ????				      ror	rndHi	; 5	 16 bit LFSR
    332  0000 ????				      ENDIF
    333  0000 ????				      bcc	.skipEOR	; 2/3
    334  0000 ????				      eor	#RND_EOR_VAL	; 2
    335  0000 ????			   .skipEOR
    336  0000 ????				      sta	rnd	; 3 = 14/19
    337  0000 ????				      ENDM
    338  0000 ????
    339  0000 ????				      MAC	resync
    340  0000 ????						; resync screen, X and Y == 0 afterwards
    341  0000 ????				      lda	#%10	; make sure VBLANK is ON
    342  0000 ????				      sta	VBLANK
    343  0000 ????
    344  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    345  0000 ????			   .loopResync
    346  0000 ????				      VERTICAL_SYNC
    347  0000 ????
    348  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    349  0000 ????				      lda	Platform
    350  0000 ????				      eor	#PAL_50	; PAL-50?
    351  0000 ????				      bne	.ntsc
    352  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    353  0000 ????			   .ntsc
    354  0000 ????			   .loopWait
    355  0000 ????				      sta	WSYNC
    356  0000 ????				      sta	WSYNC
    357  0000 ????				      dey
    358  0000 ????				      bne	.loopWait
    359  0000 ????				      dex
    360  0000 ????				      bne	.loopResync
    361  0000 ????				      ENDM
    362  0000 ????
    363  0000 ????				      MAC	set_platform
    364  0000 ????						; 00 = NTSC
    365  0000 ????						; 01 = NTSC
    366  0000 ????						; 10 = PAL-50
    367  0000 ????						; 11 = PAL-60
    368  0000 ????				      lda	SWCHB
    369  0000 ????				      rol
    370  0000 ????				      rol
    371  0000 ????				      rol
    372  0000 ????				      and	#%11
    373  0000 ????				      eor	#PAL
    374  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    375  0000 ????				      ENDM
    376  0000 ????
    377  0000 ????				      MAC	load_animation
    378  0000 ????				      lda	#<Animation_{1}
    379  0000 ????				      sta	animation
    380  0000 ????				      lda	#>Animation_{1}
    381  0000 ????				      sta	animation+1
    382  0000 ????				      lda	#0
    383  0000 ????				      sta	animation_delay
    384  0000 ????				      lda	#ANIMATION_{1}_ID
    385  0000 ????				      sta	ManAnimationID
    386  0000 ????				      ENDM
    387  0000 ????
    388  0000 ????
    389  0000 ????						;------------------------------------------------------------------------------
    390  0000 ????
    391  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34 U00ff ????				      SEG.U	variables
     35 U0080					      ORG	$80
     36 U0080
     37 U0080
     38 U0080		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     39 U0081
     40 U0081		       00	   DrawStackPointer ds	1	; points to start entry of drawing stack (-1 = nothing to draw)
     41 U0082		       00	   ObjStackNum ds	1	; which stack in use
     42 U0083		       00 00	   ObjStackPtr ds	2	; index to objects on object stack (0 = empty)
     43 U0085		       00	   BlankStackPtr ds	1	; index to blank object stack (0=empty)
     44 U0086		       00	   ScreenDrawPhase ds	1	; phase of screen drawing
     45 U0087
     46 U0087		       00	   POS_X      ds	1
     47 U0088		       00	   POS_Y      ds	1
     48 U0089		       00	   POS_X_NEW  ds	1
     49 U008a		       00	   POS_Y_NEW  ds	1
     50 U008b		       00	   POS_Type   ds	1
     51 U008c		       00	   POS_VAR    ds	1
     52 U008d
     53 U008d		       00	   TB_X       ds	1
     54 U008e		       00	   TB_Y       ds	1
     55 U008f		       00	   TB_PUSHX   ds	1
     56 U0090		       00	   TB_PUSHY   ds	1
     57 U0091		       00	   TB_CHAR    ds	1
     58 U0092
     59 U0092		       00	   BufferedJoystick ds	1	; player joystick input
     60 U0093		       00	   PreviousJoystick ds	1
     61 U0094
     62 U0094							; Scrolling is limited to only show board within the following area...
     63 U0094		       00	   BoardLimit_Width ds	1	; width of current playfield (only used in UnpackLevel)
     64 U0095		       00	   BoardLimit_Height ds	1	; height of current playfield (only used in UnpackLevel)
     65 U0096		       00	   BoardScrollY ds	1	; scroll position in board (Y)
     66 U0097		       00	   BoardScrollX ds	1	; scroll position in board (X)
     67 U0097		       00 94	   BoardEdge_Right =	BoardLimit_Width	; absolute rightmost scroll value
     68 U0097		       00 95	   BoardEdge_Bottom =	BoardLimit_Height	; absolute bottommost scroll value
     69 U0098		       00	   scrollBits ds	1
     70 U0099
     71 U0099		       00	   animation_index ds	1	; new
     72 U009a		       00 00	   animation  ds	2
     73 U009c		       00	   animation_delay ds	1
     74 U009d		       00	   ManX       ds	1
     75 U009e		       00	   ManY       ds	1
     76 U009f		       00	   ManDrawX   ds	1
     77 U00a0		       00	   ManDrawY   ds	1
     78 U00a1		       00	   ManMode    ds	1
     79 U00a2		       00	   ManLastDirection ds	1	; so we don't overwrite animations in-progress
     80 U00a3		       00	   ManTurnStart ds	1
     81 U00a4		       00	   ManPushCounter ds	1
     82 U00a5		       00	   LookingAround ds	1
     83 U00a6		       00	   ManAnimationID ds	1
     84 U00a7		       00	   ManNextAnimationID ds	1	; -1 for nothing
     85 U00a8		       00	   idleCount  ds	1
     86 U00a9
     87 U00a9		       00	   DelayEndOfLevel ds	1
     88 U00aa		       00	   jtoggle    ds	1	; 0/1 toggles joystick on player swapping
     89 U00ab
     90 U00ab		       00	   LEVEL_bank ds	1
     91 U00ac		       00 00	   levelPtr   ds	2
     92 U00ae
     93 U00ae					      IF	WAIT_FOR_INITIAL_DRAW
     94 U00ae		       00	   blankState ds	1
     95 U00af					      ENDIF
     96 U00af
     97 U00af							;---------------------------------------------------------------------------
     98 U00af							; 2 (shared) demo mode variables:
     99 U00af							;demoMode			  = jtoggle	  ; bit 7==1 => demo mode
    100 U00af							;moveLen			  = jtoggle	  ; bits 0..6
    101 U00af							;moveIdx			 ds 1
    102 U00af
    103 U00af		       00	   LastSpriteY ds	1
    104 U00b0
    105 U00b0							;timer 			  ds 1
    106 U00b0
    107 U00b0		       00	   BGColour   ds	1
    108 U00b1
    109 U00b1							; levelx and level have to be consecutive variables!
    110 U00b1		       00	   levelX     ds	1	; current player's level (other in scoring bank)
    111 U00b2		       00	   level      ds	1	; current player's level (other in scoring bank)
    112 U00b3							;levelDisplay			   ds 1 	   ; what to display as the level ID
    113 U00b3		       00	   Throttle   ds	1	; frame throttle to prevent super-speeds
    114 U00b4							;ThrottleSpeed 		  ds 1		  ; system-dependant throttle speed
    115 U00b4
    116 U00b4		       00	   BCD_targetsRequired ds	1	; number of un-targeted left to go
    117 U00b5		       00	   BCD_moveCounter ds	1	; BCD seconds for level
    118 U00b6		       00	   BCD_moveCounterHi ds	1
    119 U00b7
    120 U00b7		       00	   takebackIndex ds	1
    121 U00b8		       00	   takebackBaseIndex ds	1
    122 U00b9		       00	   TakebackInhibit ds	1
    123 U00ba
    124 U00ba		       00 00	   Board_AddressR ds	2
    125 U00bc		       00 00	   Board_AddressW ds	2
    126 U00be		       00	   ROM_Bank   ds	1	; last switched ROM bank (not accessible if RAM subsequently switched)
    127 U00bf		       00	   RAM_Bank   ds	1
    128 U00c0
    129 U00c0		       00	   ColourTimer ds	1	; colour of BG in scoring area to show level flash/complete
    130 U00c1							;ColourFlash			  ds 1		   ; colour of flash
    131 U00c1							;extraLifeTimer		  ds 1		  ; should be 5 seconds!
    132 U00c1
    133 U00c1							; extraLifeTimer:
    134 U00c1							;   When non-zero causes Cosmic Ark star effect in background. Used to indicate extra life.
    135 U00c1
    136 U00c1							;scoringTimer			  ds 1		  ; times the various score displays
    137 U00c1							;scoringFlags			  ds 1		  ; scoring flags are stored here
    138 U00c1
    139 U00c1							; scoringFlags:
    140 U00c1							; D7		 Extra TARGETs in effect (TARGETs collected over requirement score more) ASSUMED BPL/BMI usage
    141 U00c1							; D6		 unused
    142 U00c1							; D5		 unused
    143 U00c1							; D4		 unused
    144 U00c1							; D3		 unused
    145 U00c1							; D2		 unused
    146 U00c1							; D1	 D1-D0	 Which display kernel to use for scoring
    147 U00c1							; D0		 0 = 2x4     used for TARGETs/time
    148 U00c1							;		 1 = 1x6     used for score
    149 U00c1							;		 2 = 3x2     used for level/lives/player
    150 U00c1
    151 U00c1		       00	   NextLevelTrigger ds	1	; d7 -- next level.  d6 -- loss of life
    152 U00c1		       00 80	   BIT_NEXTLEVEL =	128
    153 U00c1		       00 40	   BIT_NEXTLIFE =	64
    154 U00c2
    155 U00c2							;------------------------------------------------------------------------------
    156 U00c2
    157 U00c2		       00	   ObjIterator ds	1	; count UP iterator over objects
    158 U00c3		       00	   DSL	      ds	1	; stack line counter
    159 U00c4
    160 U00c4		       00	   ethnic     ds	1
    161 U00c5		       00	   animate_char_index ds	1
    162 U00c6
    163 U00c6		       00	   rndHi      ds	1
    164 U00c7		       00	   rnd	      ds	1
    165 U00c8		       00 00 00    icc_colour ds	3
    166 U00cb		       00	   FadeComplete ds	1
    167 U00cc		       00	   FadeOutComplete ds	1
    168 U00cd		       00	   fadeslow   ds	1
    169 U00ce
    170 U00ce		       00 00	   seconds    ds	2
    171 U00d0
------- FILE sound/intro1_variables.asm LEVEL 3 PASS 3
      0 U00d0					      include	"sound/intro1_variables.asm"
      1 U00d0							; TIATracker music player
      2 U00d0							; Copyright 2016 Andre "Kylearan" Wichmann
      3 U00d0							; Website: https://bitbucket.org/kylearan/tiatracker
      4 U00d0							; Email: andre.wichmann@gmx.de
      5 U00d0							;
      6 U00d0							; Licensed under the Apache License, Version 2.0 (the "License");
      7 U00d0							; you may not use this file except in compliance with the License.
      8 U00d0							; You may obtain a copy of the License at
      9 U00d0							;
     10 U00d0							;   http://www.apache.org/licenses/LICENSE-2.0
     11 U00d0							;
     12 U00d0							; Unless required by applicable law or agreed to in writing, software
     13 U00d0							; distributed under the License is distributed on an "AS IS" BASIS,
     14 U00d0							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15 U00d0							; See the License for the specific language governing permissions and
     16 U00d0							; limitations under the License.
     17 U00d0
     18 U00d0							; Song author: 
     19 U00d0							; Song name: 
     20 U00d0
     21 U00d0							; @com.wudsn.ide.asm.hardware=ATARI2600
     22 U00d0
     23 U00d0							; =====================================================================
     24 U00d0							; Flags
     25 U00d0							; =====================================================================
     26 U00d0
     27 U00d0							; 1: Global song speed, 0: Each pattern has individual speed
     28 U00d0		       00 01	   TT_GLOBAL_SPEED =	1
     29 U00d0							; duration (number of TV frames) of a note
     30 U00d0		       00 05	   TT_SPEED   =	5
     31 U00d0							; duration of odd frames (needs TT_USE_FUNKTEMPO)
     32 U00d0		       00 04	   TT_ODD_SPEED =	4
     33 U00d0
     34 U00d0							; 1: Overlay percussion, +40 bytes
     35 U00d0		       00 01	   TT_USE_OVERLAY =	1
     36 U00d0							; 1: Melodic instrument slide, +9 bytes
     37 U00d0		       00 00	   TT_USE_SLIDE =	0
     38 U00d0							; 1: Goto pattern, +8 bytes
     39 U00d0		       00 01	   TT_USE_GOTO =	1
     40 U00d0							; 1: Odd/even rows have different SPEED values, +7 bytes
     41 U00d0		       00 01	   TT_USE_FUNKTEMPO =	1
     42 U00d0							; If the very first notes played on each channel are not PAUSE, HOLD or
     43 U00d0							; SLIDE, i.e. if they start with an instrument or percussion, then set
     44 U00d0							; this flag to 0 to save 2 bytes.
     45 U00d0							; 0: +2 bytes
     46 U00d0		       00 01	   TT_STARTS_WITH_NOTES =	1
     47 U00d0
     48 U00d0
     49 U00d0							; =====================================================================
     50 U00d0							; Permanent variables. These are states needed by the player.
     51 U00d0							; =====================================================================
     52 U00d0		       00	   tt_timer   ds	1	; current music timer value
     53 U00d1		       00	   tt_cur_pat_index_c0 ds	1	; current pattern index into tt_SequenceTable
     54 U00d2		       00	   tt_cur_pat_index_c1 ds	1
     55 U00d3		       00	   tt_cur_note_index_c0 ds	1	; note index into current pattern
     56 U00d4		       00	   tt_cur_note_index_c1 ds	1
     57 U00d5		       00	   tt_envelope_index_c0 ds	1	; index into ADSR envelope
     58 U00d6		       00	   tt_envelope_index_c1 ds	1
     59 U00d7		       00	   tt_cur_ins_c0 ds	1	; current instrument
     60 U00d8		       00	   tt_cur_ins_c1 ds	1
     61 U00d9
     62 U00d9
     63 U00d9							; =====================================================================
     64 U00d9							; Temporary variables. These will be overwritten during a call to the
     65 U00d9							; player routine, but can be used between calls for other things.
     66 U00d9							; =====================================================================
     67 U00d9		       00 00	   tt_ptr     ds	2
------- FILE zeropage.asm
    173 U00db
    174 U00db
    175 U00db
    176 U00db				   OVERLAY_SIZE SET	24
    177 U00db
    178 U00db
    179 U00db
    180 U00db							; This overlay variable is used for the overlay variables.  That's OK.
    181 U00db							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
    182 U00db							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
    183 U00db							; (especially the latter ones) are only used in rare occasions.
    184 U00db
    185 U00db							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
    186 U00db							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
    187 U00db
    188 U00db		       00 00 00 00*Overlay    ds	OVERLAY_SIZE	;--> overlay (share) variables
      0 U00f3					      VALIDATE_OVERLAY	"DEFINITION"
      6 U00f3					      LIST	ON
    190 U00f3
    191 U00f3
    192 U00f3		       00 00 00 00*	      ds	RESERVED_FOR_STACK
    193 U00ff
 FREE BYTES IN ZERO PAGE =  $0
    194 U00ff					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    195 U00ff				  -	      IF	* > $FF
    196 U00ff				  -	      ERR
    197 U00ff					      ENDIF
------- FILE ./sokoboo.asm
    393 U00ff
    394 U00ff
    395 U00ff							;------------------------------------------------------------------------------
    396 U00ff							; OVERLAYS!
    397 U00ff							; These variables are overlays, and should be managed with care
    398 U00ff							; That is, variables are ALREADY DEFINED, and we're reusing RAM for other purposes
    399 U00ff
    400 U00ff							; EACH OF THESE ARE VARIABLES (TEMPORARY) USED BY ONE ROUTINE (AND IT'S SUBROUTINES)
    401 U00ff							; THAT IS, LOCAL VARIABLES.  USE 'EM FREELY, THEY COST NOTHING
    402 U00ff
    403 U00ff							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
    404 U00ff
    405 U00ff
    406 U00ff							;------------------------------------------------------------------------------
      0 U00ff					      OVERLAY	GenerateHighScoreCode
      1 U00ef ????				      SEG.U	OVERLAY_GenerateHighScoreCode
      2 U00db					      org	Overlay
    408 U00db
    409 U00db		       00 00 00 00*decimal    ds	12	; MUST be 1st - same var as codeDigit
    410 U00e7		       00 00	   binMoves   ds	2
    411 U00e9		       00 00 00 00*encoding   ds	5
    412 U00ee		       00	   randomiser ds	1
    413 U00ef
      0 U00ef					      VALIDATE_OVERLAY	"GenerateHighScoreCode"
      6 U00ef					      LIST	ON
    415 U00ef
    416 U00ef							;------------------------------------------------------------------------------
      0 U00ef					      OVERLAY	BuildDrawFlags
      1 U00e6 ????				      SEG.U	OVERLAY_BuildDrawFlags
      2 U00db					      org	Overlay
    418 U00db
    419 U00db		       00 00	   BDF_DrawFlagAddress ds	2	; destination address of draw flag (mirrors ScreenBuffer)
    420 U00dd		       00 00	   BDF_DrawFlagAddress2 ds	2	; dito + SCREEN_WIDTH/2
    421 U00df		       00 00	   BDF_BoardAddress ds	2	; source address from Board
    422 U00e1		       00 00	   BDF_BoardAddress2 ds	2	; dito + SCREEN_WIDTH/2
    423 U00e3							;  IF MULTI_BANK_BOARD = YES		      ; commented, else DASM freaks out because MULTI_BANK_BOARD is calculated below
    424 U00e3		       00	   BDF_BoardBank ds	1	; holds bank of current line
    425 U00e4							;  ENDIF
    426 U00e4		       00	   DHS_Line   ds	1
    427 U00e5		       00	   DHS_Stack  ds	1	; for restoring SP
    428 U00e6							;ECHO "FREE BYTES IN OVERLAY_BuildDrawFlags = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e6					      VALIDATE_OVERLAY	"BuildDrawFlags"
      6 U00e6					      LIST	ON
    430 U00e6
    431 U00e6							;------------------------------------------------------------------------------
    432 U00e6
      0 U00e6					      OVERLAY	ColourFixer
      1 U00dd ????				      SEG.U	OVERLAY_ColourFixer
      2 U00db					      org	Overlay
    434 U00db
    435 U00db		       00	   PlatformBase ds	1
    436 U00dc		       00	   BandOffsetTemp ds	1
    437 U00dd
      0 U00dd					      VALIDATE_OVERLAY	"ColourFixer"
      6 U00dd					      LIST	ON
    439 U00dd
      0 U00dd					      OVERLAY	LevelLookup
      1 U00dd ????				      SEG.U	OVERLAY_LevelLookup
      2 U00db					      org	Overlay
    441 U00db		       00 00	   levelTable ds	2
      0 U00dd					      VALIDATE_OVERLAY	"LevelLookup"
      6 U00dd					      LIST	ON
    443 U00dd
    444 U00dd							;------------------------------------------------------------------------------
    445 U00dd
      0 U00dd					      OVERLAY	Animator
      1 U00e1 ????				      SEG.U	OVERLAY_Animator
      2 U00db					      org	Overlay
    447 U00db		       00 00	   frame_ptr  ds	2
    448 U00dd		       00 00	   colour_ptr ds	2
    449 U00df		       00	   bank       ds	1
    450 U00e0		       00	   ethnicity  ds	1
      0 U00e1					      VALIDATE_OVERLAY	"Animator"
      6 U00e1					      LIST	ON
    452 U00e1
    453 U00e1
      0 U00e1					      OVERLAY	Process
      1 U00de ????				      SEG.U	OVERLAY_Process
      2 U00db					      org	Overlay
    455 U00db
    456 U00db		       00	   BOXLeft    ds	1
    457 U00dc		       00	   BOXRight   ds	1
    458 U00dd		       00	   restorationCharacter ds	1
    459 U00de
      0 U00de					      VALIDATE_OVERLAY	"Process"
      6 U00de					      LIST	ON
    461 U00de
    462 U00de							;------------------------------------------------------------------------------
    463 U00de
    464 U00de
      0 U00de					      OVERLAY	Animate
      1 U00dc ????				      SEG.U	OVERLAY_Animate
      2 U00db					      org	Overlay
    466 U00db		       00	   halftimer  ds	1
      0 U00dc					      VALIDATE_OVERLAY	"Animate"
      6 U00dc					      LIST	ON
    468 U00dc
    469 U00dc							;------------------------------------------------------------------------------
    470 U00dc
      0 U00dc					      OVERLAY	LevelScreen
      1 U00f3 ????				      SEG.U	OVERLAY_LevelScreen
      2 U00db					      org	Overlay
    472 U00db		       00 00	   colour_table ds	2
    473 U00dd		       00 00	   digit1     ds	2
    474 U00df		       00 00	   digit2     ds	2
    475 U00e1		       00 00	   digitstar  ds	2
    476 U00e3		       00 00 00    digit      ds	3
    477 U00e6		       00	   digitick   ds	1
    478 U00e7		       00 00 00    targetDigit ds	3
    479 U00ea		       00	   endwait    ds	1
    480 U00eb							;colourindex		  ds 1
    481 U00eb		       00 00	   digitHundreds ds	2
    482 U00ed		       00	   selector   ds	1
    483 U00ee		       00	   walkSpeed  ds	1
    484 U00ef		       00 00	   manc       ds	2
    485 U00f1		       00	   wallColour ds	1
    486 U00f2		       00	   adjustColour ds	1
      0 U00f3					      VALIDATE_OVERLAY	"LevelScreen"
      6 U00f3					      LIST	ON
    488 U00f3
    489 U00f3
      0 U00f3					      OVERLAY	TitleScreen
      1 U00dd ????				      SEG.U	OVERLAY_TitleScreen
      2 U00db					      org	Overlay
    491 U00db		       00 00	   title_colour_table ds	2
      0 U00dd					      VALIDATE_OVERLAY	"TitleScreen"
      6 U00dd					      LIST	ON
    493 U00dd
    494 U00dd
    495 U00dd
      0 U00dd					      OVERLAY	CodeScreen
      1 U00f2 ????				      SEG.U	OVERLAY_CodeScreen
      2 U00db					      org	Overlay
    497 U00db		       00 00 00 00*codeDigit  ds	12	; MUST be 1st - same var as decimal
    498 U00e7		       00 00	   bigdigit0  ds	2
    499 U00e9		       00 00	   bigdigit1  ds	2
    500 U00eb		       00 00	   bigdigit2  ds	2
    501 U00ed		       00 00	   bigdigit3  ds	2
    502 U00ef		       00	   codeTemp   ds	1
    503 U00f0		       00 00	   codeDelay  ds	2
      0 U00f2					      VALIDATE_OVERLAY	"CodeScreen"
      6 U00f2					      LIST	ON
    505 U00f2
    506 U00f2
    507 U00f2							;------------------------------------------------------------------------------
    508 U00f2
      0 U00f2					      OVERLAY	TimeSlice
      1 U00dd ????				      SEG.U	OVERLAY_TimeSlice
      2 U00db					      org	Overlay
    510 U00db
    511 U00db		       00 00	   TS_Vector  ds	2	; vector to correct processing code
    512 U00dd							;ECHO "FREE BYTES IN OVERLAY_TimeSlice = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dd					      VALIDATE_OVERLAY	"TimeSlice"
      6 U00dd					      LIST	ON
    514 U00dd
    515 U00dd							;------------------------------------------------------------------------------
    516 U00dd
      0 U00dd					      OVERLAY	CopyROMShadowToRAM
      1 U00de ????				      SEG.U	OVERLAY_CopyROMShadowToRAM
      2 U00db					      org	Overlay
    518 U00db
    519 U00db		       00	   O_CopyCount ds	1
    520 U00dc		       00	   O_ROM_Source_Bank ds	1
    521 U00dd		       00	   O_Index    ds	1
    522 U00de							;ECHO "FREE BYTES IN OVERLAY_CopyROMShadowToRAM = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00de					      VALIDATE_OVERLAY	"CopyROMShadowToRAM"
      6 U00de					      LIST	ON
    524 U00de
    525 U00de							;------------------------------------------------------------------------------
    526 U00de
      0 U00de					      OVERLAY	Scoring
      1 U00dc ????				      SEG.U	OVERLAY_Scoring
      2 U00db					      org	Overlay
    528 U00db		       00	   tmpStack   ds	1
    529 U00db		       00 db	   newDisplay =	tmpStack
    530 U00dc							; also for UpdateTimer
    531 U00dc		       00 db	   tmpSound   =	tmpStack
      0 U00dc					      VALIDATE_OVERLAY	"Scoring"
      6 U00dc					      LIST	ON
    533 U00dc
    534 U00dc
    535 U00dc							;------------------------------------------------------------------------------
    536 U00dc
      0 U00dc					      OVERLAY	SaveKey
      1 U00e4 ????				      SEG.U	OVERLAY_SaveKey
      2 U00db					      org	Overlay
    538 U00db
    539 U00db		       00 00 00    dummySK    ds	3	; avoid getting overwritten by CopyROMShadowToRAM
    540 U00de		       00 00 00    highScoreSK ds	3
    541 U00e1		       00	   startingLevel ds	1	; levelx * 5
    542 U00e2		       00	   startLevel ds	1
    543 U00e3		       00	   offsetSK   ds	1	; for calculating the SK slot address
    544 U00e4
      0 U00e4					      VALIDATE_OVERLAY	"SaveKey"
      6 U00e4					      LIST	ON
    546 U00e4
    547 U00e4							;------------------------------------------------------------------------------
    548 U00e4
      0 U00e4					      OVERLAY	DrawMan
      1 U00dd ????				      SEG.U	OVERLAY_DrawMan
      2 U00db					      org	Overlay
    550 U00db
    551 U00db		       00 00	   MAN_Move   ds	2
    552 U00dd
    553 U00dd							;ECHO "FREE BYTES IN OVERLAY_DrawMan = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dd					      VALIDATE_OVERLAY	"DrawMan"
      6 U00dd					      LIST	ON
    555 U00dd
    556 U00dd							;------------------------------------------------------------------------------
    557 U00dd
      0 U00dd					      OVERLAY	ProcessObjStack
      1 U00dd ????				      SEG.U	OVERLAY_ProcessObjStack
      2 U00db					      org	Overlay
    559 U00db
    560 U00db		       00 00	   POS_Vector ds	2
    561 U00dd
    562 U00dd							;ECHO "FREE BYTES IN OVERLAY_ProcessObjStack = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dd					      VALIDATE_OVERLAY	"ProcessObjStack"
      6 U00dd					      LIST	ON
    564 U00dd
    565 U00dd							;------------------------------------------------------------------------------
    566 U00dd
      0 U00dd					      OVERLAY	ScoreLineOverlay
      1 U00ea ????				      SEG.U	OVERLAY_ScoreLineOverlay
      2 U00db					      org	Overlay
    568 U00db
    569 U00db		       00 00	   S0	      ds	2	; used for addressing digits of score
    570 U00dd		       00 00	   S1	      ds	2
    571 U00df		       00 00	   S2	      ds	2
    572 U00e1		       00 00	   S3	      ds	2
    573 U00e3		       00 00	   S4	      ds	2
    574 U00e5		       00 00	   S5	      ds	2
    575 U00e7
    576 U00e7		       00	   stkp       ds	1
    577 U00e8		       00	   sreg       ds	1
    578 U00e9		       00	   loop       ds	1
    579 U00ea
    580 U00ea							;ECHO "FREE BYTES IN ScoreLineOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00ea					      VALIDATE_OVERLAY	"ScoreLineOverlay"
      6 U00ea					      LIST	ON
    582 U00ea
    583 U00ea							;------------------------------------------------------------------------------
    584 U00ea
    585 U00ea
      0 U00ea					      OVERLAY	UnpackLevelOverlay
      1 U00e0 ????				      SEG.U	OVERLAY_UnpackLevelOverlay
      2 U00db					      org	Overlay
    587 U00db
    588 U00db		       00	   base_x     ds	1
    589 U00dc		       00	   base_y     ds	1
    590 U00dd		       00	   upk_length ds	1
    591 U00de		       00	   upk_column ds	1
    592 U00df		       00	   upk_temp   ds	1
    593 U00e0							;icc_colour		  ds 3
    594 U00e0
    595 U00e0							;ECHO "FREE BYTES IN UnpackLevelOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e0					      VALIDATE_OVERLAY	"UnpackLevelOverlay"
      6 U00e0					      LIST	ON
    597 U00e0
    598 U00e0							;------------------------------------------------------------------------------
    599 U00e0
      0 U00e0					      OVERLAY	ManProcessing
      1 U00dd ????				      SEG.U	OVERLAY_ManProcessing
      2 U00db					      org	Overlay
    601 U00db		       00 00	   actionVector ds	2
      0 U00dd					      VALIDATE_OVERLAY	"ManProcessing"
      6 U00dd					      LIST	ON
    603 U00dd
      0 U00dd					      OVERLAY	DrawIntoStack
      1 U00dc ????				      SEG.U	OVERLAY_DrawIntoStack
      2 U00db					      org	Overlay
    605 U00db		       00	   save_SP    ds	1
      0 U00dc					      VALIDATE_OVERLAY	"DrawIntoStack"
      6 U00dc					      LIST	ON
    607 U00dc
    608 U00dc							;------------------------------------------------------------------------------
    609 U00dc							;##############################################################################
    610 U00dc							;------------------------------------------------------------------------------
    611 U00dc
    612 U00dc							; NOW THE VERY INTERESTING '3E' RAM BANKS
    613 U00dc							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 2k TOTAL
    614 U00dc
      0 U00dc					      NEWRAMBANK	BANK_SCREENMARKII1
      1 U0000 ????				      SEG.U	BANK_SCREENMARKII1
      2 U0000					      ORG	ORIGIN_RAM
      3 U0000					      RORG	RAM_3E
      4 U0000				   BANK_START SET	*
      5 U0000				   BANK_SCREENMARKII1 SET	ORIGIN_RAM / RAM_SIZE
      6 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    616 U0000
    617 U0000							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    618 U0000							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    619 U0000							; The variable definitions are also in that ROM bank (even though they're RAM :)
    620 U0000
    621 U0000		       00 60	   SCREEN_BITMAP_SIZE =	4 * LINES_PER_CHAR
    622 U0000
    623 U0000							; These banks (there are #SCREEN_LINES of them) hold a RAM copy of the screen draw
    624 U0000							; code.  This code is self-modifying, in that the colour values for each scanline
    625 U0000							; are set to NTSC or PAL values on startup -- thus, the single binary can run
    626 U0000							; on either format system.  The main purpose for copying the draw code to RAM,
    627 U0000							; though, is to free up space in the fixed bank (which is incredibly valuable).
    628 U0000
    629 U0000							; A neat feature of having multiple copies of the same code in different RAM banks
    630 U0000							; is that we can use that code to switch between banks, and the system will happily
    631 U0000							; execute the next instruction from the newly switched-in bank without a problem.
    632 U0000
    633 U0000							; Now we have the actual graphics data for each of the rows.  This consists of an
    634 U0000							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    635 U0000							; character shapes are masked/copied. The depth of the character shapes may be
    636 U0000							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    637 U0000							; a multiple of 3, so that the RGB scanlines match at character joins.
    638 U0000
    639 U0000							; The next part of the graphics data is a bitmap sprite buffer -- space for two
    640 U0000							; sprites' graphics shape and colour data.  The shape and colour may be set as
    641 U0000							; part of the draw routine *every* scanline (though the system currently uses
    642 U0000							; one colour shared between both players).
    643 U0000
      0 U0000					      VALIDATE_RAM_SIZE
      1 U0000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0000				  -	      ERR
      3 U0000					      endif
    645 U0000
    646 U0000							; We have one bank for each screen row.  These banks are duplicates of the above,
    647 U0000							; accessed via the above labels but with the appropriate bank switched in.
    648 U0000
    649 U0000							;------------------------------------------------------------------------------
    650 U0000
    651 U0000					      REPEAT	SCREEN_LINES - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U1c00 ????				      SEG.U	.DUMMY
      2 U0400					      ORG	ORIGIN_RAM
      3 U0400					      RORG	RAM_3E
      4 U0400				   BANK_START SET	*
      5 U0400				   .DUMMY     SET	ORIGIN_RAM / RAM_SIZE
      6 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0400				  -	      ERR
      3 U0400					      endif
    651 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400					      SEG.U	.DUMMY
      2 U0800					      ORG	ORIGIN_RAM
      3 U0800					      RORG	RAM_3E
      4 U0800				   BANK_START SET	*
      5 U0800				   .DUMMY     SET	ORIGIN_RAM / RAM_SIZE
      6 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0800				  -	      ERR
      3 U0800					      endif
    651 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800					      SEG.U	.DUMMY
      2 U0c00					      ORG	ORIGIN_RAM
      3 U0c00					      RORG	RAM_3E
      4 U0c00				   BANK_START SET	*
      5 U0c00				   .DUMMY     SET	ORIGIN_RAM / RAM_SIZE
      6 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0c00				  -	      ERR
      3 U0c00					      endif
    651 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00					      SEG.U	.DUMMY
      2 U1000					      ORG	ORIGIN_RAM
      3 U1000					      RORG	RAM_3E
      4 U1000				   BANK_START SET	*
      5 U1000				   .DUMMY     SET	ORIGIN_RAM / RAM_SIZE
      6 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1000				  -	      ERR
      3 U1000					      endif
    651 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000					      SEG.U	.DUMMY
      2 U1400					      ORG	ORIGIN_RAM
      3 U1400					      RORG	RAM_3E
      4 U1400				   BANK_START SET	*
      5 U1400				   .DUMMY     SET	ORIGIN_RAM / RAM_SIZE
      6 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1400				  -	      ERR
      3 U1400					      endif
    651 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400					      SEG.U	.DUMMY
      2 U1800					      ORG	ORIGIN_RAM
      3 U1800					      RORG	RAM_3E
      4 U1800				   BANK_START SET	*
      5 U1800				   .DUMMY     SET	ORIGIN_RAM / RAM_SIZE
      6 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1800				  -	      ERR
      3 U1800					      endif
    651 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800					      SEG.U	.DUMMY
      2 U1c00					      ORG	ORIGIN_RAM
      3 U1c00					      RORG	RAM_3E
      4 U1c00				   BANK_START SET	*
      5 U1c00				   .DUMMY     SET	ORIGIN_RAM / RAM_SIZE
      6 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1c00				  -	      ERR
      3 U1c00					      endif
    654 U1c00					      REPEND
    655 U1c00
    656 U1c00							;------------------------------------------------------------------------------
    657 U1c00							;##############################################################################
    658 U1c00							;------------------------------------------------------------------------------
    659 U1c00
      0 U1c00					      NEWRAMBANK	BANK_DRAW_BUFFERS
      1 U2000 ????				      SEG.U	BANK_DRAW_BUFFERS
      2 U2000					      ORG	ORIGIN_RAM
      3 U2000					      RORG	RAM_3E
      4 U2000				   BANK_START SET	*
      5 U2000				   BANK_DRAW_BUFFERS SET	ORIGIN_RAM / RAM_SIZE
      6 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    661 U2000							; VARS DEFINED IN ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    662 U2000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2000					      VALIDATE_RAM_SIZE
      1 U2000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2000				  -	      ERR
      3 U2000					      endif
    664 U2000
    665 U2000							;------------------------------------------------------------------------------
    666 U2000							;##############################################################################
    667 U2000							;------------------------------------------------------------------------------
    668 U2000
      0 U2000					      NEWRAMBANK	BANK_SCORING
      1 U2400 ????				      SEG.U	BANK_SCORING
      2 U2400					      ORG	ORIGIN_RAM
      3 U2400					      RORG	RAM_3E
      4 U2400				   BANK_START SET	*
      5 U2400				   BANK_SCORING SET	ORIGIN_RAM / RAM_SIZE
      6 U2400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    670 U2400							; VARS DEFINED IN ROM_SHADOW_OF_BANK_SCORING
    671 U2400							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2400					      VALIDATE_RAM_SIZE
      1 U2400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2400				  -	      ERR
      3 U2400					      endif
    673 U2400
    674 U2400							;------------------------------------------------------------------------------
    675 U2400							;##############################################################################
    676 U2400							;------------------------------------------------------------------------------
    677 U2400
      0 U2400					      NEWRAMBANK	BANK_DECODE_LEVEL
      1 U2800 ????				      SEG.U	BANK_DECODE_LEVEL
      2 U2800					      ORG	ORIGIN_RAM
      3 U2800					      RORG	RAM_3E
      4 U2800				   BANK_START SET	*
      5 U2800				   BANK_DECODE_LEVEL SET	ORIGIN_RAM / RAM_SIZE
      6 U2800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    679 U2800							; VARS DEFINED IN BANK_DECODE_LEVEL_SHADOW
    680 U2800							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2800					      VALIDATE_RAM_SIZE
      1 U2800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2800				  -	      ERR
      3 U2800					      endif
    682 U2800
    683 U2800							;------------------------------------------------------------------------------
    684 U2800							;##############################################################################
    685 U2800							;------------------------------------------------------------------------------
    686 U2800
      0 U2800					      NEWRAMBANK	BANK_OBJSTACK
      1 U2e80 ????				      SEG.U	BANK_OBJSTACK
      2 U2c00					      ORG	ORIGIN_RAM
      3 U2c00					      RORG	RAM_3E
      4 U2c00				   BANK_START SET	*
      5 U2c00				   BANK_OBJSTACK SET	ORIGIN_RAM / RAM_SIZE
      6 U2c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    688 U2c00
    689 U2c00							; The objects are a list of X,Y positions into the BOARD.  Each of these is a board
    690 U2c00							; position of something that needs to be processed.  These things include anything
    691 U2c00							; that animates.  Objects which no longer need processing do not re-add themselves
    692 U2c00							; to the object stack.  There are two stacks -- the one being processed, and the
    693 U2c00							; one for the next processing iteration.
    694 U2c00
    695 U2c00							; Note: These are referenced by ObjStackNum, as is the BLANK_STACK paired bank set.
    696 U2c00
    697 U2c00		       00 80	   OBJ_STACK_SIZE =	128
    698 U2c00
    699 U2c00							; WARNING: THESE MUST NOT CROSS PAGE BOUNDARIES!!!
    700 U2c00
    701 U2c00		       00 00 00 00*ObjStackX  ds	OBJ_STACK_SIZE
    702 U2c80		       00 00 00 00*ObjStackY  ds	OBJ_STACK_SIZE
    703 U2d00		       00 00 00 00*ObjStackVar ds	OBJ_STACK_SIZE	; for general use
    704 U2d80
    705 U2d80							; SortedObjPtr is now in the middle of a page, thus allowing to address with -1
    706 U2d80		       00 00 00 00*SortedObjPtr ds	OBJ_STACK_SIZE	; list of indexes of objects (sorted)
    707 U2e00
    708 U2e00		       00 00 00 00*ObjStackType ds	OBJ_STACK_SIZE	; type of object
    709 U2e80
 FREE RAM IN BANK_OBJSTACK =  $180
    710 U2e80					      ECHO	"FREE RAM IN BANK_OBJSTACK = ", RAM_SIZE - ( * - BANK_START )
    711 U2e80
      0 U2e80					      VALIDATE_RAM_SIZE
      1 U2e80				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2e80				  -	      ERR
      3 U2e80					      endif
    713 U2e80
    714 U2e80							;------------------------------------------------------------------------------
    715 U2e80
      0 U2e80					      NEWRAMBANK	BANK_OBJSTACK2
      1 U3000 ????				      SEG.U	BANK_OBJSTACK2
      2 U3000					      ORG	ORIGIN_RAM
      3 U3000					      RORG	RAM_3E
      4 U3000				   BANK_START SET	*
      5 U3000				   BANK_OBJSTACK2 SET	ORIGIN_RAM / RAM_SIZE
      6 U3000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    717 U3000							; THIS IS A MIRROR OF BANK_OBJSTACK -- DO NOT MODIFY OR USE!!
      0 U3000					      VALIDATE_RAM_SIZE
      1 U3000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U3000				  -	      ERR
      3 U3000					      endif
    719 U3000
    720 U3000							;------------------------------------------------------------------------------
    721 U3000							;##############################################################################
    722 U3000							;------------------------------------------------------------------------------
    723 U3000
      0 U3000					      NEWRAMBANK	BANK_BOARD
      1 U3800 ????				      SEG.U	BANK_BOARD
      2 U3400					      ORG	ORIGIN_RAM
      3 U3400					      RORG	RAM_3E
      4 U3400				   BANK_START SET	*
      5 U3400				   BANK_BOARD SET	ORIGIN_RAM / RAM_SIZE
      6 U3400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    725 U3400
    726 U3400							; Now the interesting 'BOARD' -- which in reality is a free-form system of M*N
    727 U3400							; rows and columns.  We need to reserve enough RAM for the board's entirety, but
    728 U3400							; don't really care much how it overlaps the 1K bank limit.  The code accessing
    729 U3400							; the board *MUST* calculate and take account of the correct RAM bank to switch
    730 U3400							; when accessing.
    731 U3400
    732 U3400							; The system is fairly free-form, in that it rearranges the memory and tables
    733 U3400							; automatically based on the sizes set in these constants. The board may overlay
    734 U3400							; MULTIPLE banks -- just as long as any particular LINE does not cross a bank
    735 U3400							; we're doing OK.
    736 U3400
    737 U3400							; NOTE: Assumption is that board lines CANNOT CROSS page boundaries.
    738 U3400
    739 U3400							; now fits into one single bank (if we don't reserve too much space for code)
    740 U3400
    741 U3400		       00 20	   SIZE_BOARD_X =	32	;
    742 U3400		       00 20	   SIZE_BOARD_Y =	32
    743 U3400
    744 U3400				  -	      IF	SIZE_BOARD_X * SIZE_BOARD_Y > RAM_SIZE
    745 U3400				  -	      ECHO	"ERROR: Board too big for single bank usage"
    746 U3400				  -	      ERR
    747 U3400					      ENDIF
    748 U3400
    749 U3400
    750 U3400
    751 U3400				  -	      IF	SIZE_BOARD > RAM_SIZE
    752 U3400				  -MULTI_BANK_BOARD =	YES
    753 U3400					      ELSE
    754 U3400		       00 00	   MULTI_BANK_BOARD =	NO	; timings: [-..]
    755 U3400					      ENDIF
    756 U3400
    757 U3400		       00 00 00 00*Board      ds	SIZE_BOARD	; Note, we can only access this in
    758 U3800							; 1024 byte chunks, switching RAM
    759 U3800							; banks as we go.  In other words,
    760 U3800							; this overlaps multiple banks!
    761 U3800
      0 U3800					      NEWRAMBANK	BANK_TAKEBACK
      1 U3940 ????				      SEG.U	BANK_TAKEBACK
      2 U3800					      ORG	ORIGIN_RAM
      3 U3800					      RORG	RAM_3E
      4 U3800				   BANK_START SET	*
      5 U3800				   BANK_TAKEBACK SET	ORIGIN_RAM / RAM_SIZE
      6 U3800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    763 U3800
    764 U3800		       00 3f	   TAKEBACK_MASK =	$3F
    765 U3800
    766 U3800		       00 00 00 00*TakeBackPreviousX ds	$40
    767 U3840		       00 00 00 00*TakeBackPreviousY ds	$40
    768 U3880		       00 00 00 00*TakeBackPushX ds	$40
    769 U38c0		       00 00 00 00*TakeBackPushY ds	$40
    770 U3900		       00 00 00 00*TakeBackPushChar ds	$40
    771 U3940
    772 U3940							; reverting...
    773 U3940							; A prevoius position
    774 U3940							;	     POS_VAR = board
    775 U3940							;	     board = MANOCCUPIED
    776 U3940							;	     manx,y = x,y
    777 U3940							; B current position (MANX,Y)
    778 U3940							;	     board = POS_VAR
    779 U3940							; C push position
    780 U3940							;	     BOARD = PREV_BOARD
    781 U3940							; TAKEBACK_PREV_X, TAKEBACK_PREV_Y, TAKEBACK_PUSH_X,PUSH_Y,TAKEBACK_PUSH_PREV
    782 U3940							;
    783 U3940
    784 U3940
    785 U3940							; free space here (but hard to use)
    786 U3940							; So we need to calculate where the next free bank is!
    787 U3940							; TODO: This looks dodgy.  Check..
    788 U3940
    789 U3940							;ORIGIN	  SET ( * + RAM_SIZE - 1 ) / RAM_SIZE
    790 U3940							;ORIGIN	  SET ORIGIN * RAM_SIZE
    791 U3940
    792 U3940
    793 U3940
    794 U3940							;------------------------------------------------------------------------------
    795 U3940							;##############################################################################
    796 U3940							;------------------------------------------------------------------------------
    797 U3940
    798 U3940							;------------------------------------------------------------------------------
    799 U3940
    800 U3940							;    IFNCONST MAX_LEVEL_SIZE
    801 U3940				   MAX_LEVEL_SIZE SET	0
    802 U3940							;    ENDIF
    803 U3940
    804 U3940
    805 U3940				   MAX_LEVEL_NUMBER SET	0
    806 U3940					      MAC	start_level
    807 U3940				   LEVEL_START SET	*
    808 U3940				   BANK_LEVEL_{1} =	_CURRENT_BANK
    809 U3940				   LEVEL_{1}  SUBROUTINE
    810 U3940				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
    811 U3940							; ECHO "current MAX_LEVEL_NUMBER = ", MAX_LEVEL_NUMBER
    812 U3940					      ENDM		; {name}
    813 U3940
    814 U3940
    815 U3940					      MAC	end_level
    816 U3940				   LEVEL_SIZE_{1} =	* - LEVEL_START
    817 U3940					      IF	LEVEL_SIZE_{1} > MAX_LEVEL_SIZE
    818 U3940				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_{1}
    819 U3940					      ENDIF
    820 U3940					      ENDM		; {name}
    821 U3940
    822 U3940
    823 U3940					      MAC	defl
    824 U3940					      START_LEVEL	{1}
    825 U3940					      .byte	{2},0
    826 U3940					      END_LEVEL	{1}
    827 U3940					      ENDM
    828 U3940
    829 U3940							;--------------------------------------------------------------------------------
    830 U3940
    831 U3940							;ORIGIN      SET 0
    832 U3940
------- FILE BANK_ROM_SHADOW_RAMBANK.asm LEVEL 2 PASS 3
      0 U3940					      include	"BANK_ROM_SHADOW_RAMBANK.asm"
      1 U3940							;    Sokoboo - a Sokoban implementation
      2 U3940							;    using a generic tile-based display engine for the Atari 2600
      3 U3940							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4 U3940							;
      5 U3940							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6 U3940							;
      7 U3940							;    Code related to the generic tile-based display engine was developed by
      8 U3940							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9 U3940							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10 U3940							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11 U3940							;
     12 U3940							;    Code related to music and sound effects uses the TIATracker music player
     13 U3940							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14 U3940							;    directory for Apache licensing details.
     15 U3940							;
     16 U3940							;    Some level data incorporated in this program were created by Lee J Haywood.
     17 U3940							;    See the copyright notices in the License directory for a list of level
     18 U3940							;    contributors.
     19 U3940							;
     20 U3940							;    Except where otherwise indicated, this software is released under the
     21 U3940							;    following licensing arrangement...
     22 U3940							;
     23 U3940							;    This program is free software: you can redistribute it and/or modify
     24 U3940							;    it under the terms of the GNU General Public License as published by
     25 U3940							;    the Free Software Foundation, either version 3 of the License, or
     26 U3940							;    (at your option) any later version.
     27 U3940							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28 U3940
     29 U3940							;    This program is distributed in the hope that it will be useful,
     30 U3940							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31 U3940							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32 U3940							;    GNU General Public License for more details.
     33 U3940
     34 U3940							;------------------------------------------------------------------------------
     35 U3940							;##############################################################################
     36 U3940							;------------------------------------------------------------------------------
      0 U3940					      NEWBANK	ROM_SHADOW_OF_RAMBANK_CODE
      1  03fe ????				      SEG	ROM_SHADOW_OF_RAMBANK_CODE
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   ROM_SHADOW_OF_RAMBANK_CODE SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	ROM_SHADOW_OF_RAMBANK_CODE
     38  0000
     39  0000							; This is essentially a ROM mirror of a RAM bank.
     40  0000							; The contents of this bank are copied to each of the ROW banks on startup, and
     41  0000							; this gives a 1:1 correspondence between the data/addresses defined here, and
     42  0000							; the addresses in the switched-in RAM bank.
     43  0000
     44  0000							; Note: Bankswitching code between any of these banks guarantees the code can
     45  0000							; continue to run -- because, of course, the same code is still at the same
     46  0000							; memory address.
     47  0000
      0  0000					      DEFINE_SUBROUTINE	DrawTheScreen
      1  0000		       00 00	   BANK_DrawTheScreen =	_CURRENT_BANK
      2  0000					      SUBROUTINE
      3  0000				   DrawTheScreen
     49  0000
     50  0000							; Thomas Jentzsch strikes again.  And Andrew Davie too ;)
     51  0000							; A refactor of the kernel to improve the timing.
     52  0000							; Experimental refactor to remove the blank line...
     53  0000
     54  0000							; adjust here so that the first line of the kernel starts exactly at cycle 67
     55  0000							; (since TJ said it could start up to 5 cycles earlier than #67).
     56  0000
     57  0000							; TODO: remove GRP1 and COLUP1 access (or use higher resolution player)
     58  0000							;	     @57
      0  0000					      SLEEP	6	; 3
      1  0000				   .CYCLES    SET	6
      2  0000
      3  0000				  -	      IF	.CYCLES < 2
      4  0000				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0000				  -	      ERR
      6  0000					      ENDIF
      7  0000
      8  0000				  -	      IF	.CYCLES & 1
      9  0000				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0000				  -	      nop	0
     11  0000				  -	      ELSE
     12  0000				  -	      bit	VSYNC
     13  0000				  -	      ENDIF
     14  0000				  -.CYCLES    SET	.CYCLES - 3
     15  0000					      ENDIF
     16  0000
     17  0000					      REPEAT	.CYCLES / 2
     18  0000		       ea		      nop
     17  0000					      REPEND
     18  0001		       ea		      nop
     17  0001					      REPEND
     18  0002		       ea		      nop
     19  0003					      REPEND
     60  0003
     61  0003		       a2 00		      ldx	#<(BANK_SCREENMARKII1)	; 2		     == 0!!!
     62  0005		       10 3d		      bpl	NextALineStart	; 3 =	8    @65     unconditional
     63  0007
     64  0007				   Proc2		; 5
      0  0007					      SLEEP	3	; 3	     @64
      1  0007				   .CYCLES    SET	3
      2  0007
      3  0007				  -	      IF	.CYCLES < 2
      4  0007				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0007				  -	      ERR
      6  0007					      ENDIF
      7  0007
      8  0007					      IF	.CYCLES & 1
      9  0007					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0007		       04 00		      nop	0
     11  0009				  -	      ELSE
     12  0009				  -	      bit	VSYNC
     13  0009					      ENDIF
     14  0009				   .CYCLES    SET	.CYCLES - 3
     15  0009					      ENDIF
     16  0009
     17  0009				  -	      REPEAT	.CYCLES / 2
     18  0009				  -	      nop
     19  0009					      REPEND
     66  0009		       10 3b		      bpl	ScanBLUEBD	; 3 = 11    @67     unconditional
     67  000b
      0  000b					      DEFINE_SUBROUTINE	ScanRED	;	     @60
      1  000b		       00 00	   BANK_ScanRED =	_CURRENT_BANK
      2  000b					      SUBROUTINE
      3  000b				   ScanRED
     69  000b		       b9 35 f3    SM_PF0_REDl lda	CHARACTERSHAPE_BLANK,y	; 4
     70  000e		       85 4d		      sta	PF0	; 3	     @67
     71  0010		       b9 14 f2 	      lda	ScreenBitmapRED+0*LINES_PER_CHAR,y	; 4
     72  0013		       85 4e		      sta	PF1	; 3 = 14    @74
     73  0015							;SELFMOD_PLAYERCOL_RED
     74  0015		       b9 65 f3 	      lda	PLAYER0_COLOUR,y	; 4
     75  0018							;lda #$66
     76  0018							;nop
     77  0018		       85 46		      sta	COLUP0	; 3	     @05
      0  001a					      SLEEP	3
      1  001a				   .CYCLES    SET	3
      2  001a
      3  001a				  -	      IF	.CYCLES < 2
      4  001a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  001a				  -	      ERR
      6  001a					      ENDIF
      7  001a
      8  001a					      IF	.CYCLES & 1
      9  001a					      IFNCONST	NO_ILLEGAL_OPCODES
     10  001a		       04 00		      nop	0
     11  001c				  -	      ELSE
     12  001c				  -	      bit	VSYNC
     13  001c					      ENDIF
     14  001c				   .CYCLES    SET	.CYCLES - 3
     15  001c					      ENDIF
     16  001c
     17  001c				  -	      REPEAT	.CYCLES / 2
     18  001c				  -	      nop
     19  001c					      REPEND
     79  001c							;sta COLUP1				      ; 3 = 10	  @08
     80  001c
     81  001c							; TIMING COUNTS ARE WRONG FROM HERE, DUE TO ABOVE CYCLE LOSS
     82  001c
     83  001c		       f0 1d	   Colour_A_Actual =	* + 1
     84  001c				   SELFMOD_RED
     85  001c		       a9 00		      lda	#0	; 2
     86  001e		       85 48		      sta	COLUPF	; 3 =	5    @13
     87  0020
     88  0020				   SELFMOD_PLAYER0_RED
     89  0020		       b9 4d f3 	      lda	ShapePlayerRED,y	; 4
     90  0023		       85 5b		      sta	GRP0	; 3 =	7    @20
     91  0025
     92  0025		       b9 2c f2 	      lda	ScreenBitmapRED+1*LINES_PER_CHAR,y	; 4
     93  0028		       85 4f		      sta	PF2	; 3 =	7    @27
     94  002a
     95  002a		       b9 35 f3    SM_PF0_REDr lda	#CHARACTERSHAPE_BLANK,y	; 4
     96  002d		       85 4d		      sta	PF0	; 3	     @34
     97  002f		       b9 44 f2 	      lda	ScreenBitmapRED+2*LINES_PER_CHAR,y	; 4
     98  0032		       85 4e		      sta	PF1	; 3	     @41
     99  0034		       b9 5c f2 	      lda	ScreenBitmapRED+3*LINES_PER_CHAR,y	; 4
    100  0037		       85 4f		      sta	PF2	; 3 = 21    @48     must be >=48! :-)
    101  0039
    102  0039				   SELFMOD_PLAYER1_RED
    103  0039		       b9 4d f3 	      lda	ShapePlayerRED,y	; 4
    104  003c							;sta.w GRP1				      ; 4 =  8	  @56	VDELed!
      0  003c					      SLEEP	4
      1  003c				   .CYCLES    SET	4
      2  003c
      3  003c				  -	      IF	.CYCLES < 2
      4  003c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  003c				  -	      ERR
      6  003c					      ENDIF
      7  003c
      8  003c				  -	      IF	.CYCLES & 1
      9  003c				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  003c				  -	      nop	0
     11  003c				  -	      ELSE
     12  003c				  -	      bit	VSYNC
     13  003c				  -	      ENDIF
     14  003c				  -.CYCLES    SET	.CYCLES - 3
     15  003c					      ENDIF
     16  003c
     17  003c					      REPEAT	.CYCLES / 2
     18  003c		       ea		      nop
     17  003c					      REPEND
     18  003d		       ea		      nop
     19  003e					      REPEND
    106  003e
    107  003e		       88		      dey		; 2
    108  003f		       10 c6		      bpl	Proc2	; 2(3)      --> 61 if taken
    109  0041
    110  0041		       e8	   SELFMOD_X  inx		; 2
    111  0042		       86 3e		      stx	SET_BANK_RAM	; 3	     SWITCH TO CORRECT ROW BANK (OR EXIT BANK)
    112  0044							;EXIT_RETURN_HERE
    113  0044				   NextALineStart
    114  0044		       a0 07		      ldy	#LINES_PER_CHAR/3-1	; 2 = 11    @67
    115  0046				   ScanBLUEBD		;	     @67     let's start as late as possible
    116  0046
    117  0046							;------------------------------------------------------------------------------
    118  0046
    119  0046		       b9 35 f3    SM_PF0_BLUEl lda	CHARACTERSHAPE_BLANK,y	; 4
    120  0049		       85 4d		      sta	PF0	; 3 =	7    @74
    121  004b							;SELFMOD_PLAYERCOL_BLUE
    122  004b		       b9 75 f3 	      lda	PLAYER0_COLOUR+2*LINES_PER_CHAR/3,y	; 4
    123  004e							;lda #$66
    124  004e							;nop
    125  004e							;sta COLUP1				      ; 3	  @05
      0  004e					      SLEEP	3
      1  004e				   .CYCLES    SET	3
      2  004e
      3  004e				  -	      IF	.CYCLES < 2
      4  004e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  004e				  -	      ERR
      6  004e					      ENDIF
      7  004e
      8  004e					      IF	.CYCLES & 1
      9  004e					      IFNCONST	NO_ILLEGAL_OPCODES
     10  004e		       04 00		      nop	0
     11  0050				  -	      ELSE
     12  0050				  -	      bit	VSYNC
     13  0050					      ENDIF
     14  0050				   .CYCLES    SET	.CYCLES - 3
     15  0050					      ENDIF
     16  0050
     17  0050				  -	      REPEAT	.CYCLES / 2
     18  0050				  -	      nop
     19  0050					      REPEND
    127  0050		       85 46		      sta	COLUP0	; 3 = 10    @08
    128  0052
    129  0052		       f0 53	   Colour_C_Actual =	* + 1
    130  0052				   SELFMOD_BLUE
    131  0052		       a9 00		      lda	#0	; 2
    132  0054		       85 48		      sta	COLUPF	; 3 =	5    @13
    133  0056
    134  0056				   SELFMOD_PLAYER0_BLUE
    135  0056		       b9 4d f3 	      lda	ShapePlayerBLUE,y	; 4
    136  0059		       85 5b		      sta	GRP0	; 3 =	7    @20
    137  005b
    138  005b		       b9 24 f2 	      lda	ScreenBitmapBLUE+0*LINES_PER_CHAR,y	; 4
    139  005e		       85 4e		      sta	PF1	; 3	     @27     <=27! :-)
    140  0060		       b9 3c f2 	      lda	ScreenBitmapBLUE+1*LINES_PER_CHAR,y	; 4
    141  0063		       85 4f		      sta	PF2	; 3 = 14    @34
    142  0065
    143  0065		       b9 35 f3    SM_PF0_BLUEr lda	CHARACTERSHAPE_BLANK,y	; 4
    144  0068		       85 4d		      sta	PF0	; 3	     @41
    145  006a		       b9 54 f2 	      lda	ScreenBitmapBLUE+2*LINES_PER_CHAR,y	; 4
    146  006d		       85 4e		      sta	PF1	; 3	     @48
    147  006f		       b9 6c f2 	      lda	ScreenBitmapBLUE+3*LINES_PER_CHAR,y	; 4
    148  0072		       85 4f		      sta	PF2	; 3 = 21    @55
    149  0074
    150  0074				   SELFMOD_PLAYER1_BLUE
    151  0074		       b9 4d f3 	      lda	ShapePlayerBLUE,y	; 4
    152  0077							;sta GRP1				      ; 3 =  7	  VDELed! @62
      0  0077					      SLEEP	3
      1  0077				   .CYCLES    SET	3
      2  0077
      3  0077				  -	      IF	.CYCLES < 2
      4  0077				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0077				  -	      ERR
      6  0077					      ENDIF
      7  0077
      8  0077					      IF	.CYCLES & 1
      9  0077					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0077		       04 00		      nop	0
     11  0079				  -	      ELSE
     12  0079				  -	      bit	VSYNC
     13  0079					      ENDIF
     14  0079				   .CYCLES    SET	.CYCLES - 3
     15  0079					      ENDIF
     16  0079
     17  0079				  -	      REPEAT	.CYCLES / 2
     18  0079				  -	      nop
     19  0079					      REPEND
    154  0079
    155  0079							;------------------------------------------------------------------------------
    156  0079
    157  0079				   ScanGREEN		;	     @62
    158  0079		       b9 35 f3    SM_PF0_GREENl lda	CHARACTERSHAPE_BLANK,y	; 4
    159  007c		       85 4d		      sta	PF0	; 3 =	7    @69
    160  007e							;SELFMOD_PLAYERCOL_GREEN
    161  007e		       b9 6d f3 	      lda	PLAYER0_COLOUR+LINES_PER_CHAR/3,y	; 4
    162  0081							;lda #$66
    163  0081							;nop
    164  0081							;sta COLUP1				      ; 3	  @00
      0  0081					      SLEEP	3
      1  0081				   .CYCLES    SET	3
      2  0081
      3  0081				  -	      IF	.CYCLES < 2
      4  0081				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0081				  -	      ERR
      6  0081					      ENDIF
      7  0081
      8  0081					      IF	.CYCLES & 1
      9  0081					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0081		       04 00		      nop	0
     11  0083				  -	      ELSE
     12  0083				  -	      bit	VSYNC
     13  0083					      ENDIF
     14  0083				   .CYCLES    SET	.CYCLES - 3
     15  0083					      ENDIF
     16  0083
     17  0083				  -	      REPEAT	.CYCLES / 2
     18  0083				  -	      nop
     19  0083					      REPEND
    166  0083		       85 46		      sta	COLUP0	; 3 = 10    @03
    167  0085
    168  0085		       f0 86	   Colour_B_Actual =	* + 1
    169  0085				   SELFMOD_GREEN
    170  0085		       a9 00		      lda	#0	; 2
    171  0087		       85 48		      sta	COLUPF	; 3 =	5    @08
    172  0089
    173  0089				   SELFMOD_PLAYER0_GREEN
    174  0089		       b9 4d f3 	      lda	ShapePlayerGREEN,y	; 4
    175  008c		       85 5b		      sta	GRP0	; 3 =	7    @15
    176  008e
    177  008e		       b9 1c f2 	      lda	ScreenBitmapGREEN+0*LINES_PER_CHAR,y	; 4
    178  0091		       85 4e		      sta	PF1	; 3	     @22
    179  0093		       b9 34 f2 	      lda	ScreenBitmapGREEN+1*LINES_PER_CHAR,y	; 4
    180  0096		       85 4f		      sta	PF2	; 3 = 14    @29
    181  0098
    182  0098		       b9 35 f3    SM_PF0_GREENr lda	CHARACTERSHAPE_BLANK,y	; 4
    183  009b		       85 4d		      sta	PF0	; 3	     @36
    184  009d		       b9 4c f2 	      lda	ScreenBitmapGREEN+2*LINES_PER_CHAR,y	; 4
    185  00a0		       85 4e		      sta	PF1	; 3	     @43
    186  00a2		       b9 64 f2 	      lda	ScreenBitmapGREEN+3*LINES_PER_CHAR,y	; 4
    187  00a5		       85 4f		      sta	PF2	; 3 = 21    @50
    188  00a7
    189  00a7				   SELFMOD_PLAYER1_GREEN
    190  00a7		       b9 4d f3 	      lda	ShapePlayerGREEN,y	; 4
    191  00aa							;sta GRP1				      ; 3 =  7	  @57	  VDELed!
      0  00aa					      SLEEP	3
      1  00aa				   .CYCLES    SET	3
      2  00aa
      3  00aa				  -	      IF	.CYCLES < 2
      4  00aa				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  00aa				  -	      ERR
      6  00aa					      ENDIF
      7  00aa
      8  00aa					      IF	.CYCLES & 1
      9  00aa					      IFNCONST	NO_ILLEGAL_OPCODES
     10  00aa		       04 00		      nop	0
     11  00ac				  -	      ELSE
     12  00ac				  -	      bit	VSYNC
     13  00ac					      ENDIF
     14  00ac				   .CYCLES    SET	.CYCLES - 3
     15  00ac					      ENDIF
     16  00ac
     17  00ac				  -	      REPEAT	.CYCLES / 2
     18  00ac				  -	      nop
     19  00ac					      REPEND
    193  00ac
    194  00ac		       4c 0b f0 	      jmp	ScanRED	; 3	     @60
    195  00af
    196  00af							;------------------------------------------------------------------------------
    197  00af
    198  00af							;------------------------------------------------------------------------------
    199  00af
    200  00af							;*** Ideas: ***
    201  00af							; - separate data for left and right nibble (saves 88 cycles, 63 cycles or
    202  00af							;   13.5% on average), also unrolling would be more effective than now
    203  00af							; - use CharacterDataVecHI for mirrored/unmirrored (saves cycles and bytes,
    204  00af							;   see EXPERIMENTAL)
    205  00af							; - special QuickDraw routine for PF0 (~165 cycles, but only ~2% usage)
    206  00af							; - stack AI (reordering for less setup code and cycle usage, maybe better use
    207  00af							;   bidirectional linked list instead)
    208  00af							; - calculate mirrored gfx data into RAM (saves ROM)
    209  00af
    210  00af							;*** average cycle calculation (10% blanks, all columns equally frequent): ***
    211  00af							;currently:
    212  00af							; 72%*539 (!unrolled)
    213  00af							;+ 8%*304 (unrolled)
    214  00af							;+20%*269 (unrolled)
    215  00af							;--------
    216  00af							;=   ~466.2 cycles on average
    217  00af
    218  00af							;alternative #1:
    219  00af							; 72%*522 (unrolled)
    220  00af							;+ 8%*352 (!unrolled)
    221  00af							;+20%*307 (!unrolled)
    222  00af							;--------
    223  00af							;=   ~465.4 cycles on average
    224  00af
    225  00af
    226  00af		       00 01	   MIRROR     =	1
    227  00af		       00 80	   DIRECT     =	$80
    228  00af
    229  00af							;------------------------------------------------------------------------------
    230  00af							; Here we don't draw into a buffer, but directly patch the kernel
    231  00af							; VERY fast!
    232  00af							;
    233  00af							; TODO: check if DirectDraw for PF1/2 can be handle efficiently like this too
    234  00af							; Problem: SlowDraw cannot assume that the other nibble is set correctly anymore
    235  00af
    236  00af				   PF0Draw		; 25✅ cycles until here
    237  00af
    238  00af		       ae 84 02 	      ldx	INTIM	; 4
    239  00b2		       e0 04		      cpx	#SEGTIME_SCD_PF0	; 2
    240  00b4		       90 72		      bcc	ExitDraw	; 2(3)=8✅
    241  00b6
    242  00b6		       29 7f		      and	#<(~DIRECT)	; 2
    243  00b8		       aa		      tax		; 2 =	4✅
    244  00b9
    245  00b9		       98		      tya		; 2
    246  00ba		       0a		      asl		; 2	     no mirrored chars in PF0
    247  00bb		       a8		      tay		; 2 =	6✅
    248  00bc							;		  clc				  ; 2
    249  00bc
    250  00bc		       b9 15 f3 	      lda	CharacterDataVecHI,y	; 4
    251  00bf		       9d 0d f4 	      sta	SM_PF0_REDl +RAM_WRITE+2,x	; 5
    252  00c2		       9d 7b f4 	      sta	SM_PF0_GREENl+RAM_WRITE+2,x	; 5
    253  00c5		       9d 48 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+2,x	; 5 = 19✅
    254  00c8
    255  00c8		       b9 b5 f2 	      lda	CharacterDataVecLO,y	; 4
    256  00cb		       9d 0c f4 	      sta	SM_PF0_REDl +RAM_WRITE+1,x	; 5
    257  00ce		       69 07		      adc	#LINES_PER_CHAR/3-1	; 2	     CF is set!
    258  00d0		       9d 7a f4 	      sta	SM_PF0_GREENl+RAM_WRITE+1,x	; 5
    259  00d3		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    260  00d5		       9d 47 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+1,x	; 5 = 23✅
    261  00d8
    262  00d8		       4c cb fa 	      jmp	DrawAnother	; 3 =	[25]+8+4+6+19+24+3 = 88✅ entering DrawAnother
    263  00db
    264  00db							; Timing for PF0Draw
    265  00db							; 88
    266  00db							; total: 37+70+6 = 113 => 113/64 + 1.4 = 3.17 = 4 (or 3?)
    267  00db
    268  00db
    269  00db							;------------------------------------------------------------------------------
    270  00db							; Direct draw draws to PF0, which only has one active member of the character
    271  00db							; pair -- so it can be a direct copy.	Quicker still!
    272  00db
    273  00db				   DirectDraw		; 37✅ cycles until here
    274  00db
    275  00db		       ad 84 02 	      lda	INTIM	; 4
    276  00de		       c9 08		      cmp	#SEGTIME_SCD_DIRECT	; 2
    277  00e0		       90 46		      bcc	ExitDraw	; 2(3)=8
    278  00e2							; => [37]+(9)+6rts = 51 cycles if draw exits
    279  00e2
    280  00e2							; @ [37]+8 =45✅
    281  00e2
    282  00e2		       b9 15 f3 	      lda	CharacterDataVecHI,y	; 4
    283  00e5		       8d 12 f5 	      sta	SM3LOAD+RAM_WRITE+2	; 4
    284  00e8		       8d 18 f5 	      sta	SM3LOADb+RAM_WRITE+2	; 4
    285  00eb		       8d 1e f5 	      sta	SM3LOADc+RAM_WRITE+2	; 4 = 16
    286  00ee
    287  00ee		       b9 b5 f2 	      lda	CharacterDataVecLO,y	; 4
    288  00f1		       8d 11 f5 	      sta	SM3LOAD+RAM_WRITE+1	; 4
    289  00f4		       69 07		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    290  00f6		       8d 17 f5 	      sta	SM3LOADb+RAM_WRITE+1	; 4
    291  00f9		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    292  00fb		       8d 1d f5 	      sta	SM3LOADc+RAM_WRITE+1	; 4 = 20
    293  00fe
    294  00fe		       bd b2 f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    295  0101		       8d 14 f5 	      sta	SM3STORE+RAM_WRITE+1	; 4
    296  0104		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    297  0106		       8d 1a f5 	      sta	SM3STOREb+RAM_WRITE+1	; 4
    298  0109		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    299  010b		       8d 20 f5 	      sta	SM3STOREc+RAM_WRITE+1	; 4 = 20
    300  010e
    301  010e		       a0 07		      ldy	#LINES_PER_CHAR/3 - 1	; 2 =	2
    302  0110
    303  0110							; @45+16+20+20+2 = @103
    304  0110				   TSFill3		; 8*{...
    305  0110		       b9 00 f0    SM3LOAD    lda	$F000,y	; 4+
    306  0113		       99 14 f6    SM3STORE   sta	ScreenBitmap+RAM_WRITE,y	; 5
    307  0116		       b9 00 f0    SM3LOADb   lda	$F000,y	; 4+
    308  0119		       99 14 f6    SM3STOREb  sta	ScreenBitmap+RAM_WRITE,y	; 5
    309  011c		       b9 00 f0    SM3LOADc   lda	$F000,y	; 4+
    310  011f		       99 14 f6    SM3STOREc  sta	ScreenBitmap+RAM_WRITE,y	; 5 = 27
    311  0122
    312  0122		       88		      dey		; 2
      0  0123					      CHECKPAGE_BPL	TSFill3	; 3(2)=5 ...32✅} = 8*32-1 = 255
      8  0123					      LIST	ON
      9  0123		       10 eb		      bpl	TSFill3
    314  0125
    315  0125		       4c cb fa 	      jmp	DrawAnother	; 3
    316  0128							; => @103+255+3 = 361✅ entering DrawAnother
    317  0128
    318  0128		       60	   ExitDraw   rts		; 6
    319  0129
    320  0129							;------------------------------------------------------------------------------
    321  0129
      0  0129					      DEFINE_SUBROUTINE	StealPart3	; [18]✅ CYCLES TO HERE
      1  0129		       00 00	   BANK_StealPart3 =	_CURRENT_BANK
      2  0129					      SUBROUTINE
      3  0129				   StealPart3
    323  0129
    324  0129		       bd c4 f1 	      lda	MOD10,x	; 4
    325  012c		       30 81		      bmi	PF0Draw	; 2/3 --> 25 cycles entering PF0Draw
    326  012e
    327  012e		       4a		      lsr		; 2
    328  012f		       aa		      tax		; 2
    329  0130		       98		      tya		; 2
    330  0131		       2a		      rol		; 2	       allows for mirrored char = * | 1
    331  0132		       a8		      tay		; 2
    332  0133		       b0 a6		      bcs	DirectDraw	; 2(3) = 18✅ when draw stack was built, bit 7 flags direct-drawn character
    333  0135							; ==> [18]+{19) = 37 @ start of DirectDraw
    334  0135
    335  0135		       b9 15 f3 	      lda	CharacterDataVecHI,y	; 4
    336  0138		       10 38		      bpl	QuickDraw	; 2(3) = 6(7)	 special-case blank characters for extra speed
    337  013a							; => [18]+18+(7) = 43✅ starting QuickDraw
    338  013a							; +15 => 58✅ if QuickDraw exits
    339  013a
    340  013a							; @ 24
    341  013a
    342  013a		       8d 63 f5 	      sta	SMEOR1+RAM_WRITE+2	; 4
    343  013d
    344  013d		       ad 84 02 	      lda	INTIM	; 4
    345  0140		       c9 0d		      cmp	#SEGTIME_SCD_SLOW	; 2
    346  0142		       90 e4		      bcc	ExitDraw	; 2(3) = 8
    347  0144							; => [18]+55+6rts=79✅ cycles if we decline
    348  0144
    349  0144							; @36
    350  0144							; [18]+36 = @54
    351  0144
    352  0144		       b9 b5 f2 	      lda	CharacterDataVecLO,y	; 4
    353  0147		       8d 62 f5 	      sta	SMEOR1+RAM_WRITE+1	; 4 =	8
    354  014a
    355  014a		       bd b2 f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    356  014d		       8d 5f f5 	      sta	SMLOAD+RAM_WRITE+1	; 4
    357  0150		       8d 67 f5 	      sta	SMEOR2+RAM_WRITE+1	; 4
    358  0153		       8d 6a f5 	      sta	SMSTORE+RAM_WRITE+1	; 4 = 16
    359  0156
    360  0156		       bd bc f1 	      lda	CharMaskNeg,x	; 4	     masks out left or right
    361  0159		       8d 65 f5 	      sta	SMMASK+RAM_WRITE+1	; 4 =	8
    362  015c
    363  015c		       a0 17	   SlowDraw   ldy	#LINES_PER_CHAR - 1	; 2 =	2 => @88+
    364  015e
    365  015e							; A very nice bit of Thomas Jentzsch replacement magic giving 77 cycle savings.
    366  015e							; Rewrite for self-modification by Andrew Davie giving another 90 cycles :)
    367  015e
    368  015e				   TSFill		; 24*{...✅
    369  015e
    370  015e		       b9 14 f2    SMLOAD     lda	ScreenBitmap,y	; 4
    371  0161		       59 00 f0    SMEOR1     eor	$F000,y	; 4
    372  0164		       29 00	   SMMASK     and	#0	; 2
    373  0166		       59 14 f2    SMEOR2     eor	ScreenBitmap,y	; 4	     using ScreenBitmap here avoids setting high-pointer
    374  0169		       99 14 f6    SMSTORE    sta	ScreenBitmap+RAM_WRITE,y	; 5 = 19
    375  016c
    376  016c		       88		      dey		; 2
      0  016d					      CHECKPAGE_BPL	TSFill	; 3(2)=5  ...24}-1 = 575✅
      8  016d					      LIST	ON
      9  016d		       10 ef		      bpl	TSFill
    378  016f
    379  016f		       4c cb fa 	      jmp	DrawAnother	; 3 = @88+575+3 = @676✅
    380  0172
    381  0172
    382  0172							;------------------------------------------------------------------------------
    383  0172							; QuickDraw is for drawing BLANK characters.  It just has to mask out the
    384  0172							; existing character data, so can be special-cased from the normal character
    385  0172							; draw, saving roughly 230 cycles.
    386  0172
    387  0172				   QuickDraw		; [43]✅ cycles until here
    388  0172
    389  0172		       ad 84 02 	      lda	INTIM	; 4
    390  0175		       c9 08		      cmp	#SEGTIME_SCD_QUICK	; 2
    391  0177		       90 af		      bcc	ExitDraw	; 2(3)=8(9)
    392  0179							; =>[43]+(9)+6rts =58✅ if exit
    393  0179							;@[43]+8=51✅
    394  0179
    395  0179		       bd b2 f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    396  017c		       8d 99 f5 	      sta	SM2LOAD+RAM_WRITE+1	; 4
    397  017f		       8d 9c f5 	      sta	SM2STORE+RAM_WRITE+1	; 4
    398  0182		       69 07		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    399  0184		       8d a0 f5 	      sta	SM2LOADb+RAM_WRITE+1	; 4
    400  0187		       8d a3 f5 	      sta	SM2STOREb+RAM_WRITE+1	; 4
    401  018a		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    402  018c		       8d a7 f5 	      sta	SM2LOADc+RAM_WRITE+1	; 4
    403  018f		       8d aa f5 	      sta	SM2STOREc+RAM_WRITE+1	; 4 = 32✅
    404  0192
    405  0192		       bc ba f1 	      ldy	CharMask,x	; 4	     masks out left or right
    406  0195
    407  0195		       a2 07		      ldx	#LINES_PER_CHAR/3 - 1	; 2	     =32+4+2+8*{...✅
    408  0197				   TSFill2
    409  0197		       98		      tya		; 2
    410  0198		       3d 14 f2    SM2LOAD    and	ScreenBitmap,x	; 4+
    411  019b		       9d 14 f6    SM2STORE   sta	ScreenBitmap+RAM_WRITE,x	; 5
    412  019e		       98		      tya		; 2
    413  019f		       3d 14 f2    SM2LOADb   and	ScreenBitmap,x	; 4+
    414  01a2		       9d 14 f6    SM2STOREb  sta	ScreenBitmap+RAM_WRITE,x	; 5
    415  01a5		       98		      tya		; 2
    416  01a6		       3d 14 f2    SM2LOADc   and	ScreenBitmap,x	; 4+
    417  01a9		       9d 14 f6    SM2STOREc  sta	ScreenBitmap+RAM_WRITE,x	; 5 = 33✅
    418  01ac
    419  01ac		       ca		      dex		; 2
      0  01ad					      CHECKPAGE_BPL	TSFill2	; 3(2) = 5  ...} = 32+4+2+8*38-1
      8  01ad					      LIST	ON
      9  01ad		       10 e8		      bpl	TSFill2
    421  01af							;		  => 341✅
    422  01af
    423  01af		       4c cb fa 	      jmp	DrawAnother	; 3 = 344
    424  01b2
    425  01b2							;------------------------------------------------------------------------------
    426  01b2
      0  01b2					      DEFINE_SUBROUTINE	CharAddressLO	;[abs char location % 10]
      1  01b2		       00 00	   BANK_CharAddressLO =	_CURRENT_BANK
      2  01b2					      SUBROUTINE
      3  01b2				   CharAddressLO
    428  01b2
    429  01b2							; Gives the absolute screen buffer address of the first line of the given character
    430  01b2							; Where character number is 0-9
    431  01b2
    432  01b2		       14		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 1
    433  01b3		       14		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 2
    434  01b4		       2c		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 3
    435  01b5		       2c		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 4
    436  01b6		       44		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 6
    437  01b7		       44		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 7
    438  01b8		       5c		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 8
    439  01b9		       5c		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 9
    440  01ba
      0  01ba					      CHECKPAGEX	CharAddressLO, "CharAddressLO crosses page"
      9  01ba					      LIST	ON
    442  01ba
      0  01ba					      DEFINE_SUBROUTINE	CharMask	; [abs char location % 10]
      1  01ba		       00 00	   BANK_CharMask =	_CURRENT_BANK
      2  01ba					      SUBROUTINE
      3  01ba				   CharMask
    444  01ba
    445  01ba							; Gives the mask for any char of the screen (per row)
    446  01ba							; Note, this is hardwired to the screen format of 6 bytes/line
    447  01ba
    448  01ba		       0f		      .byte.b	$0F	; 1
    449  01bb		       f0		      .byte.b	$F0	; 2
    450  01bc				   CharMaskNeg
    451  01bc		       f0		      .byte.b	$F0	; 3/1
    452  01bd		       0f		      .byte.b	$0F	; 4/2
    453  01be		       0f		      .byte.b	$0F	; 6/3
    454  01bf		       f0		      .byte.b	$F0	; 7/4
    455  01c0		       f0		      .byte.b	$F0	; 8/6
    456  01c1		       0f		      .byte.b	$0F	; 9/7
    457  01c2		       0f		      .byte.b	$0F	; -/8
    458  01c3		       f0		      .byte.b	$F0	; -/9
    459  01c4
      0  01c4					      CHECKPAGEX	CharMask, "CharMask crosses page"
      9  01c4					      LIST	ON
    461  01c4
      0  01c4					      DEFINE_SUBROUTINE	MOD10
      1  01c4		       00 00	   BANK_MOD10 =	_CURRENT_BANK
      2  01c4					      SUBROUTINE
      3  01c4				   MOD10
    463  01c4
    464  01c4				   MOD10
    465  01c4					      REPEAT	SCREEN_LINES
    466  01c4							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    467  01c4							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    468  01c4		       80		      .byte.b	DIRECT
    469  01c5		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    470  01c9		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    471  01ca		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    465  01ca					      REPEND
    466  01ce							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    467  01ce							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    468  01ce		       80		      .byte.b	DIRECT
    469  01cf		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    470  01d3		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    471  01d4		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    465  01d4					      REPEND
    466  01d8							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    467  01d8							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    468  01d8		       80		      .byte.b	DIRECT
    469  01d9		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    470  01dd		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    471  01de		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    465  01de					      REPEND
    466  01e2							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    467  01e2							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    468  01e2		       80		      .byte.b	DIRECT
    469  01e3		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    470  01e7		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    471  01e8		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    465  01e8					      REPEND
    466  01ec							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    467  01ec							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    468  01ec		       80		      .byte.b	DIRECT
    469  01ed		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    470  01f1		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    471  01f2		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    465  01f2					      REPEND
    466  01f6							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    467  01f6							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    468  01f6		       80		      .byte.b	DIRECT
    469  01f7		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    470  01fb		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    471  01fc		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    465  01fc					      REPEND
    466  0200							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    467  0200							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    468  0200		       80		      .byte.b	DIRECT
    469  0201		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    470  0205		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    471  0206		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    465  0206					      REPEND
    466  020a							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    467  020a							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    468  020a		       80		      .byte.b	DIRECT
    469  020b		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    470  020f		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    471  0210		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    472  0214					      REPEND
    473  0214
    474  0214							;CHECKPAGEX MOD10, "MOD10 crosses page"
    475  0214
    476  0214							;------------------------------------------------------------------------------
    477  0214
      0  0214					      OPTIONAL_PAGEBREAK	"SCREEN_BITMAP", SCREEN_BITMAP_SIZE
     10  0214					      LIST	ON
    479  0214
    480  0214		       00 00 00 00*ScreenBitmap ds	SCREEN_BITMAP_SIZE,0	; character bitmap row (10 chars wide)
    481  0214		       f2 14	   ScreenBitmapRED =	ScreenBitmap + LINES_PER_CHAR/3*0
    482  0214		       f2 1c	   ScreenBitmapGREEN =	ScreenBitmap + LINES_PER_CHAR/3*1
    483  0214		       f2 24	   ScreenBitmapBLUE =	ScreenBitmap + LINES_PER_CHAR/3*2
    484  0274
      0  0274					      CHECKPAGEX	ScreenBitmap, "ScreenBitmap"
      9  0274					      LIST	ON
    486  0274
    487  0274
      0  0274					      DEFINE_SUBROUTINE	DoColours
      1  0274		       00 00	   BANK_DoColours =	_CURRENT_BANK
      2  0274					      SUBROUTINE
      3  0274				   DoColours
    489  0274
    490  0274
    491  0274		       a5 c8		      lda	icc_colour
    492  0276		       8d fb f7 	      sta	Colour_A + RAM_WRITE
    493  0279		       a5 c9		      lda	icc_colour+1
    494  027b		       8d fc f7 	      sta	Colour_B + RAM_WRITE
    495  027e		       a5 ca		      lda	icc_colour+2
    496  0280		       8d fd f7 	      sta	Colour_C + RAM_WRITE
    497  0283
    498  0283		       60		      rts
    499  0284
    500  0284							;--------------------------------------------------------------------------
    501  0284
      0  0284					      DEFINE_SUBROUTINE	SelfModDrawPlayers	; copied to ROW RAM BANKS
      1  0284		       00 00	   BANK_SelfModDrawPlayers =	_CURRENT_BANK
      2  0284					      SUBROUTINE
      3  0284				   SelfModDrawPlayers
    503  0284
    504  0284							; Update the appropriate shape pointers in the draw code.
    505  0284							; First, set the shape to a blank player -- effectively erasing
    506  0284
    507  0284		       a6 af		      ldx	LastSpriteY
    508  0286		       30 15		      bmi	erased	; offscreen
    509  0288		       e4 a0		      cpx	ManDrawY
    510  028a		       f0 28		      beq	NoMod	; same line, so all should be OK already
    511  028c
    512  028c		       86 3e		      stx	SET_BANK_RAM	; switch old bank in (this code too!!!!)
    513  028e
    514  028e		       a9 35		      lda	#<PLAYER_BLANK	; "erase"
    515  0290		       8d 21 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1
    516  0293		       a9 3d		      lda	#<PLAYER_BLANK + LINES_PER_CHAR/3
    517  0295		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    518  0298		       a9 45		      lda	#<PLAYER_BLANK + 2*LINES_PER_CHAR/3
    519  029a		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    520  029d
    521  029d							; Now we've erased, we write the new shape
    522  029d
    523  029d		       a6 a0	   erased     ldx	ManDrawY
    524  029f		       86 af		      stx	LastSpriteY
    525  02a1		       30 11		      bmi	NoMod
    526  02a3
    527  02a3		       86 3e		      stx	SET_BANK_RAM	; switch new bank in (this code too!!!!)
    528  02a5
    529  02a5		       a9 4d		      lda	#<PLAYER0_SHAPE	; draw buffer holding the new frame shape
    530  02a7		       8d 21 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1
    531  02aa		       a9 55		      lda	#<PLAYER0_SHAPE + LINES_PER_CHAR/3
    532  02ac		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    533  02af		       a9 5d		      lda	#<PLAYER0_SHAPE + 2*LINES_PER_CHAR/3
    534  02b1		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    535  02b4
    536  02b4		       60	   NoMod      rts
    537  02b5
    538  02b5
    539  02b5
    540  02b5							;------------------------------------------------------------------------------
    541  02b5
    542  02b5							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    543  02b5
    544  02b5							;------------------------------------------------------------------------------
    545  02b5
    546  02b5
    547  02b5
    548  02b5
    549  02b5				   OBJTYPE    SET	0
    550  02b5					      MAC	define_character
    551  02b5				   CHARACTER_{1} =	OBJTYPE
    552  02b5				   OBJTYPE    .SET	OBJTYPE + 1
    553  02b5					      ENDM
    554  02b5
    555  02b5							; Modifications to character #/order must also ensure the following are correct...
    556  02b5							;   CharacterDataVecLO/HI	   in this file
    557  02b5							;   MoveVecLO/HI		   in BANK_INITBANK
    558  02b5							;   CharReplacement		   in BANK_ROM_SHADOW_DRAWBUFFERS
    559  02b5
      0  02b5					      DEFINE_CHARACTER	BLANK
      1  02b5		       00 00	   CHARACTER_BLANK =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02b5					      DEFINE_CHARACTER	SOIL
      1  02b5		       00 01	   CHARACTER_SOIL =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02b5					      DEFINE_CHARACTER	BOX
      1  02b5		       00 02	   CHARACTER_BOX =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02b5					      DEFINE_CHARACTER	TARGET
      1  02b5		       00 03	   CHARACTER_TARGET =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02b5					      DEFINE_CHARACTER	TARGET2
      1  02b5		       00 04	   CHARACTER_TARGET2 =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02b5					      DEFINE_CHARACTER	MANOCCUPIED
      1  02b5		       00 05	   CHARACTER_MANOCCUPIED =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02b5					      DEFINE_CHARACTER	STEEL
      1  02b5		       00 06	   CHARACTER_STEEL =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02b5					      DEFINE_CHARACTER	RIVET
      1  02b5		       00 07	   CHARACTER_RIVET =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02b5					      DEFINE_CHARACTER	WALL
      1  02b5		       00 08	   CHARACTER_WALL =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02b5					      DEFINE_CHARACTER	STRIPE
      1  02b5		       00 09	   CHARACTER_STRIPE =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02b5					      DEFINE_CHARACTER	BOX_ON_TARGET
      1  02b5		       00 0a	   CHARACTER_BOX_ON_TARGET =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
    571  02b5							;DEFINE_CHARACTER BOX_ON_TARGET2
      0  02b5					      DEFINE_CHARACTER	NOGO
      1  02b5		       00 0b	   CHARACTER_NOGO =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02b5					      DEFINE_CHARACTER	TARGET1
      1  02b5		       00 0c	   CHARACTER_TARGET1 =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02b5					      DEFINE_CHARACTER	TARGET3
      1  02b5		       00 0d	   CHARACTER_TARGET3 =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02b5					      DEFINE_CHARACTER	TARGET5
      1  02b5		       00 0e	   CHARACTER_TARGET5 =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02b5					      DEFINE_CHARACTER	TARGET7
      1  02b5		       00 0f	   CHARACTER_TARGET7 =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
    577  02b5
    578  02b5				  -	      if	DIGITS
    579  02b5				  -	      DEFINE_CHARACTER	0
    580  02b5				  -	      DEFINE_CHARACTER	1
    581  02b5				  -	      DEFINE_CHARACTER	2
    582  02b5				  -	      DEFINE_CHARACTER	3
    583  02b5				  -	      DEFINE_CHARACTER	4
    584  02b5				  -	      DEFINE_CHARACTER	5
    585  02b5				  -	      DEFINE_CHARACTER	6
    586  02b5				  -	      DEFINE_CHARACTER	7
    587  02b5				  -	      DEFINE_CHARACTER	8
    588  02b5				  -	      DEFINE_CHARACTER	9
    589  02b5					      endif
    590  02b5
      0  02b5					      DEFINE_CHARACTER	MAXIMUM
      1  02b5		       00 10	   CHARACTER_MAXIMUM =	OBJTYPE
      2  02b5				   OBJTYPE    .SET	OBJTYPE + 1
    592  02b5
    593  02b5
      0  02b5					      DEFINE_SUBROUTINE	CharacterDataVecLO
      1  02b5		       00 00	   BANK_CharacterDataVecLO =	_CURRENT_BANK
      2  02b5					      SUBROUTINE
      3  02b5				   CharacterDataVecLO
    595  02b5
    596  02b5							; Two entries per character.  2nd is ptr to mirrored character
    597  02b5							; Characters don't have to be mirrored, obviously -- use the same pointer for both!
    598  02b5
    599  02b5		       35		      .byte.b	<CHARACTERSHAPE_BLANK
    600  02b6		       35		      .byte.b	<CHARACTERSHAPE_BLANK
    601  02b7		       48		      .byte.b	<CHARACTERSHAPE_SOIL
    602  02b8		       48		      .byte.b	<CHARACTERSHAPE_SOIL_MIRRORED
    603  02b9		       60		      .byte.b	<CHARACTERSHAPE_BOX
    604  02ba		       78		      .byte.b	<CHARACTERSHAPE_BOX_MIRRORED
    605  02bb		       27		      .byte.b	<CHARACTERSHAPE_TARGET1
    606  02bc		       3f		      .byte.b	<CHARACTERSHAPE_TARGET1_MIRRORED
    607  02bd		       35		      .byte.b	<CHARACTERSHAPE_BLANK
    608  02be		       35		      .byte.b	<CHARACTERSHAPE_BLANK
    609  02bf		       35		      .byte.b	<CHARACTERSHAPE_BLANK	; man occupied
    610  02c0		       35		      .byte.b	<CHARACTERSHAPE_BLANK
    611  02c1		       e4		      .byte.b	<CHARACTERSHAPE_STEEL
    612  02c2		       00		      .byte.b	<CHARACTERSHAPE_STEEL_MIRRORED
    613  02c3		       e7		      .byte.b	<CHARACTERSHAPE_RIVET
    614  02c4		       00		      .byte.b	<CHARACTERSHAPE_RIVET_MIRRORED
    615  02c5		       c0		      .byte.b	<CHARACTERSHAPE_WALL
    616  02c6		       d8		      .byte.b	<CHARACTERSHAPE_WALL_MIRRORED
    617  02c7		       18		      .byte.b	<CHARACTERSHAPE_STRIPE
    618  02c8		       30		      .byte.b	<CHARACTERSHAPE_STRIPE_MIRRORED
    619  02c9		       90		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET
    620  02ca		       a8		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    621  02cb							;  .byte <CHARACTERSHAPE_BOX_ON_TARGET2
    622  02cb							;  .byte <CHARACTERSHAPE_BOX_ON_TARGET2_MIRRORED
    623  02cb		       35		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    624  02cc		       35		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    625  02cd		       27		      .byte.b	<CHARACTERSHAPE_TARGET1
    626  02ce		       3f		      .byte.b	<CHARACTERSHAPE_TARGET1_MIRRORED
    627  02cf		       57		      .byte.b	<CHARACTERSHAPE_TARGET3
    628  02d0		       6f		      .byte.b	<CHARACTERSHAPE_TARGET3_MIRRORED
    629  02d1		       87		      .byte.b	<CHARACTERSHAPE_TARGET5
    630  02d2		       9f		      .byte.b	<CHARACTERSHAPE_TARGET5_MIRRORED
    631  02d3		       b7		      .byte.b	<CHARACTERSHAPE_TARGET7
    632  02d4		       cf		      .byte.b	<CHARACTERSHAPE_TARGET7_MIRRORED
    633  02d5
    634  02d5				  -	      if	DIGITS
    635  02d5				  -	      .byte	<CHARACTERSHAPE_0, <CHARACTERSHAPE_0_MIRRORED
    636  02d5				  -	      .byte	<CHARACTERSHAPE_1, <CHARACTERSHAPE_1_MIRRORED
    637  02d5				  -	      .byte	<CHARACTERSHAPE_2, <CHARACTERSHAPE_2_MIRRORED
    638  02d5				  -	      .byte	<CHARACTERSHAPE_3, <CHARACTERSHAPE_3_MIRRORED
    639  02d5				  -	      .byte	<CHARACTERSHAPE_4, <CHARACTERSHAPE_4_MIRRORED
    640  02d5				  -	      .byte	<CHARACTERSHAPE_5, <CHARACTERSHAPE_5_MIRRORED
    641  02d5				  -	      .byte	<CHARACTERSHAPE_6, <CHARACTERSHAPE_6_MIRRORED
    642  02d5				  -	      .byte	<CHARACTERSHAPE_7, <CHARACTERSHAPE_7_MIRRORED
    643  02d5				  -	      .byte	<CHARACTERSHAPE_8, <CHARACTERSHAPE_8_MIRRORED
    644  02d5				  -	      .byte	<CHARACTERSHAPE_9, <CHARACTERSHAPE_9_MIRRORED
    645  02d5					      endif
    646  02d5
    647  02d5
    648  02d5				  -	      IF	* - CharacterDataVecLO != CHARACTER_MAXIMUM*2
    649  02d5				  -	      ECHO	"ERROR: Incorrect CharacterDataVecLO table!"
    650  02d5				  -	      ERR
    651  02d5					      ENDIF
    652  02d5
      0  02d5					      CHECKPAGEX	CharacterDataVecLO, "CharacterDataVecLO crosses page"
      9  02d5					      LIST	ON
    654  02d5
    655  02d5
    656  02d5							;------------------------------------------------------------------------------
    657  02d5
    658  02d5							; The acutal colour palette to use for the player. The player may be any "ethnicity" which refers
    659  02d5							; to the colours for a frame. The skin could be asian/black/caucasian, the cloting could be anything.
    660  02d5							; Each ethnicity is defined as first 8 bytes for NTSC and then 8 bytes for PAL. The 8 bytes refer
    661  02d5							; to the "CL#" index values defined in the player COLOUR frames. So, an index is grabbed from the
    662  02d5							; player frame, it is adjusted to add the base ethnicity and the NTSC/PAL, and that gives the base
    663  02d5							; for reading 8 successive bytes for CL0..CL7 from the frame definitions.
    664  02d5
    665  02d5				   EthnicityColourPalette
    666  02d5
    667  02d5							; CL0	   = BLACK
    668  02d5							; CL1	   = HAT
    669  02d5							; CL2	   = SKIN
    670  02d5							; CL3	   = CUFFS/TRIM
    671  02d5							; CL4	   = JUMPER
    672  02d5							; CL5	   = PANTS
    673  02d5							; CL6	   = SHOES
    674  02d5							; CL7	   = UNUSED
    675  02d5
    676  02d5							; CL7 = NOT USABLE
    677  02d5
    678  02d5							; (*) = unchecked/converted
    679  02d5
    680  02d5					      MAC	colour_group
    681  02d5							; NTSC...
    682  02d5					      .byte	0
    683  02d5					      .byte	{1}+{2}-2+PALETTE_INTENSITY_ADJUST
    684  02d5					      .byte	{3}+{4}-2+PALETTE_INTENSITY_ADJUST
    685  02d5					      .byte	{5}+{6}-2+PALETTE_INTENSITY_ADJUST
    686  02d5					      .byte	{7}+{8}-2+PALETTE_INTENSITY_ADJUST
    687  02d5					      .byte	{9}+{10}-2+PALETTE_INTENSITY_ADJUST
    688  02d5					      .byte	{11}+{12}-2+PALETTE_INTENSITY_ADJUST
    689  02d5					      .byte	0
    690  02d5
    691  02d5							; PAL...
    692  02d5					      .byte	0
    693  02d5					      NTSC_TO_PAL	{1}, {2}-2+PALETTE_INTENSITY_ADJUST
    694  02d5					      NTSC_TO_PAL	{3}, {4}-2+PALETTE_INTENSITY_ADJUST
    695  02d5					      NTSC_TO_PAL	{5}, {6}-2+PALETTE_INTENSITY_ADJUST
    696  02d5					      NTSC_TO_PAL	{7}, {8}-2+PALETTE_INTENSITY_ADJUST
    697  02d5					      NTSC_TO_PAL	{9}, {10}-2+PALETTE_INTENSITY_ADJUST
    698  02d5					      NTSC_TO_PAL	{11}, {12}-2+PALETTE_INTENSITY_ADJUST
    699  02d5					      .byte	0
    700  02d5					      ENDM
    701  02d5
    702  02d5							; USE NTSC COLOUR+INTENSITY. WILL AUTO-ADD PAL EQUIVALENT...
    703  02d5							;		 HAT	 FACE	 TRIM	 JUMPER  PANTS	SHOES
      0  02d5					      COLOUR_GROUP	$10,$A, $40,$8, $00,$A, $80,$8, $90,6, $10,6	; 0
      1  02d5
      2  02d5		       00		      .byte.b	0
      3  02d6		       1a		      .byte.b	$10+$A-2+PALETTE_INTENSITY_ADJUST
      4  02d7		       48		      .byte.b	$40+$8-2+PALETTE_INTENSITY_ADJUST
      5  02d8		       0a		      .byte.b	$00+$A-2+PALETTE_INTENSITY_ADJUST
      6  02d9		       88		      .byte.b	$80+$8-2+PALETTE_INTENSITY_ADJUST
      7  02da		       96		      .byte.b	$90+6-2+PALETTE_INTENSITY_ADJUST
      8  02db		       16		      .byte.b	$10+6-2+PALETTE_INTENSITY_ADJUST
      9  02dc		       00		      .byte.b	0
     10  02dd
     11  02dd
     12  02dd		       00		      .byte.b	0
      0  02de					      NTSC_TO_PAL	$10, $A-2+PALETTE_INTENSITY_ADJUST
      1  02de				  -	      IF	$10 = 0
      2  02de				  -	      .byte	$10+$A-2+PALETTE_INTENSITY_ADJUST
      3  02de					      ENDIF
      4  02de					      IF	$10 = $10
      5  02de		       2a		      .byte.b	$20+$A-2+PALETTE_INTENSITY_ADJUST
      6  02df					      ENDIF
      7  02df				  -	      IF	$10 = $20
      8  02df				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
      9  02df					      ENDIF
     10  02df				  -	      IF	$10 = $30
     11  02df				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
     12  02df					      ENDIF
     13  02df				  -	      IF	$10 = $40
     14  02df				  -	      .byte	$60+$A-2+PALETTE_INTENSITY_ADJUST
     15  02df					      ENDIF
     16  02df				  -	      IF	$10 = $50
     17  02df				  -	      .byte	$80+$A-2+PALETTE_INTENSITY_ADJUST
     18  02df					      ENDIF
     19  02df				  -	      IF	$10 = $60
     20  02df				  -	      .byte	$C0+$A-2+PALETTE_INTENSITY_ADJUST
     21  02df					      ENDIF
     22  02df				  -	      IF	$10 = $70
     23  02df				  -	      .byte	$D0+$A-2+PALETTE_INTENSITY_ADJUST
     24  02df					      ENDIF
     25  02df				  -	      IF	$10 = $80
     26  02df				  -	      .byte	$B0+$A-2+PALETTE_INTENSITY_ADJUST
     27  02df					      ENDIF
     28  02df				  -	      IF	$10 = $90
     29  02df				  -	      .byte	$90+$A-2+PALETTE_INTENSITY_ADJUST
     30  02df					      ENDIF
     31  02df				  -	      IF	$10 = $A0
     32  02df				  -	      .byte	$70+$A-2+PALETTE_INTENSITY_ADJUST
     33  02df					      ENDIF
     34  02df				  -	      IF	$10 = $B0
     35  02df				  -	      .byte	$50+$A-2+PALETTE_INTENSITY_ADJUST
     36  02df					      ENDIF
     37  02df				  -	      IF	$10 = $C0
     38  02df				  -	      .byte	$30+$A-2+PALETTE_INTENSITY_ADJUST
     39  02df					      ENDIF
     40  02df				  -	      IF	$10 = $D0
     41  02df				  -	      .byte	$30+$A-2+PALETTE_INTENSITY_ADJUST
     42  02df					      ENDIF
     43  02df				  -	      IF	$10 = $E0
     44  02df				  -	      .byte	$20+$A-2+PALETTE_INTENSITY_ADJUST
     45  02df					      ENDIF
     46  02df				  -	      IF	$10 = $F0
     47  02df				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
     48  02df					      ENDIF
      0  02df					      NTSC_TO_PAL	$40, $8-2+PALETTE_INTENSITY_ADJUST
      1  02df				  -	      IF	$40 = 0
      2  02df				  -	      .byte	$40+$8-2+PALETTE_INTENSITY_ADJUST
      3  02df					      ENDIF
      4  02df				  -	      IF	$40 = $10
      5  02df				  -	      .byte	$20+$8-2+PALETTE_INTENSITY_ADJUST
      6  02df					      ENDIF
      7  02df				  -	      IF	$40 = $20
      8  02df				  -	      .byte	$40+$8-2+PALETTE_INTENSITY_ADJUST
      9  02df					      ENDIF
     10  02df				  -	      IF	$40 = $30
     11  02df				  -	      .byte	$40+$8-2+PALETTE_INTENSITY_ADJUST
     12  02df					      ENDIF
     13  02df					      IF	$40 = $40
     14  02df		       68		      .byte.b	$60+$8-2+PALETTE_INTENSITY_ADJUST
     15  02e0					      ENDIF
     16  02e0				  -	      IF	$40 = $50
     17  02e0				  -	      .byte	$80+$8-2+PALETTE_INTENSITY_ADJUST
     18  02e0					      ENDIF
     19  02e0				  -	      IF	$40 = $60
     20  02e0				  -	      .byte	$C0+$8-2+PALETTE_INTENSITY_ADJUST
     21  02e0					      ENDIF
     22  02e0				  -	      IF	$40 = $70
     23  02e0				  -	      .byte	$D0+$8-2+PALETTE_INTENSITY_ADJUST
     24  02e0					      ENDIF
     25  02e0				  -	      IF	$40 = $80
     26  02e0				  -	      .byte	$B0+$8-2+PALETTE_INTENSITY_ADJUST
     27  02e0					      ENDIF
     28  02e0				  -	      IF	$40 = $90
     29  02e0				  -	      .byte	$90+$8-2+PALETTE_INTENSITY_ADJUST
     30  02e0					      ENDIF
     31  02e0				  -	      IF	$40 = $A0
     32  02e0				  -	      .byte	$70+$8-2+PALETTE_INTENSITY_ADJUST
     33  02e0					      ENDIF
     34  02e0				  -	      IF	$40 = $B0
     35  02e0				  -	      .byte	$50+$8-2+PALETTE_INTENSITY_ADJUST
     36  02e0					      ENDIF
     37  02e0				  -	      IF	$40 = $C0
     38  02e0				  -	      .byte	$30+$8-2+PALETTE_INTENSITY_ADJUST
     39  02e0					      ENDIF
     40  02e0				  -	      IF	$40 = $D0
     41  02e0				  -	      .byte	$30+$8-2+PALETTE_INTENSITY_ADJUST
     42  02e0					      ENDIF
     43  02e0				  -	      IF	$40 = $E0
     44  02e0				  -	      .byte	$20+$8-2+PALETTE_INTENSITY_ADJUST
     45  02e0					      ENDIF
     46  02e0				  -	      IF	$40 = $F0
     47  02e0				  -	      .byte	$40+$8-2+PALETTE_INTENSITY_ADJUST
     48  02e0					      ENDIF
      0  02e0					      NTSC_TO_PAL	$00, $A-2+PALETTE_INTENSITY_ADJUST
      1  02e0					      IF	$00 = 0
      2  02e0		       0a		      .byte.b	$00+$A-2+PALETTE_INTENSITY_ADJUST
      3  02e1					      ENDIF
      4  02e1				  -	      IF	$00 = $10
      5  02e1				  -	      .byte	$20+$A-2+PALETTE_INTENSITY_ADJUST
      6  02e1					      ENDIF
      7  02e1				  -	      IF	$00 = $20
      8  02e1				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
      9  02e1					      ENDIF
     10  02e1				  -	      IF	$00 = $30
     11  02e1				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
     12  02e1					      ENDIF
     13  02e1				  -	      IF	$00 = $40
     14  02e1				  -	      .byte	$60+$A-2+PALETTE_INTENSITY_ADJUST
     15  02e1					      ENDIF
     16  02e1				  -	      IF	$00 = $50
     17  02e1				  -	      .byte	$80+$A-2+PALETTE_INTENSITY_ADJUST
     18  02e1					      ENDIF
     19  02e1				  -	      IF	$00 = $60
     20  02e1				  -	      .byte	$C0+$A-2+PALETTE_INTENSITY_ADJUST
     21  02e1					      ENDIF
     22  02e1				  -	      IF	$00 = $70
     23  02e1				  -	      .byte	$D0+$A-2+PALETTE_INTENSITY_ADJUST
     24  02e1					      ENDIF
     25  02e1				  -	      IF	$00 = $80
     26  02e1				  -	      .byte	$B0+$A-2+PALETTE_INTENSITY_ADJUST
     27  02e1					      ENDIF
     28  02e1				  -	      IF	$00 = $90
     29  02e1				  -	      .byte	$90+$A-2+PALETTE_INTENSITY_ADJUST
     30  02e1					      ENDIF
     31  02e1				  -	      IF	$00 = $A0
     32  02e1				  -	      .byte	$70+$A-2+PALETTE_INTENSITY_ADJUST
     33  02e1					      ENDIF
     34  02e1				  -	      IF	$00 = $B0
     35  02e1				  -	      .byte	$50+$A-2+PALETTE_INTENSITY_ADJUST
     36  02e1					      ENDIF
     37  02e1				  -	      IF	$00 = $C0
     38  02e1				  -	      .byte	$30+$A-2+PALETTE_INTENSITY_ADJUST
     39  02e1					      ENDIF
     40  02e1				  -	      IF	$00 = $D0
     41  02e1				  -	      .byte	$30+$A-2+PALETTE_INTENSITY_ADJUST
     42  02e1					      ENDIF
     43  02e1				  -	      IF	$00 = $E0
     44  02e1				  -	      .byte	$20+$A-2+PALETTE_INTENSITY_ADJUST
     45  02e1					      ENDIF
     46  02e1				  -	      IF	$00 = $F0
     47  02e1				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
     48  02e1					      ENDIF
      0  02e1					      NTSC_TO_PAL	$80, $8-2+PALETTE_INTENSITY_ADJUST
      1  02e1				  -	      IF	$80 = 0
      2  02e1				  -	      .byte	$80+$8-2+PALETTE_INTENSITY_ADJUST
      3  02e1					      ENDIF
      4  02e1				  -	      IF	$80 = $10
      5  02e1				  -	      .byte	$20+$8-2+PALETTE_INTENSITY_ADJUST
      6  02e1					      ENDIF
      7  02e1				  -	      IF	$80 = $20
      8  02e1				  -	      .byte	$40+$8-2+PALETTE_INTENSITY_ADJUST
      9  02e1					      ENDIF
     10  02e1				  -	      IF	$80 = $30
     11  02e1				  -	      .byte	$40+$8-2+PALETTE_INTENSITY_ADJUST
     12  02e1					      ENDIF
     13  02e1				  -	      IF	$80 = $40
     14  02e1				  -	      .byte	$60+$8-2+PALETTE_INTENSITY_ADJUST
     15  02e1					      ENDIF
     16  02e1				  -	      IF	$80 = $50
     17  02e1				  -	      .byte	$80+$8-2+PALETTE_INTENSITY_ADJUST
     18  02e1					      ENDIF
     19  02e1				  -	      IF	$80 = $60
     20  02e1				  -	      .byte	$C0+$8-2+PALETTE_INTENSITY_ADJUST
     21  02e1					      ENDIF
     22  02e1				  -	      IF	$80 = $70
     23  02e1				  -	      .byte	$D0+$8-2+PALETTE_INTENSITY_ADJUST
     24  02e1					      ENDIF
     25  02e1					      IF	$80 = $80
     26  02e1		       b8		      .byte.b	$B0+$8-2+PALETTE_INTENSITY_ADJUST
     27  02e2					      ENDIF
     28  02e2				  -	      IF	$80 = $90
     29  02e2				  -	      .byte	$90+$8-2+PALETTE_INTENSITY_ADJUST
     30  02e2					      ENDIF
     31  02e2				  -	      IF	$80 = $A0
     32  02e2				  -	      .byte	$70+$8-2+PALETTE_INTENSITY_ADJUST
     33  02e2					      ENDIF
     34  02e2				  -	      IF	$80 = $B0
     35  02e2				  -	      .byte	$50+$8-2+PALETTE_INTENSITY_ADJUST
     36  02e2					      ENDIF
     37  02e2				  -	      IF	$80 = $C0
     38  02e2				  -	      .byte	$30+$8-2+PALETTE_INTENSITY_ADJUST
     39  02e2					      ENDIF
     40  02e2				  -	      IF	$80 = $D0
     41  02e2				  -	      .byte	$30+$8-2+PALETTE_INTENSITY_ADJUST
     42  02e2					      ENDIF
     43  02e2				  -	      IF	$80 = $E0
     44  02e2				  -	      .byte	$20+$8-2+PALETTE_INTENSITY_ADJUST
     45  02e2					      ENDIF
     46  02e2				  -	      IF	$80 = $F0
     47  02e2				  -	      .byte	$40+$8-2+PALETTE_INTENSITY_ADJUST
     48  02e2					      ENDIF
      0  02e2					      NTSC_TO_PAL	$90, 6-2+PALETTE_INTENSITY_ADJUST
      1  02e2				  -	      IF	$90 = 0
      2  02e2				  -	      .byte	$90+6-2+PALETTE_INTENSITY_ADJUST
      3  02e2					      ENDIF
      4  02e2				  -	      IF	$90 = $10
      5  02e2				  -	      .byte	$20+6-2+PALETTE_INTENSITY_ADJUST
      6  02e2					      ENDIF
      7  02e2				  -	      IF	$90 = $20
      8  02e2				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
      9  02e2					      ENDIF
     10  02e2				  -	      IF	$90 = $30
     11  02e2				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
     12  02e2					      ENDIF
     13  02e2				  -	      IF	$90 = $40
     14  02e2				  -	      .byte	$60+6-2+PALETTE_INTENSITY_ADJUST
     15  02e2					      ENDIF
     16  02e2				  -	      IF	$90 = $50
     17  02e2				  -	      .byte	$80+6-2+PALETTE_INTENSITY_ADJUST
     18  02e2					      ENDIF
     19  02e2				  -	      IF	$90 = $60
     20  02e2				  -	      .byte	$C0+6-2+PALETTE_INTENSITY_ADJUST
     21  02e2					      ENDIF
     22  02e2				  -	      IF	$90 = $70
     23  02e2				  -	      .byte	$D0+6-2+PALETTE_INTENSITY_ADJUST
     24  02e2					      ENDIF
     25  02e2				  -	      IF	$90 = $80
     26  02e2				  -	      .byte	$B0+6-2+PALETTE_INTENSITY_ADJUST
     27  02e2					      ENDIF
     28  02e2					      IF	$90 = $90
     29  02e2		       96		      .byte.b	$90+6-2+PALETTE_INTENSITY_ADJUST
     30  02e3					      ENDIF
     31  02e3				  -	      IF	$90 = $A0
     32  02e3				  -	      .byte	$70+6-2+PALETTE_INTENSITY_ADJUST
     33  02e3					      ENDIF
     34  02e3				  -	      IF	$90 = $B0
     35  02e3				  -	      .byte	$50+6-2+PALETTE_INTENSITY_ADJUST
     36  02e3					      ENDIF
     37  02e3				  -	      IF	$90 = $C0
     38  02e3				  -	      .byte	$30+6-2+PALETTE_INTENSITY_ADJUST
     39  02e3					      ENDIF
     40  02e3				  -	      IF	$90 = $D0
     41  02e3				  -	      .byte	$30+6-2+PALETTE_INTENSITY_ADJUST
     42  02e3					      ENDIF
     43  02e3				  -	      IF	$90 = $E0
     44  02e3				  -	      .byte	$20+6-2+PALETTE_INTENSITY_ADJUST
     45  02e3					      ENDIF
     46  02e3				  -	      IF	$90 = $F0
     47  02e3				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
     48  02e3					      ENDIF
      0  02e3					      NTSC_TO_PAL	$10, 6-2+PALETTE_INTENSITY_ADJUST
      1  02e3				  -	      IF	$10 = 0
      2  02e3				  -	      .byte	$10+6-2+PALETTE_INTENSITY_ADJUST
      3  02e3					      ENDIF
      4  02e3					      IF	$10 = $10
      5  02e3		       26		      .byte.b	$20+6-2+PALETTE_INTENSITY_ADJUST
      6  02e4					      ENDIF
      7  02e4				  -	      IF	$10 = $20
      8  02e4				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
      9  02e4					      ENDIF
     10  02e4				  -	      IF	$10 = $30
     11  02e4				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
     12  02e4					      ENDIF
     13  02e4				  -	      IF	$10 = $40
     14  02e4				  -	      .byte	$60+6-2+PALETTE_INTENSITY_ADJUST
     15  02e4					      ENDIF
     16  02e4				  -	      IF	$10 = $50
     17  02e4				  -	      .byte	$80+6-2+PALETTE_INTENSITY_ADJUST
     18  02e4					      ENDIF
     19  02e4				  -	      IF	$10 = $60
     20  02e4				  -	      .byte	$C0+6-2+PALETTE_INTENSITY_ADJUST
     21  02e4					      ENDIF
     22  02e4				  -	      IF	$10 = $70
     23  02e4				  -	      .byte	$D0+6-2+PALETTE_INTENSITY_ADJUST
     24  02e4					      ENDIF
     25  02e4				  -	      IF	$10 = $80
     26  02e4				  -	      .byte	$B0+6-2+PALETTE_INTENSITY_ADJUST
     27  02e4					      ENDIF
     28  02e4				  -	      IF	$10 = $90
     29  02e4				  -	      .byte	$90+6-2+PALETTE_INTENSITY_ADJUST
     30  02e4					      ENDIF
     31  02e4				  -	      IF	$10 = $A0
     32  02e4				  -	      .byte	$70+6-2+PALETTE_INTENSITY_ADJUST
     33  02e4					      ENDIF
     34  02e4				  -	      IF	$10 = $B0
     35  02e4				  -	      .byte	$50+6-2+PALETTE_INTENSITY_ADJUST
     36  02e4					      ENDIF
     37  02e4				  -	      IF	$10 = $C0
     38  02e4				  -	      .byte	$30+6-2+PALETTE_INTENSITY_ADJUST
     39  02e4					      ENDIF
     40  02e4				  -	      IF	$10 = $D0
     41  02e4				  -	      .byte	$30+6-2+PALETTE_INTENSITY_ADJUST
     42  02e4					      ENDIF
     43  02e4				  -	      IF	$10 = $E0
     44  02e4				  -	      .byte	$20+6-2+PALETTE_INTENSITY_ADJUST
     45  02e4					      ENDIF
     46  02e4				  -	      IF	$10 = $F0
     47  02e4				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
     48  02e4					      ENDIF
     19  02e4		       00		      .byte.b	0
      0  02e5					      COLOUR_GROUP	$10,$A, $F0,$8, $60,$A, $50,$4, $70,6, $40,6	; 1
      1  02e5
      2  02e5		       00		      .byte.b	0
      3  02e6		       1a		      .byte.b	$10+$A-2+PALETTE_INTENSITY_ADJUST
      4  02e7		       f8		      .byte.b	$F0+$8-2+PALETTE_INTENSITY_ADJUST
      5  02e8		       6a		      .byte.b	$60+$A-2+PALETTE_INTENSITY_ADJUST
      6  02e9		       54		      .byte.b	$50+$4-2+PALETTE_INTENSITY_ADJUST
      7  02ea		       76		      .byte.b	$70+6-2+PALETTE_INTENSITY_ADJUST
      8  02eb		       46		      .byte.b	$40+6-2+PALETTE_INTENSITY_ADJUST
      9  02ec		       00		      .byte.b	0
     10  02ed
     11  02ed
     12  02ed		       00		      .byte.b	0
      0  02ee					      NTSC_TO_PAL	$10, $A-2+PALETTE_INTENSITY_ADJUST
      1  02ee				  -	      IF	$10 = 0
      2  02ee				  -	      .byte	$10+$A-2+PALETTE_INTENSITY_ADJUST
      3  02ee					      ENDIF
      4  02ee					      IF	$10 = $10
      5  02ee		       2a		      .byte.b	$20+$A-2+PALETTE_INTENSITY_ADJUST
      6  02ef					      ENDIF
      7  02ef				  -	      IF	$10 = $20
      8  02ef				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
      9  02ef					      ENDIF
     10  02ef				  -	      IF	$10 = $30
     11  02ef				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
     12  02ef					      ENDIF
     13  02ef				  -	      IF	$10 = $40
     14  02ef				  -	      .byte	$60+$A-2+PALETTE_INTENSITY_ADJUST
     15  02ef					      ENDIF
     16  02ef				  -	      IF	$10 = $50
     17  02ef				  -	      .byte	$80+$A-2+PALETTE_INTENSITY_ADJUST
     18  02ef					      ENDIF
     19  02ef				  -	      IF	$10 = $60
     20  02ef				  -	      .byte	$C0+$A-2+PALETTE_INTENSITY_ADJUST
     21  02ef					      ENDIF
     22  02ef				  -	      IF	$10 = $70
     23  02ef				  -	      .byte	$D0+$A-2+PALETTE_INTENSITY_ADJUST
     24  02ef					      ENDIF
     25  02ef				  -	      IF	$10 = $80
     26  02ef				  -	      .byte	$B0+$A-2+PALETTE_INTENSITY_ADJUST
     27  02ef					      ENDIF
     28  02ef				  -	      IF	$10 = $90
     29  02ef				  -	      .byte	$90+$A-2+PALETTE_INTENSITY_ADJUST
     30  02ef					      ENDIF
     31  02ef				  -	      IF	$10 = $A0
     32  02ef				  -	      .byte	$70+$A-2+PALETTE_INTENSITY_ADJUST
     33  02ef					      ENDIF
     34  02ef				  -	      IF	$10 = $B0
     35  02ef				  -	      .byte	$50+$A-2+PALETTE_INTENSITY_ADJUST
     36  02ef					      ENDIF
     37  02ef				  -	      IF	$10 = $C0
     38  02ef				  -	      .byte	$30+$A-2+PALETTE_INTENSITY_ADJUST
     39  02ef					      ENDIF
     40  02ef				  -	      IF	$10 = $D0
     41  02ef				  -	      .byte	$30+$A-2+PALETTE_INTENSITY_ADJUST
     42  02ef					      ENDIF
     43  02ef				  -	      IF	$10 = $E0
     44  02ef				  -	      .byte	$20+$A-2+PALETTE_INTENSITY_ADJUST
     45  02ef					      ENDIF
     46  02ef				  -	      IF	$10 = $F0
     47  02ef				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
     48  02ef					      ENDIF
      0  02ef					      NTSC_TO_PAL	$F0, $8-2+PALETTE_INTENSITY_ADJUST
      1  02ef				  -	      IF	$F0 = 0
      2  02ef				  -	      .byte	$F0+$8-2+PALETTE_INTENSITY_ADJUST
      3  02ef					      ENDIF
      4  02ef				  -	      IF	$F0 = $10
      5  02ef				  -	      .byte	$20+$8-2+PALETTE_INTENSITY_ADJUST
      6  02ef					      ENDIF
      7  02ef				  -	      IF	$F0 = $20
      8  02ef				  -	      .byte	$40+$8-2+PALETTE_INTENSITY_ADJUST
      9  02ef					      ENDIF
     10  02ef				  -	      IF	$F0 = $30
     11  02ef				  -	      .byte	$40+$8-2+PALETTE_INTENSITY_ADJUST
     12  02ef					      ENDIF
     13  02ef				  -	      IF	$F0 = $40
     14  02ef				  -	      .byte	$60+$8-2+PALETTE_INTENSITY_ADJUST
     15  02ef					      ENDIF
     16  02ef				  -	      IF	$F0 = $50
     17  02ef				  -	      .byte	$80+$8-2+PALETTE_INTENSITY_ADJUST
     18  02ef					      ENDIF
     19  02ef				  -	      IF	$F0 = $60
     20  02ef				  -	      .byte	$C0+$8-2+PALETTE_INTENSITY_ADJUST
     21  02ef					      ENDIF
     22  02ef				  -	      IF	$F0 = $70
     23  02ef				  -	      .byte	$D0+$8-2+PALETTE_INTENSITY_ADJUST
     24  02ef					      ENDIF
     25  02ef				  -	      IF	$F0 = $80
     26  02ef				  -	      .byte	$B0+$8-2+PALETTE_INTENSITY_ADJUST
     27  02ef					      ENDIF
     28  02ef				  -	      IF	$F0 = $90
     29  02ef				  -	      .byte	$90+$8-2+PALETTE_INTENSITY_ADJUST
     30  02ef					      ENDIF
     31  02ef				  -	      IF	$F0 = $A0
     32  02ef				  -	      .byte	$70+$8-2+PALETTE_INTENSITY_ADJUST
     33  02ef					      ENDIF
     34  02ef				  -	      IF	$F0 = $B0
     35  02ef				  -	      .byte	$50+$8-2+PALETTE_INTENSITY_ADJUST
     36  02ef					      ENDIF
     37  02ef				  -	      IF	$F0 = $C0
     38  02ef				  -	      .byte	$30+$8-2+PALETTE_INTENSITY_ADJUST
     39  02ef					      ENDIF
     40  02ef				  -	      IF	$F0 = $D0
     41  02ef				  -	      .byte	$30+$8-2+PALETTE_INTENSITY_ADJUST
     42  02ef					      ENDIF
     43  02ef				  -	      IF	$F0 = $E0
     44  02ef				  -	      .byte	$20+$8-2+PALETTE_INTENSITY_ADJUST
     45  02ef					      ENDIF
     46  02ef					      IF	$F0 = $F0
     47  02ef		       48		      .byte.b	$40+$8-2+PALETTE_INTENSITY_ADJUST
     48  02f0					      ENDIF
      0  02f0					      NTSC_TO_PAL	$60, $A-2+PALETTE_INTENSITY_ADJUST
      1  02f0				  -	      IF	$60 = 0
      2  02f0				  -	      .byte	$60+$A-2+PALETTE_INTENSITY_ADJUST
      3  02f0					      ENDIF
      4  02f0				  -	      IF	$60 = $10
      5  02f0				  -	      .byte	$20+$A-2+PALETTE_INTENSITY_ADJUST
      6  02f0					      ENDIF
      7  02f0				  -	      IF	$60 = $20
      8  02f0				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
      9  02f0					      ENDIF
     10  02f0				  -	      IF	$60 = $30
     11  02f0				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
     12  02f0					      ENDIF
     13  02f0				  -	      IF	$60 = $40
     14  02f0				  -	      .byte	$60+$A-2+PALETTE_INTENSITY_ADJUST
     15  02f0					      ENDIF
     16  02f0				  -	      IF	$60 = $50
     17  02f0				  -	      .byte	$80+$A-2+PALETTE_INTENSITY_ADJUST
     18  02f0					      ENDIF
     19  02f0					      IF	$60 = $60
     20  02f0		       ca		      .byte.b	$C0+$A-2+PALETTE_INTENSITY_ADJUST
     21  02f1					      ENDIF
     22  02f1				  -	      IF	$60 = $70
     23  02f1				  -	      .byte	$D0+$A-2+PALETTE_INTENSITY_ADJUST
     24  02f1					      ENDIF
     25  02f1				  -	      IF	$60 = $80
     26  02f1				  -	      .byte	$B0+$A-2+PALETTE_INTENSITY_ADJUST
     27  02f1					      ENDIF
     28  02f1				  -	      IF	$60 = $90
     29  02f1				  -	      .byte	$90+$A-2+PALETTE_INTENSITY_ADJUST
     30  02f1					      ENDIF
     31  02f1				  -	      IF	$60 = $A0
     32  02f1				  -	      .byte	$70+$A-2+PALETTE_INTENSITY_ADJUST
     33  02f1					      ENDIF
     34  02f1				  -	      IF	$60 = $B0
     35  02f1				  -	      .byte	$50+$A-2+PALETTE_INTENSITY_ADJUST
     36  02f1					      ENDIF
     37  02f1				  -	      IF	$60 = $C0
     38  02f1				  -	      .byte	$30+$A-2+PALETTE_INTENSITY_ADJUST
     39  02f1					      ENDIF
     40  02f1				  -	      IF	$60 = $D0
     41  02f1				  -	      .byte	$30+$A-2+PALETTE_INTENSITY_ADJUST
     42  02f1					      ENDIF
     43  02f1				  -	      IF	$60 = $E0
     44  02f1				  -	      .byte	$20+$A-2+PALETTE_INTENSITY_ADJUST
     45  02f1					      ENDIF
     46  02f1				  -	      IF	$60 = $F0
     47  02f1				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
     48  02f1					      ENDIF
      0  02f1					      NTSC_TO_PAL	$50, $4-2+PALETTE_INTENSITY_ADJUST
      1  02f1				  -	      IF	$50 = 0
      2  02f1				  -	      .byte	$50+$4-2+PALETTE_INTENSITY_ADJUST
      3  02f1					      ENDIF
      4  02f1				  -	      IF	$50 = $10
      5  02f1				  -	      .byte	$20+$4-2+PALETTE_INTENSITY_ADJUST
      6  02f1					      ENDIF
      7  02f1				  -	      IF	$50 = $20
      8  02f1				  -	      .byte	$40+$4-2+PALETTE_INTENSITY_ADJUST
      9  02f1					      ENDIF
     10  02f1				  -	      IF	$50 = $30
     11  02f1				  -	      .byte	$40+$4-2+PALETTE_INTENSITY_ADJUST
     12  02f1					      ENDIF
     13  02f1				  -	      IF	$50 = $40
     14  02f1				  -	      .byte	$60+$4-2+PALETTE_INTENSITY_ADJUST
     15  02f1					      ENDIF
     16  02f1					      IF	$50 = $50
     17  02f1		       84		      .byte.b	$80+$4-2+PALETTE_INTENSITY_ADJUST
     18  02f2					      ENDIF
     19  02f2				  -	      IF	$50 = $60
     20  02f2				  -	      .byte	$C0+$4-2+PALETTE_INTENSITY_ADJUST
     21  02f2					      ENDIF
     22  02f2				  -	      IF	$50 = $70
     23  02f2				  -	      .byte	$D0+$4-2+PALETTE_INTENSITY_ADJUST
     24  02f2					      ENDIF
     25  02f2				  -	      IF	$50 = $80
     26  02f2				  -	      .byte	$B0+$4-2+PALETTE_INTENSITY_ADJUST
     27  02f2					      ENDIF
     28  02f2				  -	      IF	$50 = $90
     29  02f2				  -	      .byte	$90+$4-2+PALETTE_INTENSITY_ADJUST
     30  02f2					      ENDIF
     31  02f2				  -	      IF	$50 = $A0
     32  02f2				  -	      .byte	$70+$4-2+PALETTE_INTENSITY_ADJUST
     33  02f2					      ENDIF
     34  02f2				  -	      IF	$50 = $B0
     35  02f2				  -	      .byte	$50+$4-2+PALETTE_INTENSITY_ADJUST
     36  02f2					      ENDIF
     37  02f2				  -	      IF	$50 = $C0
     38  02f2				  -	      .byte	$30+$4-2+PALETTE_INTENSITY_ADJUST
     39  02f2					      ENDIF
     40  02f2				  -	      IF	$50 = $D0
     41  02f2				  -	      .byte	$30+$4-2+PALETTE_INTENSITY_ADJUST
     42  02f2					      ENDIF
     43  02f2				  -	      IF	$50 = $E0
     44  02f2				  -	      .byte	$20+$4-2+PALETTE_INTENSITY_ADJUST
     45  02f2					      ENDIF
     46  02f2				  -	      IF	$50 = $F0
     47  02f2				  -	      .byte	$40+$4-2+PALETTE_INTENSITY_ADJUST
     48  02f2					      ENDIF
      0  02f2					      NTSC_TO_PAL	$70, 6-2+PALETTE_INTENSITY_ADJUST
      1  02f2				  -	      IF	$70 = 0
      2  02f2				  -	      .byte	$70+6-2+PALETTE_INTENSITY_ADJUST
      3  02f2					      ENDIF
      4  02f2				  -	      IF	$70 = $10
      5  02f2				  -	      .byte	$20+6-2+PALETTE_INTENSITY_ADJUST
      6  02f2					      ENDIF
      7  02f2				  -	      IF	$70 = $20
      8  02f2				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
      9  02f2					      ENDIF
     10  02f2				  -	      IF	$70 = $30
     11  02f2				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
     12  02f2					      ENDIF
     13  02f2				  -	      IF	$70 = $40
     14  02f2				  -	      .byte	$60+6-2+PALETTE_INTENSITY_ADJUST
     15  02f2					      ENDIF
     16  02f2				  -	      IF	$70 = $50
     17  02f2				  -	      .byte	$80+6-2+PALETTE_INTENSITY_ADJUST
     18  02f2					      ENDIF
     19  02f2				  -	      IF	$70 = $60
     20  02f2				  -	      .byte	$C0+6-2+PALETTE_INTENSITY_ADJUST
     21  02f2					      ENDIF
     22  02f2					      IF	$70 = $70
     23  02f2		       d6		      .byte.b	$D0+6-2+PALETTE_INTENSITY_ADJUST
     24  02f3					      ENDIF
     25  02f3				  -	      IF	$70 = $80
     26  02f3				  -	      .byte	$B0+6-2+PALETTE_INTENSITY_ADJUST
     27  02f3					      ENDIF
     28  02f3				  -	      IF	$70 = $90
     29  02f3				  -	      .byte	$90+6-2+PALETTE_INTENSITY_ADJUST
     30  02f3					      ENDIF
     31  02f3				  -	      IF	$70 = $A0
     32  02f3				  -	      .byte	$70+6-2+PALETTE_INTENSITY_ADJUST
     33  02f3					      ENDIF
     34  02f3				  -	      IF	$70 = $B0
     35  02f3				  -	      .byte	$50+6-2+PALETTE_INTENSITY_ADJUST
     36  02f3					      ENDIF
     37  02f3				  -	      IF	$70 = $C0
     38  02f3				  -	      .byte	$30+6-2+PALETTE_INTENSITY_ADJUST
     39  02f3					      ENDIF
     40  02f3				  -	      IF	$70 = $D0
     41  02f3				  -	      .byte	$30+6-2+PALETTE_INTENSITY_ADJUST
     42  02f3					      ENDIF
     43  02f3				  -	      IF	$70 = $E0
     44  02f3				  -	      .byte	$20+6-2+PALETTE_INTENSITY_ADJUST
     45  02f3					      ENDIF
     46  02f3				  -	      IF	$70 = $F0
     47  02f3				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
     48  02f3					      ENDIF
      0  02f3					      NTSC_TO_PAL	$40, 6-2+PALETTE_INTENSITY_ADJUST
      1  02f3				  -	      IF	$40 = 0
      2  02f3				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
      3  02f3					      ENDIF
      4  02f3				  -	      IF	$40 = $10
      5  02f3				  -	      .byte	$20+6-2+PALETTE_INTENSITY_ADJUST
      6  02f3					      ENDIF
      7  02f3				  -	      IF	$40 = $20
      8  02f3				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
      9  02f3					      ENDIF
     10  02f3				  -	      IF	$40 = $30
     11  02f3				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
     12  02f3					      ENDIF
     13  02f3					      IF	$40 = $40
     14  02f3		       66		      .byte.b	$60+6-2+PALETTE_INTENSITY_ADJUST
     15  02f4					      ENDIF
     16  02f4				  -	      IF	$40 = $50
     17  02f4				  -	      .byte	$80+6-2+PALETTE_INTENSITY_ADJUST
     18  02f4					      ENDIF
     19  02f4				  -	      IF	$40 = $60
     20  02f4				  -	      .byte	$C0+6-2+PALETTE_INTENSITY_ADJUST
     21  02f4					      ENDIF
     22  02f4				  -	      IF	$40 = $70
     23  02f4				  -	      .byte	$D0+6-2+PALETTE_INTENSITY_ADJUST
     24  02f4					      ENDIF
     25  02f4				  -	      IF	$40 = $80
     26  02f4				  -	      .byte	$B0+6-2+PALETTE_INTENSITY_ADJUST
     27  02f4					      ENDIF
     28  02f4				  -	      IF	$40 = $90
     29  02f4				  -	      .byte	$90+6-2+PALETTE_INTENSITY_ADJUST
     30  02f4					      ENDIF
     31  02f4				  -	      IF	$40 = $A0
     32  02f4				  -	      .byte	$70+6-2+PALETTE_INTENSITY_ADJUST
     33  02f4					      ENDIF
     34  02f4				  -	      IF	$40 = $B0
     35  02f4				  -	      .byte	$50+6-2+PALETTE_INTENSITY_ADJUST
     36  02f4					      ENDIF
     37  02f4				  -	      IF	$40 = $C0
     38  02f4				  -	      .byte	$30+6-2+PALETTE_INTENSITY_ADJUST
     39  02f4					      ENDIF
     40  02f4				  -	      IF	$40 = $D0
     41  02f4				  -	      .byte	$30+6-2+PALETTE_INTENSITY_ADJUST
     42  02f4					      ENDIF
     43  02f4				  -	      IF	$40 = $E0
     44  02f4				  -	      .byte	$20+6-2+PALETTE_INTENSITY_ADJUST
     45  02f4					      ENDIF
     46  02f4				  -	      IF	$40 = $F0
     47  02f4				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
     48  02f4					      ENDIF
     19  02f4		       00		      .byte.b	0
      0  02f5					      COLOUR_GROUP	$40,$6, $30,$8, $00,$A, $90,$4, $A0,6, $20,6	; 2
      1  02f5
      2  02f5		       00		      .byte.b	0
      3  02f6		       46		      .byte.b	$40+$6-2+PALETTE_INTENSITY_ADJUST
      4  02f7		       38		      .byte.b	$30+$8-2+PALETTE_INTENSITY_ADJUST
      5  02f8		       0a		      .byte.b	$00+$A-2+PALETTE_INTENSITY_ADJUST
      6  02f9		       94		      .byte.b	$90+$4-2+PALETTE_INTENSITY_ADJUST
      7  02fa		       a6		      .byte.b	$A0+6-2+PALETTE_INTENSITY_ADJUST
      8  02fb		       26		      .byte.b	$20+6-2+PALETTE_INTENSITY_ADJUST
      9  02fc		       00		      .byte.b	0
     10  02fd
     11  02fd
     12  02fd		       00		      .byte.b	0
      0  02fe					      NTSC_TO_PAL	$40, $6-2+PALETTE_INTENSITY_ADJUST
      1  02fe				  -	      IF	$40 = 0
      2  02fe				  -	      .byte	$40+$6-2+PALETTE_INTENSITY_ADJUST
      3  02fe					      ENDIF
      4  02fe				  -	      IF	$40 = $10
      5  02fe				  -	      .byte	$20+$6-2+PALETTE_INTENSITY_ADJUST
      6  02fe					      ENDIF
      7  02fe				  -	      IF	$40 = $20
      8  02fe				  -	      .byte	$40+$6-2+PALETTE_INTENSITY_ADJUST
      9  02fe					      ENDIF
     10  02fe				  -	      IF	$40 = $30
     11  02fe				  -	      .byte	$40+$6-2+PALETTE_INTENSITY_ADJUST
     12  02fe					      ENDIF
     13  02fe					      IF	$40 = $40
     14  02fe		       66		      .byte.b	$60+$6-2+PALETTE_INTENSITY_ADJUST
     15  02ff					      ENDIF
     16  02ff				  -	      IF	$40 = $50
     17  02ff				  -	      .byte	$80+$6-2+PALETTE_INTENSITY_ADJUST
     18  02ff					      ENDIF
     19  02ff				  -	      IF	$40 = $60
     20  02ff				  -	      .byte	$C0+$6-2+PALETTE_INTENSITY_ADJUST
     21  02ff					      ENDIF
     22  02ff				  -	      IF	$40 = $70
     23  02ff				  -	      .byte	$D0+$6-2+PALETTE_INTENSITY_ADJUST
     24  02ff					      ENDIF
     25  02ff				  -	      IF	$40 = $80
     26  02ff				  -	      .byte	$B0+$6-2+PALETTE_INTENSITY_ADJUST
     27  02ff					      ENDIF
     28  02ff				  -	      IF	$40 = $90
     29  02ff				  -	      .byte	$90+$6-2+PALETTE_INTENSITY_ADJUST
     30  02ff					      ENDIF
     31  02ff				  -	      IF	$40 = $A0
     32  02ff				  -	      .byte	$70+$6-2+PALETTE_INTENSITY_ADJUST
     33  02ff					      ENDIF
     34  02ff				  -	      IF	$40 = $B0
     35  02ff				  -	      .byte	$50+$6-2+PALETTE_INTENSITY_ADJUST
     36  02ff					      ENDIF
     37  02ff				  -	      IF	$40 = $C0
     38  02ff				  -	      .byte	$30+$6-2+PALETTE_INTENSITY_ADJUST
     39  02ff					      ENDIF
     40  02ff				  -	      IF	$40 = $D0
     41  02ff				  -	      .byte	$30+$6-2+PALETTE_INTENSITY_ADJUST
     42  02ff					      ENDIF
     43  02ff				  -	      IF	$40 = $E0
     44  02ff				  -	      .byte	$20+$6-2+PALETTE_INTENSITY_ADJUST
     45  02ff					      ENDIF
     46  02ff				  -	      IF	$40 = $F0
     47  02ff				  -	      .byte	$40+$6-2+PALETTE_INTENSITY_ADJUST
     48  02ff					      ENDIF
      0  02ff					      NTSC_TO_PAL	$30, $8-2+PALETTE_INTENSITY_ADJUST
      1  02ff				  -	      IF	$30 = 0
      2  02ff				  -	      .byte	$30+$8-2+PALETTE_INTENSITY_ADJUST
      3  02ff					      ENDIF
      4  02ff				  -	      IF	$30 = $10
      5  02ff				  -	      .byte	$20+$8-2+PALETTE_INTENSITY_ADJUST
      6  02ff					      ENDIF
      7  02ff				  -	      IF	$30 = $20
      8  02ff				  -	      .byte	$40+$8-2+PALETTE_INTENSITY_ADJUST
      9  02ff					      ENDIF
     10  02ff					      IF	$30 = $30
     11  02ff		       48		      .byte.b	$40+$8-2+PALETTE_INTENSITY_ADJUST
     12  0300					      ENDIF
     13  0300				  -	      IF	$30 = $40
     14  0300				  -	      .byte	$60+$8-2+PALETTE_INTENSITY_ADJUST
     15  0300					      ENDIF
     16  0300				  -	      IF	$30 = $50
     17  0300				  -	      .byte	$80+$8-2+PALETTE_INTENSITY_ADJUST
     18  0300					      ENDIF
     19  0300				  -	      IF	$30 = $60
     20  0300				  -	      .byte	$C0+$8-2+PALETTE_INTENSITY_ADJUST
     21  0300					      ENDIF
     22  0300				  -	      IF	$30 = $70
     23  0300				  -	      .byte	$D0+$8-2+PALETTE_INTENSITY_ADJUST
     24  0300					      ENDIF
     25  0300				  -	      IF	$30 = $80
     26  0300				  -	      .byte	$B0+$8-2+PALETTE_INTENSITY_ADJUST
     27  0300					      ENDIF
     28  0300				  -	      IF	$30 = $90
     29  0300				  -	      .byte	$90+$8-2+PALETTE_INTENSITY_ADJUST
     30  0300					      ENDIF
     31  0300				  -	      IF	$30 = $A0
     32  0300				  -	      .byte	$70+$8-2+PALETTE_INTENSITY_ADJUST
     33  0300					      ENDIF
     34  0300				  -	      IF	$30 = $B0
     35  0300				  -	      .byte	$50+$8-2+PALETTE_INTENSITY_ADJUST
     36  0300					      ENDIF
     37  0300				  -	      IF	$30 = $C0
     38  0300				  -	      .byte	$30+$8-2+PALETTE_INTENSITY_ADJUST
     39  0300					      ENDIF
     40  0300				  -	      IF	$30 = $D0
     41  0300				  -	      .byte	$30+$8-2+PALETTE_INTENSITY_ADJUST
     42  0300					      ENDIF
     43  0300				  -	      IF	$30 = $E0
     44  0300				  -	      .byte	$20+$8-2+PALETTE_INTENSITY_ADJUST
     45  0300					      ENDIF
     46  0300				  -	      IF	$30 = $F0
     47  0300				  -	      .byte	$40+$8-2+PALETTE_INTENSITY_ADJUST
     48  0300					      ENDIF
      0  0300					      NTSC_TO_PAL	$00, $A-2+PALETTE_INTENSITY_ADJUST
      1  0300					      IF	$00 = 0
      2  0300		       0a		      .byte.b	$00+$A-2+PALETTE_INTENSITY_ADJUST
      3  0301					      ENDIF
      4  0301				  -	      IF	$00 = $10
      5  0301				  -	      .byte	$20+$A-2+PALETTE_INTENSITY_ADJUST
      6  0301					      ENDIF
      7  0301				  -	      IF	$00 = $20
      8  0301				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
      9  0301					      ENDIF
     10  0301				  -	      IF	$00 = $30
     11  0301				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
     12  0301					      ENDIF
     13  0301				  -	      IF	$00 = $40
     14  0301				  -	      .byte	$60+$A-2+PALETTE_INTENSITY_ADJUST
     15  0301					      ENDIF
     16  0301				  -	      IF	$00 = $50
     17  0301				  -	      .byte	$80+$A-2+PALETTE_INTENSITY_ADJUST
     18  0301					      ENDIF
     19  0301				  -	      IF	$00 = $60
     20  0301				  -	      .byte	$C0+$A-2+PALETTE_INTENSITY_ADJUST
     21  0301					      ENDIF
     22  0301				  -	      IF	$00 = $70
     23  0301				  -	      .byte	$D0+$A-2+PALETTE_INTENSITY_ADJUST
     24  0301					      ENDIF
     25  0301				  -	      IF	$00 = $80
     26  0301				  -	      .byte	$B0+$A-2+PALETTE_INTENSITY_ADJUST
     27  0301					      ENDIF
     28  0301				  -	      IF	$00 = $90
     29  0301				  -	      .byte	$90+$A-2+PALETTE_INTENSITY_ADJUST
     30  0301					      ENDIF
     31  0301				  -	      IF	$00 = $A0
     32  0301				  -	      .byte	$70+$A-2+PALETTE_INTENSITY_ADJUST
     33  0301					      ENDIF
     34  0301				  -	      IF	$00 = $B0
     35  0301				  -	      .byte	$50+$A-2+PALETTE_INTENSITY_ADJUST
     36  0301					      ENDIF
     37  0301				  -	      IF	$00 = $C0
     38  0301				  -	      .byte	$30+$A-2+PALETTE_INTENSITY_ADJUST
     39  0301					      ENDIF
     40  0301				  -	      IF	$00 = $D0
     41  0301				  -	      .byte	$30+$A-2+PALETTE_INTENSITY_ADJUST
     42  0301					      ENDIF
     43  0301				  -	      IF	$00 = $E0
     44  0301				  -	      .byte	$20+$A-2+PALETTE_INTENSITY_ADJUST
     45  0301					      ENDIF
     46  0301				  -	      IF	$00 = $F0
     47  0301				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
     48  0301					      ENDIF
      0  0301					      NTSC_TO_PAL	$90, $4-2+PALETTE_INTENSITY_ADJUST
      1  0301				  -	      IF	$90 = 0
      2  0301				  -	      .byte	$90+$4-2+PALETTE_INTENSITY_ADJUST
      3  0301					      ENDIF
      4  0301				  -	      IF	$90 = $10
      5  0301				  -	      .byte	$20+$4-2+PALETTE_INTENSITY_ADJUST
      6  0301					      ENDIF
      7  0301				  -	      IF	$90 = $20
      8  0301				  -	      .byte	$40+$4-2+PALETTE_INTENSITY_ADJUST
      9  0301					      ENDIF
     10  0301				  -	      IF	$90 = $30
     11  0301				  -	      .byte	$40+$4-2+PALETTE_INTENSITY_ADJUST
     12  0301					      ENDIF
     13  0301				  -	      IF	$90 = $40
     14  0301				  -	      .byte	$60+$4-2+PALETTE_INTENSITY_ADJUST
     15  0301					      ENDIF
     16  0301				  -	      IF	$90 = $50
     17  0301				  -	      .byte	$80+$4-2+PALETTE_INTENSITY_ADJUST
     18  0301					      ENDIF
     19  0301				  -	      IF	$90 = $60
     20  0301				  -	      .byte	$C0+$4-2+PALETTE_INTENSITY_ADJUST
     21  0301					      ENDIF
     22  0301				  -	      IF	$90 = $70
     23  0301				  -	      .byte	$D0+$4-2+PALETTE_INTENSITY_ADJUST
     24  0301					      ENDIF
     25  0301				  -	      IF	$90 = $80
     26  0301				  -	      .byte	$B0+$4-2+PALETTE_INTENSITY_ADJUST
     27  0301					      ENDIF
     28  0301					      IF	$90 = $90
     29  0301		       94		      .byte.b	$90+$4-2+PALETTE_INTENSITY_ADJUST
     30  0302					      ENDIF
     31  0302				  -	      IF	$90 = $A0
     32  0302				  -	      .byte	$70+$4-2+PALETTE_INTENSITY_ADJUST
     33  0302					      ENDIF
     34  0302				  -	      IF	$90 = $B0
     35  0302				  -	      .byte	$50+$4-2+PALETTE_INTENSITY_ADJUST
     36  0302					      ENDIF
     37  0302				  -	      IF	$90 = $C0
     38  0302				  -	      .byte	$30+$4-2+PALETTE_INTENSITY_ADJUST
     39  0302					      ENDIF
     40  0302				  -	      IF	$90 = $D0
     41  0302				  -	      .byte	$30+$4-2+PALETTE_INTENSITY_ADJUST
     42  0302					      ENDIF
     43  0302				  -	      IF	$90 = $E0
     44  0302				  -	      .byte	$20+$4-2+PALETTE_INTENSITY_ADJUST
     45  0302					      ENDIF
     46  0302				  -	      IF	$90 = $F0
     47  0302				  -	      .byte	$40+$4-2+PALETTE_INTENSITY_ADJUST
     48  0302					      ENDIF
      0  0302					      NTSC_TO_PAL	$A0, 6-2+PALETTE_INTENSITY_ADJUST
      1  0302				  -	      IF	$A0 = 0
      2  0302				  -	      .byte	$A0+6-2+PALETTE_INTENSITY_ADJUST
      3  0302					      ENDIF
      4  0302				  -	      IF	$A0 = $10
      5  0302				  -	      .byte	$20+6-2+PALETTE_INTENSITY_ADJUST
      6  0302					      ENDIF
      7  0302				  -	      IF	$A0 = $20
      8  0302				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
      9  0302					      ENDIF
     10  0302				  -	      IF	$A0 = $30
     11  0302				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
     12  0302					      ENDIF
     13  0302				  -	      IF	$A0 = $40
     14  0302				  -	      .byte	$60+6-2+PALETTE_INTENSITY_ADJUST
     15  0302					      ENDIF
     16  0302				  -	      IF	$A0 = $50
     17  0302				  -	      .byte	$80+6-2+PALETTE_INTENSITY_ADJUST
     18  0302					      ENDIF
     19  0302				  -	      IF	$A0 = $60
     20  0302				  -	      .byte	$C0+6-2+PALETTE_INTENSITY_ADJUST
     21  0302					      ENDIF
     22  0302				  -	      IF	$A0 = $70
     23  0302				  -	      .byte	$D0+6-2+PALETTE_INTENSITY_ADJUST
     24  0302					      ENDIF
     25  0302				  -	      IF	$A0 = $80
     26  0302				  -	      .byte	$B0+6-2+PALETTE_INTENSITY_ADJUST
     27  0302					      ENDIF
     28  0302				  -	      IF	$A0 = $90
     29  0302				  -	      .byte	$90+6-2+PALETTE_INTENSITY_ADJUST
     30  0302					      ENDIF
     31  0302					      IF	$A0 = $A0
     32  0302		       76		      .byte.b	$70+6-2+PALETTE_INTENSITY_ADJUST
     33  0303					      ENDIF
     34  0303				  -	      IF	$A0 = $B0
     35  0303				  -	      .byte	$50+6-2+PALETTE_INTENSITY_ADJUST
     36  0303					      ENDIF
     37  0303				  -	      IF	$A0 = $C0
     38  0303				  -	      .byte	$30+6-2+PALETTE_INTENSITY_ADJUST
     39  0303					      ENDIF
     40  0303				  -	      IF	$A0 = $D0
     41  0303				  -	      .byte	$30+6-2+PALETTE_INTENSITY_ADJUST
     42  0303					      ENDIF
     43  0303				  -	      IF	$A0 = $E0
     44  0303				  -	      .byte	$20+6-2+PALETTE_INTENSITY_ADJUST
     45  0303					      ENDIF
     46  0303				  -	      IF	$A0 = $F0
     47  0303				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
     48  0303					      ENDIF
      0  0303					      NTSC_TO_PAL	$20, 6-2+PALETTE_INTENSITY_ADJUST
      1  0303				  -	      IF	$20 = 0
      2  0303				  -	      .byte	$20+6-2+PALETTE_INTENSITY_ADJUST
      3  0303					      ENDIF
      4  0303				  -	      IF	$20 = $10
      5  0303				  -	      .byte	$20+6-2+PALETTE_INTENSITY_ADJUST
      6  0303					      ENDIF
      7  0303					      IF	$20 = $20
      8  0303		       46		      .byte.b	$40+6-2+PALETTE_INTENSITY_ADJUST
      9  0304					      ENDIF
     10  0304				  -	      IF	$20 = $30
     11  0304				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
     12  0304					      ENDIF
     13  0304				  -	      IF	$20 = $40
     14  0304				  -	      .byte	$60+6-2+PALETTE_INTENSITY_ADJUST
     15  0304					      ENDIF
     16  0304				  -	      IF	$20 = $50
     17  0304				  -	      .byte	$80+6-2+PALETTE_INTENSITY_ADJUST
     18  0304					      ENDIF
     19  0304				  -	      IF	$20 = $60
     20  0304				  -	      .byte	$C0+6-2+PALETTE_INTENSITY_ADJUST
     21  0304					      ENDIF
     22  0304				  -	      IF	$20 = $70
     23  0304				  -	      .byte	$D0+6-2+PALETTE_INTENSITY_ADJUST
     24  0304					      ENDIF
     25  0304				  -	      IF	$20 = $80
     26  0304				  -	      .byte	$B0+6-2+PALETTE_INTENSITY_ADJUST
     27  0304					      ENDIF
     28  0304				  -	      IF	$20 = $90
     29  0304				  -	      .byte	$90+6-2+PALETTE_INTENSITY_ADJUST
     30  0304					      ENDIF
     31  0304				  -	      IF	$20 = $A0
     32  0304				  -	      .byte	$70+6-2+PALETTE_INTENSITY_ADJUST
     33  0304					      ENDIF
     34  0304				  -	      IF	$20 = $B0
     35  0304				  -	      .byte	$50+6-2+PALETTE_INTENSITY_ADJUST
     36  0304					      ENDIF
     37  0304				  -	      IF	$20 = $C0
     38  0304				  -	      .byte	$30+6-2+PALETTE_INTENSITY_ADJUST
     39  0304					      ENDIF
     40  0304				  -	      IF	$20 = $D0
     41  0304				  -	      .byte	$30+6-2+PALETTE_INTENSITY_ADJUST
     42  0304					      ENDIF
     43  0304				  -	      IF	$20 = $E0
     44  0304				  -	      .byte	$20+6-2+PALETTE_INTENSITY_ADJUST
     45  0304					      ENDIF
     46  0304				  -	      IF	$20 = $F0
     47  0304				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
     48  0304					      ENDIF
     19  0304		       00		      .byte.b	0
      0  0305					      COLOUR_GROUP	$30,$A, $50,$8, $00,$A, $40,$4, $60,6, $E0,8	; 3
      1  0305
      2  0305		       00		      .byte.b	0
      3  0306		       3a		      .byte.b	$30+$A-2+PALETTE_INTENSITY_ADJUST
      4  0307		       58		      .byte.b	$50+$8-2+PALETTE_INTENSITY_ADJUST
      5  0308		       0a		      .byte.b	$00+$A-2+PALETTE_INTENSITY_ADJUST
      6  0309		       44		      .byte.b	$40+$4-2+PALETTE_INTENSITY_ADJUST
      7  030a		       66		      .byte.b	$60+6-2+PALETTE_INTENSITY_ADJUST
      8  030b		       e8		      .byte.b	$E0+8-2+PALETTE_INTENSITY_ADJUST
      9  030c		       00		      .byte.b	0
     10  030d
     11  030d
     12  030d		       00		      .byte.b	0
      0  030e					      NTSC_TO_PAL	$30, $A-2+PALETTE_INTENSITY_ADJUST
      1  030e				  -	      IF	$30 = 0
      2  030e				  -	      .byte	$30+$A-2+PALETTE_INTENSITY_ADJUST
      3  030e					      ENDIF
      4  030e				  -	      IF	$30 = $10
      5  030e				  -	      .byte	$20+$A-2+PALETTE_INTENSITY_ADJUST
      6  030e					      ENDIF
      7  030e				  -	      IF	$30 = $20
      8  030e				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
      9  030e					      ENDIF
     10  030e					      IF	$30 = $30
     11  030e		       4a		      .byte.b	$40+$A-2+PALETTE_INTENSITY_ADJUST
     12  030f					      ENDIF
     13  030f				  -	      IF	$30 = $40
     14  030f				  -	      .byte	$60+$A-2+PALETTE_INTENSITY_ADJUST
     15  030f					      ENDIF
     16  030f				  -	      IF	$30 = $50
     17  030f				  -	      .byte	$80+$A-2+PALETTE_INTENSITY_ADJUST
     18  030f					      ENDIF
     19  030f				  -	      IF	$30 = $60
     20  030f				  -	      .byte	$C0+$A-2+PALETTE_INTENSITY_ADJUST
     21  030f					      ENDIF
     22  030f				  -	      IF	$30 = $70
     23  030f				  -	      .byte	$D0+$A-2+PALETTE_INTENSITY_ADJUST
     24  030f					      ENDIF
     25  030f				  -	      IF	$30 = $80
     26  030f				  -	      .byte	$B0+$A-2+PALETTE_INTENSITY_ADJUST
     27  030f					      ENDIF
     28  030f				  -	      IF	$30 = $90
     29  030f				  -	      .byte	$90+$A-2+PALETTE_INTENSITY_ADJUST
     30  030f					      ENDIF
     31  030f				  -	      IF	$30 = $A0
     32  030f				  -	      .byte	$70+$A-2+PALETTE_INTENSITY_ADJUST
     33  030f					      ENDIF
     34  030f				  -	      IF	$30 = $B0
     35  030f				  -	      .byte	$50+$A-2+PALETTE_INTENSITY_ADJUST
     36  030f					      ENDIF
     37  030f				  -	      IF	$30 = $C0
     38  030f				  -	      .byte	$30+$A-2+PALETTE_INTENSITY_ADJUST
     39  030f					      ENDIF
     40  030f				  -	      IF	$30 = $D0
     41  030f				  -	      .byte	$30+$A-2+PALETTE_INTENSITY_ADJUST
     42  030f					      ENDIF
     43  030f				  -	      IF	$30 = $E0
     44  030f				  -	      .byte	$20+$A-2+PALETTE_INTENSITY_ADJUST
     45  030f					      ENDIF
     46  030f				  -	      IF	$30 = $F0
     47  030f				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
     48  030f					      ENDIF
      0  030f					      NTSC_TO_PAL	$50, $8-2+PALETTE_INTENSITY_ADJUST
      1  030f				  -	      IF	$50 = 0
      2  030f				  -	      .byte	$50+$8-2+PALETTE_INTENSITY_ADJUST
      3  030f					      ENDIF
      4  030f				  -	      IF	$50 = $10
      5  030f				  -	      .byte	$20+$8-2+PALETTE_INTENSITY_ADJUST
      6  030f					      ENDIF
      7  030f				  -	      IF	$50 = $20
      8  030f				  -	      .byte	$40+$8-2+PALETTE_INTENSITY_ADJUST
      9  030f					      ENDIF
     10  030f				  -	      IF	$50 = $30
     11  030f				  -	      .byte	$40+$8-2+PALETTE_INTENSITY_ADJUST
     12  030f					      ENDIF
     13  030f				  -	      IF	$50 = $40
     14  030f				  -	      .byte	$60+$8-2+PALETTE_INTENSITY_ADJUST
     15  030f					      ENDIF
     16  030f					      IF	$50 = $50
     17  030f		       88		      .byte.b	$80+$8-2+PALETTE_INTENSITY_ADJUST
     18  0310					      ENDIF
     19  0310				  -	      IF	$50 = $60
     20  0310				  -	      .byte	$C0+$8-2+PALETTE_INTENSITY_ADJUST
     21  0310					      ENDIF
     22  0310				  -	      IF	$50 = $70
     23  0310				  -	      .byte	$D0+$8-2+PALETTE_INTENSITY_ADJUST
     24  0310					      ENDIF
     25  0310				  -	      IF	$50 = $80
     26  0310				  -	      .byte	$B0+$8-2+PALETTE_INTENSITY_ADJUST
     27  0310					      ENDIF
     28  0310				  -	      IF	$50 = $90
     29  0310				  -	      .byte	$90+$8-2+PALETTE_INTENSITY_ADJUST
     30  0310					      ENDIF
     31  0310				  -	      IF	$50 = $A0
     32  0310				  -	      .byte	$70+$8-2+PALETTE_INTENSITY_ADJUST
     33  0310					      ENDIF
     34  0310				  -	      IF	$50 = $B0
     35  0310				  -	      .byte	$50+$8-2+PALETTE_INTENSITY_ADJUST
     36  0310					      ENDIF
     37  0310				  -	      IF	$50 = $C0
     38  0310				  -	      .byte	$30+$8-2+PALETTE_INTENSITY_ADJUST
     39  0310					      ENDIF
     40  0310				  -	      IF	$50 = $D0
     41  0310				  -	      .byte	$30+$8-2+PALETTE_INTENSITY_ADJUST
     42  0310					      ENDIF
     43  0310				  -	      IF	$50 = $E0
     44  0310				  -	      .byte	$20+$8-2+PALETTE_INTENSITY_ADJUST
     45  0310					      ENDIF
     46  0310				  -	      IF	$50 = $F0
     47  0310				  -	      .byte	$40+$8-2+PALETTE_INTENSITY_ADJUST
     48  0310					      ENDIF
      0  0310					      NTSC_TO_PAL	$00, $A-2+PALETTE_INTENSITY_ADJUST
      1  0310					      IF	$00 = 0
      2  0310		       0a		      .byte.b	$00+$A-2+PALETTE_INTENSITY_ADJUST
      3  0311					      ENDIF
      4  0311				  -	      IF	$00 = $10
      5  0311				  -	      .byte	$20+$A-2+PALETTE_INTENSITY_ADJUST
      6  0311					      ENDIF
      7  0311				  -	      IF	$00 = $20
      8  0311				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
      9  0311					      ENDIF
     10  0311				  -	      IF	$00 = $30
     11  0311				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
     12  0311					      ENDIF
     13  0311				  -	      IF	$00 = $40
     14  0311				  -	      .byte	$60+$A-2+PALETTE_INTENSITY_ADJUST
     15  0311					      ENDIF
     16  0311				  -	      IF	$00 = $50
     17  0311				  -	      .byte	$80+$A-2+PALETTE_INTENSITY_ADJUST
     18  0311					      ENDIF
     19  0311				  -	      IF	$00 = $60
     20  0311				  -	      .byte	$C0+$A-2+PALETTE_INTENSITY_ADJUST
     21  0311					      ENDIF
     22  0311				  -	      IF	$00 = $70
     23  0311				  -	      .byte	$D0+$A-2+PALETTE_INTENSITY_ADJUST
     24  0311					      ENDIF
     25  0311				  -	      IF	$00 = $80
     26  0311				  -	      .byte	$B0+$A-2+PALETTE_INTENSITY_ADJUST
     27  0311					      ENDIF
     28  0311				  -	      IF	$00 = $90
     29  0311				  -	      .byte	$90+$A-2+PALETTE_INTENSITY_ADJUST
     30  0311					      ENDIF
     31  0311				  -	      IF	$00 = $A0
     32  0311				  -	      .byte	$70+$A-2+PALETTE_INTENSITY_ADJUST
     33  0311					      ENDIF
     34  0311				  -	      IF	$00 = $B0
     35  0311				  -	      .byte	$50+$A-2+PALETTE_INTENSITY_ADJUST
     36  0311					      ENDIF
     37  0311				  -	      IF	$00 = $C0
     38  0311				  -	      .byte	$30+$A-2+PALETTE_INTENSITY_ADJUST
     39  0311					      ENDIF
     40  0311				  -	      IF	$00 = $D0
     41  0311				  -	      .byte	$30+$A-2+PALETTE_INTENSITY_ADJUST
     42  0311					      ENDIF
     43  0311				  -	      IF	$00 = $E0
     44  0311				  -	      .byte	$20+$A-2+PALETTE_INTENSITY_ADJUST
     45  0311					      ENDIF
     46  0311				  -	      IF	$00 = $F0
     47  0311				  -	      .byte	$40+$A-2+PALETTE_INTENSITY_ADJUST
     48  0311					      ENDIF
      0  0311					      NTSC_TO_PAL	$40, $4-2+PALETTE_INTENSITY_ADJUST
      1  0311				  -	      IF	$40 = 0
      2  0311				  -	      .byte	$40+$4-2+PALETTE_INTENSITY_ADJUST
      3  0311					      ENDIF
      4  0311				  -	      IF	$40 = $10
      5  0311				  -	      .byte	$20+$4-2+PALETTE_INTENSITY_ADJUST
      6  0311					      ENDIF
      7  0311				  -	      IF	$40 = $20
      8  0311				  -	      .byte	$40+$4-2+PALETTE_INTENSITY_ADJUST
      9  0311					      ENDIF
     10  0311				  -	      IF	$40 = $30
     11  0311				  -	      .byte	$40+$4-2+PALETTE_INTENSITY_ADJUST
     12  0311					      ENDIF
     13  0311					      IF	$40 = $40
     14  0311		       64		      .byte.b	$60+$4-2+PALETTE_INTENSITY_ADJUST
     15  0312					      ENDIF
     16  0312				  -	      IF	$40 = $50
     17  0312				  -	      .byte	$80+$4-2+PALETTE_INTENSITY_ADJUST
     18  0312					      ENDIF
     19  0312				  -	      IF	$40 = $60
     20  0312				  -	      .byte	$C0+$4-2+PALETTE_INTENSITY_ADJUST
     21  0312					      ENDIF
     22  0312				  -	      IF	$40 = $70
     23  0312				  -	      .byte	$D0+$4-2+PALETTE_INTENSITY_ADJUST
     24  0312					      ENDIF
     25  0312				  -	      IF	$40 = $80
     26  0312				  -	      .byte	$B0+$4-2+PALETTE_INTENSITY_ADJUST
     27  0312					      ENDIF
     28  0312				  -	      IF	$40 = $90
     29  0312				  -	      .byte	$90+$4-2+PALETTE_INTENSITY_ADJUST
     30  0312					      ENDIF
     31  0312				  -	      IF	$40 = $A0
     32  0312				  -	      .byte	$70+$4-2+PALETTE_INTENSITY_ADJUST
     33  0312					      ENDIF
     34  0312				  -	      IF	$40 = $B0
     35  0312				  -	      .byte	$50+$4-2+PALETTE_INTENSITY_ADJUST
     36  0312					      ENDIF
     37  0312				  -	      IF	$40 = $C0
     38  0312				  -	      .byte	$30+$4-2+PALETTE_INTENSITY_ADJUST
     39  0312					      ENDIF
     40  0312				  -	      IF	$40 = $D0
     41  0312				  -	      .byte	$30+$4-2+PALETTE_INTENSITY_ADJUST
     42  0312					      ENDIF
     43  0312				  -	      IF	$40 = $E0
     44  0312				  -	      .byte	$20+$4-2+PALETTE_INTENSITY_ADJUST
     45  0312					      ENDIF
     46  0312				  -	      IF	$40 = $F0
     47  0312				  -	      .byte	$40+$4-2+PALETTE_INTENSITY_ADJUST
     48  0312					      ENDIF
      0  0312					      NTSC_TO_PAL	$60, 6-2+PALETTE_INTENSITY_ADJUST
      1  0312				  -	      IF	$60 = 0
      2  0312				  -	      .byte	$60+6-2+PALETTE_INTENSITY_ADJUST
      3  0312					      ENDIF
      4  0312				  -	      IF	$60 = $10
      5  0312				  -	      .byte	$20+6-2+PALETTE_INTENSITY_ADJUST
      6  0312					      ENDIF
      7  0312				  -	      IF	$60 = $20
      8  0312				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
      9  0312					      ENDIF
     10  0312				  -	      IF	$60 = $30
     11  0312				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
     12  0312					      ENDIF
     13  0312				  -	      IF	$60 = $40
     14  0312				  -	      .byte	$60+6-2+PALETTE_INTENSITY_ADJUST
     15  0312					      ENDIF
     16  0312				  -	      IF	$60 = $50
     17  0312				  -	      .byte	$80+6-2+PALETTE_INTENSITY_ADJUST
     18  0312					      ENDIF
     19  0312					      IF	$60 = $60
     20  0312		       c6		      .byte.b	$C0+6-2+PALETTE_INTENSITY_ADJUST
     21  0313					      ENDIF
     22  0313				  -	      IF	$60 = $70
     23  0313				  -	      .byte	$D0+6-2+PALETTE_INTENSITY_ADJUST
     24  0313					      ENDIF
     25  0313				  -	      IF	$60 = $80
     26  0313				  -	      .byte	$B0+6-2+PALETTE_INTENSITY_ADJUST
     27  0313					      ENDIF
     28  0313				  -	      IF	$60 = $90
     29  0313				  -	      .byte	$90+6-2+PALETTE_INTENSITY_ADJUST
     30  0313					      ENDIF
     31  0313				  -	      IF	$60 = $A0
     32  0313				  -	      .byte	$70+6-2+PALETTE_INTENSITY_ADJUST
     33  0313					      ENDIF
     34  0313				  -	      IF	$60 = $B0
     35  0313				  -	      .byte	$50+6-2+PALETTE_INTENSITY_ADJUST
     36  0313					      ENDIF
     37  0313				  -	      IF	$60 = $C0
     38  0313				  -	      .byte	$30+6-2+PALETTE_INTENSITY_ADJUST
     39  0313					      ENDIF
     40  0313				  -	      IF	$60 = $D0
     41  0313				  -	      .byte	$30+6-2+PALETTE_INTENSITY_ADJUST
     42  0313					      ENDIF
     43  0313				  -	      IF	$60 = $E0
     44  0313				  -	      .byte	$20+6-2+PALETTE_INTENSITY_ADJUST
     45  0313					      ENDIF
     46  0313				  -	      IF	$60 = $F0
     47  0313				  -	      .byte	$40+6-2+PALETTE_INTENSITY_ADJUST
     48  0313					      ENDIF
      0  0313					      NTSC_TO_PAL	$E0, 8-2+PALETTE_INTENSITY_ADJUST
      1  0313				  -	      IF	$E0 = 0
      2  0313				  -	      .byte	$E0+8-2+PALETTE_INTENSITY_ADJUST
      3  0313					      ENDIF
      4  0313				  -	      IF	$E0 = $10
      5  0313				  -	      .byte	$20+8-2+PALETTE_INTENSITY_ADJUST
      6  0313					      ENDIF
      7  0313				  -	      IF	$E0 = $20
      8  0313				  -	      .byte	$40+8-2+PALETTE_INTENSITY_ADJUST
      9  0313					      ENDIF
     10  0313				  -	      IF	$E0 = $30
     11  0313				  -	      .byte	$40+8-2+PALETTE_INTENSITY_ADJUST
     12  0313					      ENDIF
     13  0313				  -	      IF	$E0 = $40
     14  0313				  -	      .byte	$60+8-2+PALETTE_INTENSITY_ADJUST
     15  0313					      ENDIF
     16  0313				  -	      IF	$E0 = $50
     17  0313				  -	      .byte	$80+8-2+PALETTE_INTENSITY_ADJUST
     18  0313					      ENDIF
     19  0313				  -	      IF	$E0 = $60
     20  0313				  -	      .byte	$C0+8-2+PALETTE_INTENSITY_ADJUST
     21  0313					      ENDIF
     22  0313				  -	      IF	$E0 = $70
     23  0313				  -	      .byte	$D0+8-2+PALETTE_INTENSITY_ADJUST
     24  0313					      ENDIF
     25  0313				  -	      IF	$E0 = $80
     26  0313				  -	      .byte	$B0+8-2+PALETTE_INTENSITY_ADJUST
     27  0313					      ENDIF
     28  0313				  -	      IF	$E0 = $90
     29  0313				  -	      .byte	$90+8-2+PALETTE_INTENSITY_ADJUST
     30  0313					      ENDIF
     31  0313				  -	      IF	$E0 = $A0
     32  0313				  -	      .byte	$70+8-2+PALETTE_INTENSITY_ADJUST
     33  0313					      ENDIF
     34  0313				  -	      IF	$E0 = $B0
     35  0313				  -	      .byte	$50+8-2+PALETTE_INTENSITY_ADJUST
     36  0313					      ENDIF
     37  0313				  -	      IF	$E0 = $C0
     38  0313				  -	      .byte	$30+8-2+PALETTE_INTENSITY_ADJUST
     39  0313					      ENDIF
     40  0313				  -	      IF	$E0 = $D0
     41  0313				  -	      .byte	$30+8-2+PALETTE_INTENSITY_ADJUST
     42  0313					      ENDIF
     43  0313					      IF	$E0 = $E0
     44  0313		       28		      .byte.b	$20+8-2+PALETTE_INTENSITY_ADJUST
     45  0314					      ENDIF
     46  0314				  -	      IF	$E0 = $F0
     47  0314				  -	      .byte	$40+8-2+PALETTE_INTENSITY_ADJUST
     48  0314					      ENDIF
     19  0314		       00		      .byte.b	0
    708  0315
    709  0315							;---------------------------------------------------------------------------
    710  0315
      0  0315					      DEFINE_SUBROUTINE	CharacterDataVecHI
      1  0315		       00 00	   BANK_CharacterDataVecHI =	_CURRENT_BANK
      2  0315					      SUBROUTINE
      3  0315				   CharacterDataVecHI
    712  0315
    713  0315		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    714  0316		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    715  0317		       ff		      .byte.b	>CHARACTERSHAPE_SOIL
    716  0318		       ff		      .byte.b	>CHARACTERSHAPE_SOIL_MIRRORED
    717  0319		       ff		      .byte.b	>CHARACTERSHAPE_BOX
    718  031a		       ff		      .byte.b	>CHARACTERSHAPE_BOX_MIRRORED
    719  031b		       fe		      .byte.b	>CHARACTERSHAPE_TARGET1
    720  031c		       fe		      .byte.b	>CHARACTERSHAPE_TARGET1_MIRRORED
    721  031d		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    722  031e		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    723  031f		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; man occupied
    724  0320		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    725  0321		       fd		      .byte.b	>CHARACTERSHAPE_STEEL
    726  0322		       fe		      .byte.b	>CHARACTERSHAPE_STEEL_MIRRORED
    727  0323		       fe		      .byte.b	>CHARACTERSHAPE_RIVET
    728  0324		       ff		      .byte.b	>CHARACTERSHAPE_RIVET_MIRRORED
    729  0325		       ff		      .byte.b	>CHARACTERSHAPE_WALL
    730  0326		       ff		      .byte.b	>CHARACTERSHAPE_WALL_MIRRORED
    731  0327		       ff		      .byte.b	>CHARACTERSHAPE_STRIPE
    732  0328		       ff		      .byte.b	>CHARACTERSHAPE_STRIPE_MIRRORED
    733  0329		       ff		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET
    734  032a		       ff		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    735  032b							;    .byte >CHARACTERSHAPE_BOX_ON_TARGET2
    736  032b							;    .byte >CHARACTERSHAPE_BOX_ON_TARGET2_MIRRORED
    737  032b		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
    738  032c		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
    739  032d		       fe		      .byte.b	>CHARACTERSHAPE_TARGET1
    740  032e		       fe		      .byte.b	>CHARACTERSHAPE_TARGET1_MIRRORED
    741  032f		       fe		      .byte.b	>CHARACTERSHAPE_TARGET3
    742  0330		       fe		      .byte.b	>CHARACTERSHAPE_TARGET3_MIRRORED
    743  0331		       fe		      .byte.b	>CHARACTERSHAPE_TARGET5
    744  0332		       fe		      .byte.b	>CHARACTERSHAPE_TARGET5_MIRRORED
    745  0333		       fe		      .byte.b	>CHARACTERSHAPE_TARGET7
    746  0334		       fe		      .byte.b	>CHARACTERSHAPE_TARGET7_MIRRORED
    747  0335
    748  0335				  -	      if	DIGITS
    749  0335				  -	      .byte	>CHARACTERSHAPE_0, >CHARACTERSHAPE_0_MIRRORED
    750  0335				  -	      .byte	>CHARACTERSHAPE_1, >CHARACTERSHAPE_1_MIRRORED
    751  0335				  -	      .byte	>CHARACTERSHAPE_2, >CHARACTERSHAPE_2_MIRRORED
    752  0335				  -	      .byte	>CHARACTERSHAPE_3, >CHARACTERSHAPE_3_MIRRORED
    753  0335				  -	      .byte	>CHARACTERSHAPE_4, >CHARACTERSHAPE_4_MIRRORED
    754  0335				  -	      .byte	>CHARACTERSHAPE_5, >CHARACTERSHAPE_5_MIRRORED
    755  0335				  -	      .byte	>CHARACTERSHAPE_6, >CHARACTERSHAPE_6_MIRRORED
    756  0335				  -	      .byte	>CHARACTERSHAPE_7, >CHARACTERSHAPE_7_MIRRORED
    757  0335				  -	      .byte	>CHARACTERSHAPE_8, >CHARACTERSHAPE_8_MIRRORED
    758  0335				  -	      .byte	>CHARACTERSHAPE_9, >CHARACTERSHAPE_9_MIRRORED
    759  0335					      endif
    760  0335
    761  0335				  -	      IF	* - CharacterDataVecHI != CHARACTER_MAXIMUM*2
    762  0335				  -	      ECHO	"ERROR: Incorrect CharacterDataVecHI table!"
    763  0335				  -	      ERR
    764  0335					      ENDIF
    765  0335
      0  0335					      CHECKPAGEX	CharacterDataVecHI, "CharacterDataVecHI crosses page"
      9  0335					      LIST	ON
    767  0335
    768  0335
    769  0335							;OPTIONAL_PAGEBREAK "PLAYER BLANK SHAPE", LINES_PER_CHAR
    770  0335
    771  0335		       f3 4d	   ShapePlayer =	PLAYER0_SHAPE	;BLANK
    772  0335		       f3 4d	   ShapePlayerBLUE =	ShapePlayer	; low adresses patched
    773  0335		       f3 4d	   ShapePlayerGREEN =	ShapePlayer	; low adresses patched
    774  0335		       f3 4d	   ShapePlayerRED =	ShapePlayer	; low adresses patched
    775  0335
    776  0335		       f3 35	   CHARACTERSHAPE_MANOCCUPIED =	PLAYER_BLANK
    777  0335		       f3 35	   CHARACTERSHAPE_BLANK =	PLAYER_BLANK
    778  0335
    779  0335
    780  0335							; The following are the RAM buffers into which the player shape and colour data are copied
    781  0335							; The self-mod draw vectors point to this OR to a **blank** shape.
    782  0335
      0  0335					      OPTIONAL_PAGEBREAK	"PLAYER_BLANK", LINES_PER_CHAR
     10  0335					      LIST	ON
    784  0335				   PLAYER_BLANK
    785  0335		       00 00 00 00*	      ds	LINES_PER_CHAR, 0	; P1
      0  034d					      CHECKPAGEX	PLAYER_BLANK, "PLAYER_BLANK in BANK_ROM_SHADOW_RAMBANK.asm"
      9  034d					      LIST	ON
    787  034d
      0  034d					      OPTIONAL_PAGEBREAK	"PLAYER0_SHAPE", LINES_PER_CHAR
     10  034d					      LIST	ON
    789  034d				   PLAYER0_SHAPE
    790  034d		       00 00 00 00*	      ds	LINES_PER_CHAR,0
      0  0365					      CHECKPAGEX	PLAYER0_SHAPE, "PLAYER0_SHAPE in BANK_ROM_SHADOW_RAMBANK.asm"
      9  0365					      LIST	ON
    792  0365
      0  0365					      OPTIONAL_PAGEBREAK	"PLAYER0_COLOUR", LINES_PER_CHAR	; BOTH on same page
     10  0365					      LIST	ON
    794  0365				   PLAYER0_COLOUR
    795  0365		       00 00 00 00*	      ds	LINES_PER_CHAR,0
      0  037d					      CHECKPAGEX	PLAYER0_COLOUR, "PLAYER0_COLOUR in BANK_ROM_SHADOW_RAMBANK.asm"
      9  037d					      LIST	ON
    797  037d
    798  037d
    799  037d
    800  037d
    801  037d
    802  037d
    803  037d				   ColourBandsGreen
    804  037d
    805  037d							; NTSC...
    806  037d
    807  037d		       14 14		      ds	2,$16-4+PALETTE_INTENSITY_ADJUST
    808  037f		       f6 f6		      ds	2,$F8-4+PALETTE_INTENSITY_ADJUST
    809  0381		       26 26		      ds	2,$28-4+PALETTE_INTENSITY_ADJUST	; brown
    810  0383		       36 36		      ds	2,$38-4+PALETTE_INTENSITY_ADJUST
    811  0385		       46 46		      ds	2,$48-4+PALETTE_INTENSITY_ADJUST
    812  0387		       56 56		      ds	2,$58-4+PALETTE_INTENSITY_ADJUST
    813  0389		       68 68 68 	      ds	3,$6A-4+PALETTE_INTENSITY_ADJUST
    814  038c		       78 78		      ds	2,$7A-4+PALETTE_INTENSITY_ADJUST
    815  038e		       88 88		      ds	2,$8A-4+PALETTE_INTENSITY_ADJUST	; deep blue
    816  0390		       96 96 96 	      ds	3,$98-4+PALETTE_INTENSITY_ADJUST
    817  0393		       a6 a6		      ds	2,$A8-4+PALETTE_INTENSITY_ADJUST
    818  0395		       b6 b6		      ds	2,$B8-4+PALETTE_INTENSITY_ADJUST
    819  0397		       c6 c6		      ds	2,$C8-4+PALETTE_INTENSITY_ADJUST
    820  0399		       d6 d6		      ds	2,$D8-4+PALETTE_INTENSITY_ADJUST
    821  039b		       e6 e6		      ds	2,$E8-4+PALETTE_INTENSITY_ADJUST
    822  039d
    823  039d							; PAL...
    824  039d
    825  039d		       26 26 26 	      ds	3,$28-4+PALETTE_INTENSITY_ADJUST
    826  03a0		       46 46		      ds	2,$48-4+PALETTE_INTENSITY_ADJUST
    827  03a2		       66 66 66 	      ds	3,$68-4+PALETTE_INTENSITY_ADJUST
    828  03a5		       86 86		      ds	2,$88-4+PALETTE_INTENSITY_ADJUST
    829  03a7		       a6 a6		      ds	2,$A8-4+PALETTE_INTENSITY_ADJUST
    830  03a9		       c6 c6 c6 	      ds	3,$C8-4+PALETTE_INTENSITY_ADJUST
    831  03ac		       d6 d6 d6 	      ds	3,$D8-4+PALETTE_INTENSITY_ADJUST
    832  03af		       b6 b6 b6 	      ds	3,$B8-4+PALETTE_INTENSITY_ADJUST
    833  03b2		       96 96 96 	      ds	3,$98-4+PALETTE_INTENSITY_ADJUST
    834  03b5		       76 76		      ds	2,$78-4+PALETTE_INTENSITY_ADJUST
    835  03b7		       56 56 56 	      ds	3,$58-4+PALETTE_INTENSITY_ADJUST
    836  03ba		       36 36 36 	      ds	3,$38-4+PALETTE_INTENSITY_ADJUST
    837  03bd
    838  03bd
    839  03bd
    840  03bd
    841  03bd
      0  03bd					      DEFINE_SUBROUTINE	FixColours
      1  03bd		       00 00	   BANK_FixColours =	_CURRENT_BANK
      2  03bd					      SUBROUTINE
      3  03bd				   FixColours
    843  03bd							; USES OVERLAY "ColourFixer"
    844  03bd
    845  03bd		       a4 96		      ldy	BoardScrollY
    846  03bf		       cc fa f3 	      cpy	LastYScroll
    847  03c2		       f0 33		      beq	BandsNotChanged
    848  03c4		       8c fa f7 	      sty	LastYScroll+RAM_WRITE
    849  03c7
    850  03c7		       a5 80		      lda	Platform
    851  03c9		       29 02		      and	#%10
    852  03cb		       0a		      asl
    853  03cc		       0a		      asl
    854  03cd		       0a		      asl
    855  03ce		       0a		      asl
    856  03cf		       85 db		      sta	PlatformBase
    857  03d1
    858  03d1		       ad f8 f3 	      lda	BandOffset
    859  03d4		       65 96		      adc	BoardScrollY
    860  03d6		       85 dc		      sta	BandOffsetTemp
    861  03d8
    862  03d8
    863  03d8		       a2 07		      ldx	#SCREEN_LINES-1
    864  03da		       86 3e	   LoopBankLines stx	SET_BANK_RAM
    865  03dc
    866  03dc		       8a		      txa
    867  03dd		       18		      clc
    868  03de		       65 dc		      adc	BandOffsetTemp
    869  03e0		       29 1f		      and	#31
    870  03e2		       65 db		      adc	PlatformBase
    871  03e4		       a8		      tay
    872  03e5
    873  03e5		       b9 7d f3 	      lda	ColourBandsGreen,y
    874  03e8		       8d fc f7 	      sta	Colour_B + RAM_WRITE
    875  03eb
    876  03eb		       a4 cb		      ldy	FadeComplete
    877  03ed		       f0 02		      beq	writeActualCol
    878  03ef		       a9 00		      lda	#0
    879  03f1		       8d 86 f4    writeActualCol sta	Colour_B_Actual + RAM_WRITE
    880  03f4
    881  03f4		       ca		      dex
    882  03f5		       10 e3		      bpl	LoopBankLines
    883  03f7		       60	   BandsNotChanged rts
    884  03f8
    885  03f8		       14	   BandOffset .byte.b	20
    886  03f9		       ff	   ExistingFrame .byte.b	-1
    887  03fa		       ff	   LastYScroll .byte.b	-1
    888  03fb
    889  03fb
    890  03fb
    891  03fb
    892  03fb		       00	   Colour_A   .byte.b	0
    893  03fc		       00	   Colour_B   .byte.b	0
    894  03fd		       00	   Colour_C   .byte.b	0
    895  03fe
    896  03fe							; WARNING: DO NOT ALLOW A RTS AS LAST BYTE OF BANK, as it triggers a write at F400 access
    897  03fe
      0  03fe					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- 1K"
      1  03fe
      2  03fe
      3  03fe		       03 fe	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- 1K (1K) SIZE =  $3fe , FREE= $2
      4  03fe					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- 1K", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  03fe				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  03fe				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  03fe				  -	      ERR
      8  03fe					      endif
    899  03fe
    900  03fe							; Here there's another 1K of usable ROM....
    901  03fe							; Anything here is ONLY accessible if the bank is switched in as a ROM bank
    902  03fe							; WE CAN'T HAVE ANYTHING REQUIRED IN THE ROM_SHADOW (IN RAM) IN THIS HALF
    903  03fe
      0  03fe					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K"
      1  03fe		       03 fe	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- full 2K (2K) SIZE =  $3fe , FREE= $402
      2  03fe					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  03fe				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  03fe				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  03fe				  -	      ERR
      6  03fe					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm LEVEL 2 PASS 3
      0  03fe					      include	"BANK_ROM_SHADOW_DRAWBUFFERS.asm"
      1  03fe							;    Sokoboo - a Sokoban implementation
      2  03fe							;    using a generic tile-based display engine for the Atari 2600
      3  03fe							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  03fe							;
      5  03fe							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  03fe							;
      7  03fe							;    Code related to the generic tile-based display engine was developed by
      8  03fe							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  03fe							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  03fe							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  03fe							;
     12  03fe							;    Code related to music and sound effects uses the TIATracker music player
     13  03fe							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  03fe							;    directory for Apache licensing details.
     15  03fe							;
     16  03fe							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  03fe							;    See the copyright notices in the License directory for a list of level
     18  03fe							;    contributors.
     19  03fe							;
     20  03fe							;    Except where otherwise indicated, this software is released under the
     21  03fe							;    following licensing arrangement...
     22  03fe							;
     23  03fe							;    This program is free software: you can redistribute it and/or modify
     24  03fe							;    it under the terms of the GNU General Public License as published by
     25  03fe							;    the Free Software Foundation, either version 3 of the License, or
     26  03fe							;    (at your option) any later version.
     27  03fe							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  03fe
     29  03fe							;    This program is distributed in the hope that it will be useful,
     30  03fe							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  03fe							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  03fe							;    GNU General Public License for more details.
     33  03fe
     34  03fe							;------------------------------------------------------------------------------
     35  03fe							;##############################################################################
     36  03fe							;------------------------------------------------------------------------------
     37  03fe
      0  03fe					      NEWBANK	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      1  0a50 ????				      SEG	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   ROM_SHADOW_OF_BANK_DRAW_BUFFERS SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
     39  0800
     40  0800							; NOTE: Access to these buffers must NOT overlap pages...
     41  0800							; NOTE: We get auto-initialisation of these variables from the ROM values by
     42  0800							; copying the whole bank into the RAM bank.  Neato.
     43  0800
     44  0800		       00 50	   DRAW_STACK_SIZE =	SCREEN_ARRAY_SIZE	; <-- TJ TRY CHANGING THIS TO (SAY) 15  (!!)
     45  0800
     46  0800
     47  0800
     48  0800		       00 00 00 00*DrawStack  ds	DRAW_STACK_SIZE,0	; a stack of character #'s to draw
     49  0850		       00 00 00 00*DrawFlag   ds	SCREEN_ARRAY_SIZE,0	; holds new character to draw at position
     50  08a0
      0  08a0					      OPTIONAL_PAGEBREAK	"ScreenBuffer", SCREEN_ARRAY_SIZE
     10  08a0					      LIST	ON
     52  08a0
     53  08a0							; D7 of ScreenBuffer indicates if a DirectDraw is to be used to draw this character
     54  08a0							; Note: this may actually cause two characters to be drawn -- for the price of one.  This is *exactly*
     55  08a0							; what we want to happen!
     56  08a0
     57  08a0		       00 00 00 00*ScreenBuffer ds	SCREEN_ARRAY_SIZE,0	; the char buffer for delta-drawing
      0  08f0					      CHECKPAGEX	ScreenBuffer, "ScreenBuffer"
      9  08f0					      LIST	ON
     59  08f0
     60  08f0							;------------------------------------------------------------------------------
     61  08f0							; RAM-BASED SUBROUTINES...
     62  08f0							; NOTE: When calling these routines, remember you are actually calling the ROM routine
     63  08f0							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
     64  08f0							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
     65  08f0							; the RAM-based routine.
     66  08f0
     67  08f0
     68  08f0
     69  08f0							;------------------------------------------------------------------------------
     70  08f0
     71  08f0
     72  08f0		       60	   waitForDraw rts		; 6
     73  08f1
     74  08f1							;------------------------------------------------------------------------------
     75  08f1
      0  08f1					      DEFINE_SUBROUTINE	DrawStackUpdate	; @39✅
      1  08f1		       00 01	   BANK_DrawStackUpdate =	_CURRENT_BANK
      2  08f1					      SUBROUTINE
      3  08f1				   DrawStackUpdate
     77  08f1
     78  08f1							; Parse the DrawFlags buffer and create a draw stack
     79  08f1							; so that the actual draw doesn't need to scan for characters to draw.
     80  08f1
     81  08f1
     82  08f1							;@TJ -- let's see if we see any bad lag/shear in screen drawing without this wait in.
     83  08f1							; symptoms would be missing parts of screen when scrolling.
     84  08f1							; Gameplay (not visual) lag noticed - re-enabled 11/8/11
     85  08f1							; disabled for sokoban 27/7/2019
     86  08f1
     87  08f1							;lda DrawStackPointer
     88  08f1							;bpl waitForDraw		  ; Wait for previously not-drawn characters to be drawn
     89  08f1
     90  08f1		       ad 84 02 	      lda	INTIM	;4
     91  08f4		       c9 03		      cmp	#SEGTIME_BDS	;2
     92  08f6		       90 f8		      bcc	waitForDraw	;2/3
     93  08f8							; =>[39]+(9)+6rts = 54✅ when exit
     94  08f8
     95  08f8							; Now that all characters are drawn, recalculate/move sprite. Doing this here prevents the player
     96  08f8							; moving into the middle of dirt, or BOXs when pushing, or TARGETs when grabbing.
     97  08f8
     98  08f8							;		  sec		 already set
     99  08f8		       a5 9e		      lda	ManY	;3
    100  08fa		       e5 96		      sbc	BoardScrollY	;3
    101  08fc		       c9 08		      cmp	#SCREEN_LINES
    102  08fe		       b0 0b		      bcs	offy
    103  0900		       85 a0		      sta	ManDrawY	;3 = 9✅
    104  0902
    105  0902		       38		      sec		;2
    106  0903		       a5 9d		      lda	ManX	;3
    107  0905		       e5 97		      sbc	BoardScrollX	;3
    108  0907		       c9 0a		      cmp	#SCREEN_WIDTH	;2
    109  0909		       90 06		      bcc	onsc	;2/3 = 12(13)✅
    110  090b
    111  090b							; if the man is offscreen, we have a timing issue between the horizontal positioning code and the player
    112  090b							; draw code.  The following gets around this by setting the Y offscreen (causing the player draw code to
    113  090b							; blank the graphic) and leaving the X alone (so we don't see a brief flash in left of screen).
    114  090b
    115  090b		       a9 ff	   offy       lda	#-1	;SCREEN_LINES		     ;2
    116  090d		       85 a0		      sta	ManDrawY	;3
    117  090f		       d0 02		      bne	offsc
    118  0911
    119  0911		       85 9f	   onsc       sta	ManDrawX	;3
    120  0913				   offsc
    121  0913
    122  0913							;32✅ worst
    123  0913
      0  0913					      DEFINE_SUBROUTINE	AnimateCharReplacements2	; =38
      1  0913		       00 01	   BANK_AnimateCharReplacements2 =	_CURRENT_BANK
      2  0913					      SUBROUTINE
      3  0913				   AnimateCharReplacements2
    125  0913
    126  0913							; This manages character animation on a per-object basis.  Morph/animate these characters
    127  0913							; individually or as required.  Change will affect all characters of the same type in the
    128  0913							; visible display.
    129  0913
    130  0913		       e6 c5		      inc	animate_char_index	; 5
    131  0915		       a5 c5		      lda	animate_char_index	; 3
    132  0917		       4a		      lsr		; 2
    133  0918		       4a		      lsr
    134  0919		       29 03		      and	#3	; 2
    135  091b		       aa		      tax		; 2 = 14
    136  091c
    137  091c		       bd ec f1 	      lda	targetReplaceChar,x	; 4
    138  091f		       8d df f5 	      sta	ANIM_TARGET + RAM_WRITE	; 4 = 8
    139  0922							;lda targetReplaceChar2,x	      ; 4
    140  0922							;sta ANIM_TARGET2 + RAM_WRITE	      ; 4
    141  0922
    142  0922							;@54 worst
    143  0922
    144  0922		       a9 4f		      lda	#SCREEN_ARRAY_SIZE-1	;2
    145  0924		       85 c3		      sta	DSL	;3
    146  0926
    147  0926		       e6 86		      inc	ScreenDrawPhase	;5
    148  0928		       60		      rts		; 6 TEST allows segtime test to be smaller on next part
    149  0929							; ==> @70 worst
    150  0929
    151  0929							;---------------------------------------------------------------------------
    152  0929
      0  0929					      DEFINE_SUBROUTINE	DrawIntoStack	; @39✅
      1  0929		       00 01	   BANK_DrawIntoStack =	_CURRENT_BANK
      2  0929					      SUBROUTINE
      3  0929				   DrawIntoStack
    154  0929
    155  0929		       ba		      tsx		; 2
    156  092a		       86 db		      stx	save_SP	; 3
    157  092c		       a6 81		      ldx	DrawStackPointer	; 3
    158  092e		       9a		      txs		; 2 = 10
    159  092f
    160  092f		       a4 c3		      ldy	DSL	; 3
    161  0931
    162  0931							; @ 52✅
    163  0931
    164  0931							; worst-case DrawStackOne loop = 61 cycles per character (+11 for first one)
    165  0931							; + exit cost which is +10 cycles
    166  0931							; TJ: I count 63
    167  0931							;   + 14 for the wtf2 exit
    168  0931							;   + 22 for the end of loop exit
    169  0931
    170  0931							; This loops 80 times/frame and is called 1-2 times/frame, so any saving inside the loop will make up for a lot of overhead outside
    171  0931							; For 80 iterations that is 640 cycles, just for checking INTIM
    172  0931							; Worst case we would have ~5000. Though that will most likely never happen, we have to optimize for it, since
    173  0931							; it also will require a lot of CPU time for updating the screen data.
    174  0931
    175  0931							; TODO: optimize!
    176  0931							;
    177  0931							; idea #4: the mixed draw idea (two different characters have to be redrawn),
    178  0931							; first do a QuickDraw and then a SlowDraw, faster than two SlowDraws
    179  0931							; costs some detection time here, but saves ~240 cylces for drawing the two
    180  0931
    181  0931				   .loopDrawStack		; @100✅ from bottom of loop
    182  0931
    183  0931		       ad 84 02 	      lda	INTIM	; 4
    184  0934		       c9 04		      cmp	#SEGTIME_DSL	; 2
    185  0936		       90 4b		      bcc	.exitDrawStack	; 2(3)  + [costs 18 more to exit fully at .exit..]
    186  0938							; => full exit on 1st pass = 78✅ cycles
    187  0938							; => full exit on a single loop = 127✅ cycles
    188  0938
    189  0938							; @0✅
    190  0938
    191  0938		       b9 50 f0 	      lda	DrawFlag,y	; 4
    192  093b		       d9 a0 f0 	      cmp	ScreenBuffer,y	; 4		  Is the character already there the same as the new one?
    193  093e		       f0 16		      beq	.next0	; 2/3=10/11	  yes, so we don't draw anything
    194  0940							; @10✅
    195  0940
    196  0940							; Character is NOT the same. Figure out how it should be drawn.
    197  0940							; If it is in column 0 or 5 then it can be DirectDrawn (indirectly found by a A:A compare)
    198  0940							; If it is the same as its paired character (sharing same PF byte) then it can be DirectDrawn
    199  0940							; The top bit of the ScreenBuffer character indicates the DirectDrawn hint
    200  0940
    201  0940		       be 8c f1 	      ldx	PairedCharacter,y	; 4		  the "paired" character for this one
    202  0943		       dd 50 f0 	      cmp	DrawFlag,x	; 4		  same as partner character in new drawn screen?
    203  0946		       d0 05		      bne	.notPaired0	; 2(3)
    204  0948							; @20✅
    205  0948
    206  0948							; Consider two 'paired' characters. Either A:A or A:B
    207  0948							; When we're scanning, and we check the first, if they are NOT paired, then the second character
    208  0948							; can be considered in isolation -- its check comes later, will determine itself if the pair can be written
    209  0948							; If, however, the first character IS paired, then the write below will cause the second check to FAIL
    210  0948							; on the comparison, so the character will not be added to the draw stack. So our first character will
    211  0948							; do the job of drawing BOTH characters to the screen.
    212  0948
    213  0948		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 5		  mark paired character as drawn already (!!)
    214  094b		       09 80		      ora	#$80	; 2 =	7	  DirectDraw this character 'pair'
    215  094d							; @27✅
    216  094d							; In the case of columns 0 and 5, the X and Y registers will be the same -- no problemo, because
    217  094d							; the last write(below) marks the character as to be direct-drawn.
    218  094d
    219  094d				   .notPaired0		; @27✅ worst
    220  094d
    221  094d		       99 a0 f4 	      sta	ScreenBuffer+RAM_WRITE,y	; 5		  NEW character to draw + DirectDraw flag (128)
    222  0950
    223  0950							; The following 'pla' really just increments the draw-stack pointer.  Value is unimportant. Unusual!
    224  0950
    225  0950		       68		      pla		; 4		  ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    226  0951		       98		      tya		; 2
    227  0952		       ba		      tsx		; 2		  << now X holds drawstackpointer
    228  0953		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	; 5 = 18	  index of character to draw
    229  0956
    230  0956		       88	   .next0     dey		; 2
    231  0957		       30 21		      bmi	.finishedDrawStack	; 2(3)= 4/5
    232  0959							; @50✅
    233  0959							; unrolled 2nd loop:
    234  0959		       b9 50 f0 	      lda	DrawFlag,y	; 4
    235  095c		       d9 a0 f0 	      cmp	ScreenBuffer,y	; 4		  Is the character already there the same as the new one?
    236  095f		       f0 16		      beq	.next1	; 2(3) 	  yes, so we don't draw anything
    237  0961
    238  0961		       be 8c f1 	      ldx	PairedCharacter,y	; 4		  the "paired" character for this one
    239  0964		       dd 50 f0 	      cmp	DrawFlag,x	; 4		  same as partner character in new drawn screen?
    240  0967		       d0 05		      bne	.notPaired1	; 2(3)
    241  0969
    242  0969		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 5		  mark paired character as drawn already (!!)
    243  096c		       09 80		      ora	#$80	; 2 =	7	  DirectDraw this character 'pair'
    244  096e
    245  096e				   .notPaired1		; @77✅ worst
    246  096e
    247  096e		       99 a0 f4 	      sta	ScreenBuffer+RAM_WRITE,y	; 5		  NEW character to draw + DirectDraw flag (128)
    248  0971
    249  0971		       68		      pla		; 4		  ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    250  0972		       98		      tya		; 2
    251  0973		       ba		      tsx		; 2
    252  0974		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	; 5 = 18	  index of character to draw
    253  0977							; @95✅
    254  0977
    255  0977		       88	   .next1     dey		; 2
    256  0978		       10 b7		      bpl	.loopDrawStack	; 2(3)
    257  097a							; @100✅ --> @.loopDrawStack
    258  097a
    259  097a							;worst case: 111-4
    260  097a							;40 loops(-4), max. 2 calls(+20) -> -160+40=-120, +8 bytes
    261  097a
    262  097a							; THE FOLLOWING OPTIMISATION IS STUFFED IF PROCESSOBJSTACK is not first in the vector processor!
    263  097a
    264  097a				   .finishedDrawStack
    265  097a		       e6 86		      inc	ScreenDrawPhase	;5 =  5
    266  097c		       ba		      tsx		;2
    267  097d		       86 81		      stx	DrawStackPointer	;3
    268  097f
    269  097f		       a6 db		      ldx	save_SP	;3
    270  0981		       9a		      txs		;2 = 10
    271  0982		       60		      rts		;6 =  6
    272  0983
    273  0983				   .exitDrawStack
    274  0983		       84 c3		      sty	DSL	;3 =  3
    275  0985		       ba		      tsx		;2
    276  0986		       86 81		      stx	DrawStackPointer	;3
    277  0988		       a6 db		      ldx	save_SP	;3
    278  098a		       9a		      txs		;2 = 10
    279  098b		       60		      rts		;6 =  6
    280  098c
    281  098c				   PairedCharacter
    282  098c
    283  098c				   SOFF       SET	0
    284  098c					      REPEAT	SCREEN_LINES
    285  098c		       00 02 01 04*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    286  098c				   SOFF       SET	SOFF + SCREEN_WIDTH
    284  098c					      REPEND
    285  0996		       0a 0c 0b 0e*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    286  0996				   SOFF       SET	SOFF + SCREEN_WIDTH
    284  0996					      REPEND
    285  09a0		       14 16 15 18*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    286  09a0				   SOFF       SET	SOFF + SCREEN_WIDTH
    284  09a0					      REPEND
    285  09aa		       1e 20 1f 22*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    286  09aa				   SOFF       SET	SOFF + SCREEN_WIDTH
    284  09aa					      REPEND
    285  09b4		       28 2a 29 2c*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    286  09b4				   SOFF       SET	SOFF + SCREEN_WIDTH
    284  09b4					      REPEND
    285  09be		       32 34 33 36*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    286  09be				   SOFF       SET	SOFF + SCREEN_WIDTH
    284  09be					      REPEND
    285  09c8		       3c 3e 3d 40*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    286  09c8				   SOFF       SET	SOFF + SCREEN_WIDTH
    284  09c8					      REPEND
    285  09d2		       46 48 47 4a*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    286  09d2				   SOFF       SET	SOFF + SCREEN_WIDTH
    287  09dc					      REPEND
    288  09dc
    289  09dc							;------------------------------------------------------------------------------
    290  09dc							; Gives character replacements used during screen drawing.
    291  09dc							; The character from the board is morphed via this array into an actual character
    292  09dc							; to draw.  This allows global animation and replacment of characters without
    293  09dc							; individual objects needing to do this.  Note, the draw-time replacement happens,
    294  09dc							; not board-time.
    295  09dc
      0  09dc					      DEFINE_SUBROUTINE	CharReplacement	; in RAM -- BANK_DRAW_BUFFERS
      1  09dc		       00 01	   BANK_CharReplacement =	_CURRENT_BANK
      2  09dc					      SUBROUTINE
      3  09dc				   CharReplacement
    297  09dc
    298  09dc							; Converts a character # to an animated creature type
    299  09dc							; The array is indexed by CHARACTER_...
    300  09dc
    301  09dc		       00		      .byte.b	CHARACTER_BLANK	;  0
    302  09dd		       01		      .byte.b	CHARACTER_SOIL	;  1
    303  09de		       02		      .byte.b	CHARACTER_BOX	;  2
    304  09df		       03	   ANIM_TARGET .byte.b	CHARACTER_TARGET	;  3  XOR'd to give flashing target squares
    305  09e0		       04		      .byte.b	CHARACTER_TARGET2	;  4
    306  09e1		       05		      .byte.b	CHARACTER_MANOCCUPIED	;  5
    307  09e2		       06		      .byte.b	CHARACTER_STEEL	;  6
    308  09e3		       07		      .byte.b	CHARACTER_RIVET	;  7
    309  09e4		       08		      .byte.b	CHARACTER_WALL	;  8
    310  09e5		       09		      .byte.b	CHARACTER_STRIPE
    311  09e6		       0a	   ANIM_TARGET2 .byte.b	CHARACTER_BOX_ON_TARGET	;  8	 box on target
    312  09e7							;		  .byte CHARACTER_BOX_ON_TARGET2
    313  09e7		       00		      .byte.b	CHARACTER_BLANK	;  9
    314  09e8		       0c		      .byte.b	CHARACTER_TARGET1
    315  09e9		       0d		      .byte.b	CHARACTER_TARGET3
    316  09ea		       0e		      .byte.b	CHARACTER_TARGET5
    317  09eb		       0f		      .byte.b	CHARACTER_TARGET7
    318  09ec
    319  09ec				  -	      if	DIGITS
    320  09ec				  -	      .byte	CHARACTER_0
    321  09ec				  -	      .byte	CHARACTER_1
    322  09ec				  -	      .byte	CHARACTER_2
    323  09ec				  -	      .byte	CHARACTER_3
    324  09ec				  -	      .byte	CHARACTER_4
    325  09ec				  -	      .byte	CHARACTER_5
    326  09ec				  -	      .byte	CHARACTER_6
    327  09ec				  -	      .byte	CHARACTER_7
    328  09ec				  -	      .byte	CHARACTER_8
    329  09ec				  -	      .byte	CHARACTER_9
    330  09ec					      endif
    331  09ec
    332  09ec				  -	      IF	(* - CharReplacement != CHARACTER_MAXIMUM)
    333  09ec				  -	      ECHO	"ERROR: Incorrect CharReplacement table!"
    334  09ec				  -	      ERR
    335  09ec					      ENDIF
      0  09ec					      CHECKPAGEX	CharReplacement, "CharReplacement in BANK_ROM_SHADOW_DRAWBUFFERS"
      9  09ec					      LIST	ON
    337  09ec
    338  09ec
    339  09ec
    340  09ec				   targetReplaceChar
    341  09ec		       0c		      .byte.b	CHARACTER_TARGET1
    342  09ed		       0d		      .byte.b	CHARACTER_TARGET3
    343  09ee		       0e		      .byte.b	CHARACTER_TARGET5
    344  09ef		       0f		      .byte.b	CHARACTER_TARGET7
    345  09f0
    346  09f0							;targetReplaceChar2
    347  09f0							;    .byte CHARACTER_BOX
    348  09f0							;    .byte CHARACTER_BOX
    349  09f0							;    .byte CHARACTER_BOX_ON_TARGET
    350  09f0							;    .byte CHARACTER_BOX_ON_TARGET
    351  09f0
    352  09f0							;------------------------------------------------------------------------------
    353  09f0
    354  09f0
      0  09f0					      OPTIONAL_PAGEBREAK	"ROW_BankChar", SCREEN_LINES * SCREEN_WIDTH
 PAGE BREAK INSERTED FOR  ROW_BankChar
 REQUESTED SIZE =  $50
 WASTED SPACE =  $10
 PAGEBREAK LOCATION =  $f200
     10  0a00					      LIST	ON
      0  0a00					      DEFINE_SUBROUTINE	ROW_BankChar
      1  0a00		       00 01	   BANK_ROW_BankChar =	_CURRENT_BANK
      2  0a00					      SUBROUTINE
      3  0a00				   ROW_BankChar
    357  0a00
    358  0a00				   .BANK      SET	BANK_SCREENMARKII1
    359  0a00					      REPEAT	SCREEN_LINES
    360  0a00					      REPEAT	SCREEN_WIDTH
    361  0a00		       00		      .byte.b	.BANK
    360  0a00					      REPEND
    361  0a01		       00		      .byte.b	.BANK
    360  0a01					      REPEND
    361  0a02		       00		      .byte.b	.BANK
    360  0a02					      REPEND
    361  0a03		       00		      .byte.b	.BANK
    360  0a03					      REPEND
    361  0a04		       00		      .byte.b	.BANK
    360  0a04					      REPEND
    361  0a05		       00		      .byte.b	.BANK
    360  0a05					      REPEND
    361  0a06		       00		      .byte.b	.BANK
    360  0a06					      REPEND
    361  0a07		       00		      .byte.b	.BANK
    360  0a07					      REPEND
    361  0a08		       00		      .byte.b	.BANK
    360  0a08					      REPEND
    361  0a09		       00		      .byte.b	.BANK
    362  0a0a					      REPEND
    363  0a0a				   .BANK      SET	.BANK + 1
    359  0a0a					      REPEND
    360  0a0a					      REPEAT	SCREEN_WIDTH
    361  0a0a		       01		      .byte.b	.BANK
    360  0a0a					      REPEND
    361  0a0b		       01		      .byte.b	.BANK
    360  0a0b					      REPEND
    361  0a0c		       01		      .byte.b	.BANK
    360  0a0c					      REPEND
    361  0a0d		       01		      .byte.b	.BANK
    360  0a0d					      REPEND
    361  0a0e		       01		      .byte.b	.BANK
    360  0a0e					      REPEND
    361  0a0f		       01		      .byte.b	.BANK
    360  0a0f					      REPEND
    361  0a10		       01		      .byte.b	.BANK
    360  0a10					      REPEND
    361  0a11		       01		      .byte.b	.BANK
    360  0a11					      REPEND
    361  0a12		       01		      .byte.b	.BANK
    360  0a12					      REPEND
    361  0a13		       01		      .byte.b	.BANK
    362  0a14					      REPEND
    363  0a14				   .BANK      SET	.BANK + 1
    359  0a14					      REPEND
    360  0a14					      REPEAT	SCREEN_WIDTH
    361  0a14		       02		      .byte.b	.BANK
    360  0a14					      REPEND
    361  0a15		       02		      .byte.b	.BANK
    360  0a15					      REPEND
    361  0a16		       02		      .byte.b	.BANK
    360  0a16					      REPEND
    361  0a17		       02		      .byte.b	.BANK
    360  0a17					      REPEND
    361  0a18		       02		      .byte.b	.BANK
    360  0a18					      REPEND
    361  0a19		       02		      .byte.b	.BANK
    360  0a19					      REPEND
    361  0a1a		       02		      .byte.b	.BANK
    360  0a1a					      REPEND
    361  0a1b		       02		      .byte.b	.BANK
    360  0a1b					      REPEND
    361  0a1c		       02		      .byte.b	.BANK
    360  0a1c					      REPEND
    361  0a1d		       02		      .byte.b	.BANK
    362  0a1e					      REPEND
    363  0a1e				   .BANK      SET	.BANK + 1
    359  0a1e					      REPEND
    360  0a1e					      REPEAT	SCREEN_WIDTH
    361  0a1e		       03		      .byte.b	.BANK
    360  0a1e					      REPEND
    361  0a1f		       03		      .byte.b	.BANK
    360  0a1f					      REPEND
    361  0a20		       03		      .byte.b	.BANK
    360  0a20					      REPEND
    361  0a21		       03		      .byte.b	.BANK
    360  0a21					      REPEND
    361  0a22		       03		      .byte.b	.BANK
    360  0a22					      REPEND
    361  0a23		       03		      .byte.b	.BANK
    360  0a23					      REPEND
    361  0a24		       03		      .byte.b	.BANK
    360  0a24					      REPEND
    361  0a25		       03		      .byte.b	.BANK
    360  0a25					      REPEND
    361  0a26		       03		      .byte.b	.BANK
    360  0a26					      REPEND
    361  0a27		       03		      .byte.b	.BANK
    362  0a28					      REPEND
    363  0a28				   .BANK      SET	.BANK + 1
    359  0a28					      REPEND
    360  0a28					      REPEAT	SCREEN_WIDTH
    361  0a28		       04		      .byte.b	.BANK
    360  0a28					      REPEND
    361  0a29		       04		      .byte.b	.BANK
    360  0a29					      REPEND
    361  0a2a		       04		      .byte.b	.BANK
    360  0a2a					      REPEND
    361  0a2b		       04		      .byte.b	.BANK
    360  0a2b					      REPEND
    361  0a2c		       04		      .byte.b	.BANK
    360  0a2c					      REPEND
    361  0a2d		       04		      .byte.b	.BANK
    360  0a2d					      REPEND
    361  0a2e		       04		      .byte.b	.BANK
    360  0a2e					      REPEND
    361  0a2f		       04		      .byte.b	.BANK
    360  0a2f					      REPEND
    361  0a30		       04		      .byte.b	.BANK
    360  0a30					      REPEND
    361  0a31		       04		      .byte.b	.BANK
    362  0a32					      REPEND
    363  0a32				   .BANK      SET	.BANK + 1
    359  0a32					      REPEND
    360  0a32					      REPEAT	SCREEN_WIDTH
    361  0a32		       05		      .byte.b	.BANK
    360  0a32					      REPEND
    361  0a33		       05		      .byte.b	.BANK
    360  0a33					      REPEND
    361  0a34		       05		      .byte.b	.BANK
    360  0a34					      REPEND
    361  0a35		       05		      .byte.b	.BANK
    360  0a35					      REPEND
    361  0a36		       05		      .byte.b	.BANK
    360  0a36					      REPEND
    361  0a37		       05		      .byte.b	.BANK
    360  0a37					      REPEND
    361  0a38		       05		      .byte.b	.BANK
    360  0a38					      REPEND
    361  0a39		       05		      .byte.b	.BANK
    360  0a39					      REPEND
    361  0a3a		       05		      .byte.b	.BANK
    360  0a3a					      REPEND
    361  0a3b		       05		      .byte.b	.BANK
    362  0a3c					      REPEND
    363  0a3c				   .BANK      SET	.BANK + 1
    359  0a3c					      REPEND
    360  0a3c					      REPEAT	SCREEN_WIDTH
    361  0a3c		       06		      .byte.b	.BANK
    360  0a3c					      REPEND
    361  0a3d		       06		      .byte.b	.BANK
    360  0a3d					      REPEND
    361  0a3e		       06		      .byte.b	.BANK
    360  0a3e					      REPEND
    361  0a3f		       06		      .byte.b	.BANK
    360  0a3f					      REPEND
    361  0a40		       06		      .byte.b	.BANK
    360  0a40					      REPEND
    361  0a41		       06		      .byte.b	.BANK
    360  0a41					      REPEND
    361  0a42		       06		      .byte.b	.BANK
    360  0a42					      REPEND
    361  0a43		       06		      .byte.b	.BANK
    360  0a43					      REPEND
    361  0a44		       06		      .byte.b	.BANK
    360  0a44					      REPEND
    361  0a45		       06		      .byte.b	.BANK
    362  0a46					      REPEND
    363  0a46				   .BANK      SET	.BANK + 1
    359  0a46					      REPEND
    360  0a46					      REPEAT	SCREEN_WIDTH
    361  0a46		       07		      .byte.b	.BANK
    360  0a46					      REPEND
    361  0a47		       07		      .byte.b	.BANK
    360  0a47					      REPEND
    361  0a48		       07		      .byte.b	.BANK
    360  0a48					      REPEND
    361  0a49		       07		      .byte.b	.BANK
    360  0a49					      REPEND
    361  0a4a		       07		      .byte.b	.BANK
    360  0a4a					      REPEND
    361  0a4b		       07		      .byte.b	.BANK
    360  0a4b					      REPEND
    361  0a4c		       07		      .byte.b	.BANK
    360  0a4c					      REPEND
    361  0a4d		       07		      .byte.b	.BANK
    360  0a4d					      REPEND
    361  0a4e		       07		      .byte.b	.BANK
    360  0a4e					      REPEND
    361  0a4f		       07		      .byte.b	.BANK
    362  0a50					      REPEND
    363  0a50				   .BANK      SET	.BANK + 1
    364  0a50					      REPEND
    365  0a50
      0  0a50					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS"
      1  0a50
      2  0a50
      3  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS (1K) SIZE =  $250 , FREE= $1b0
      4  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0a50				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0a50				  -	      ERR
      8  0a50					      endif
    367  0a50
    368  0a50
      0  0a50					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K"
      1  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K (2K) SIZE =  $250 , FREE= $5b0
      2  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0a50				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0a50				  -	      ERR
      6  0a50					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_SCORING.asm LEVEL 2 PASS 3
      0  0a50					      include	"BANK_ROM_SHADOW_SCORING.asm"
      1  0a50							;    Sokoboo - a Sokoban implementation
      2  0a50							;    using a generic tile-based display engine for the Atari 2600
      3  0a50							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0a50							;
      5  0a50							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0a50							;
      7  0a50							;    Code related to the generic tile-based display engine was developed by
      8  0a50							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0a50							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0a50							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0a50							;
     12  0a50							;    Code related to music and sound effects uses the TIATracker music player
     13  0a50							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0a50							;    directory for Apache licensing details.
     15  0a50							;
     16  0a50							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0a50							;    See the copyright notices in the License directory for a list of level
     18  0a50							;    contributors.
     19  0a50							;
     20  0a50							;    Except where otherwise indicated, this software is released under the
     21  0a50							;    following licensing arrangement...
     22  0a50							;
     23  0a50							;    This program is free software: you can redistribute it and/or modify
     24  0a50							;    it under the terms of the GNU General Public License as published by
     25  0a50							;    the Free Software Foundation, either version 3 of the License, or
     26  0a50							;    (at your option) any later version.
     27  0a50							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0a50
     29  0a50							;    This program is distributed in the hope that it will be useful,
     30  0a50							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0a50							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0a50							;    GNU General Public License for more details.
     33  0a50
     34  0a50							;------------------------------------------------------------------------------
     35  0a50							;##############################################################################
     36  0a50							;------------------------------------------------------------------------------
      0  0a50					      NEWBANK	ROM_SHADOW_OF_BANK_SCORING
      1  13c0 ????				      SEG	ROM_SHADOW_OF_BANK_SCORING
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   ROM_SHADOW_OF_BANK_SCORING SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_SCORING
     38  1000
     39  1000
     40  1000		       00 9a	   SCORE_COL  =	$9a	;WHITE ;-2
     41  1000		       00 44	   SCORE_COL_HIGH_NTSC =	$44	; works for SECAM and NTSC
     42  1000		       00 66	   SCORE_COL_HIGH_PAL =	$66
     43  1000
     44  1000
     45  1000				   DigitVectorLOr
     46  1000		       31 3f 4d 38*	      .byte.b	<ZeroR-1, <OneR-1, <TwoR-1, <ThreeR-1, <FourR-1, <FiveR-1, <SixR-1, <SevenR-1, <EightR-1, <NineR-1
     47  100a		       00 07 0e 15	      .byte.b	<BLANKR-1, <DequalsR-1, <DplusR-1, <ClockR-1
     48  100e				   DigitVectorLO
     49  100e		       53 61 6e 5a*	      .byte.b	<ZeroL-1, <OneL-1, <TwoL-1, <ThreeL-1, <FourL-1, <FiveL-1, <SixL-1, <SevenL-1, <EightL-1, <NineL-1
     50  1018		       37		      .byte.b	<BLANKL-1
     51  1019
     52  1019
     53  1019		       00 0a	   ID_BLANK   =	10	; DO NOT MAKE 0
     54  1019		       00 0b	   ID_TARGET  =	11
     55  1019		       00 0c	   ID_EXTRA   =	12
     56  1019		       00 0d	   ID_CLOCK   =	13
     57  1019		       00 1b	   ID_HEAD    =	ID_BLANK+16+1
     58  1019
     59  1019							; score patch adresses:
     60  1019				   SMTblLSB
     61  1019				   SMTblTargets
     62  1019		       52 48		      .byte.b	SM_TARGET0+1-SM_BASE, SM_TARGET2+1-SM_BASE
     63  101b				   SMTblTime
     64  101b		       6e 60		      .byte.b	SM_Time0+1-SM_BASE, SM_Time2+1-SM_BASE
     65  101d				   SMTblScore
     66  101d		       1c 20 12 	      .byte.b	SMDIGIT5+1-SM_BASE, SMDIGIT3+1-SM_BASE, SMDIGIT1+1-SM_BASE
     67  1020				   SMTblMSB
     68  1020		       4d 43		      .byte.b	SM_TARGET1+1-SM_BASE, SM_TARGET3+1-SM_BASE
     69  1022		       65 59		      .byte.b	SM_Time1+1-SM_BASE, SM_Time3+1-SM_BASE
     70  1024		       23 17 07 	      .byte.b	SMDIGIT4+1-SM_BASE, SMDIGIT2+1-SM_BASE, SMDIGIT0+1-SM_BASE
     71  1027
     72  1027		       00 00	   SM_OFS_TARGETS =	SMTblTargets - SMTblLSB
     73  1027		       00 02	   SM_OFS_TIME =	SMTblTime - SMTblLSB
     74  1027		       00 04	   SM_OFS_SCORE =	SMTblScore - SMTblLSB
     75  1027
     76  1027				   CharVectorLO
     77  1027		       37		      .byte.b	<BLANKL-1
     78  1028		       c2 c2 c2 c2	      .byte.b	<CharA-1, <CharB-1, <CharC-1, <CharD-1
     79  102c		       c2 c2 c2 c2	      .byte.b	<CharE-1, <CharF-1, <CharG-1, <CharH-1
     80  1030		       c2 c2 b4 ad	      .byte.b	<CharI-1, <CharJ-1, <CharK-1, <CharL-1
     81  1034		       c2 c2 bb c2	      .byte.b	<CharM-1, <CharN-1, <CharO-1, <CharP-1
     82  1038							;    .byte   <OneL-1,	<TwoL-1,  <ThreeL-1,<FourL-1
     83  1038
     84  1038							; Digit shape definitions are at start of bank so that we don't have page boundary
     85  1038							; crossing issues.
     86  1038
     87  1038							;	  .byte 0	      ; required!
     88  1038
     89  1038		       00 07	   DIGIT_H    =	7	; height of a score digit
     90  1038
     91  1038		       00 00 00 00*BLANKL     ds	7,0
     92  103f
     93  103f
     94  103f
     95  103f				   NineL
     96  103f		       1e		      .byte.b	%00011110
     97  1040		       02		      .byte.b	%00000010
     98  1041		       02		      .byte.b	%00000010
     99  1042		       fe		      .byte.b	%11111110
    100  1043		       82		      .byte.b	%10000010
    101  1044		       82		      .byte.b	%10000010
    102  1045		       fe		      .byte.b	%11111110
    103  1046
    104  1046				   SixL
    105  1046		       fe		      .byte.b	%11111110
    106  1047		       82		      .byte.b	%10000010
    107  1048		       82		      .byte.b	%10000010
    108  1049		       fe		      .byte.b	%11111110
    109  104a		       80		      .byte.b	%10000000
    110  104b		       80		      .byte.b	%10000000
    111  104c		       f0		      .byte.b	%11110000
    112  104d
    113  104d							;    .byte %01111100
    114  104d							;    .byte %11000010
    115  104d							;    .byte %11000010
    116  104d							;    .byte %11111100
    117  104d							;    .byte %11000000
    118  104d							;    .byte %01100000
    119  104d							;    .byte %00111000
    120  104d				   EightL
    121  104d
    122  104d
    123  104d		       fe		      .byte.b	%11111110
    124  104e		       82		      .byte.b	%10000010
    125  104f		       82		      .byte.b	%10000010
    126  1050		       fe		      .byte.b	%11111110
    127  1051		       82		      .byte.b	%10000010
    128  1052		       82		      .byte.b	%10000010
    129  1053		       fe		      .byte.b	%11111110
    130  1054
    131  1054							;  .byte %01111100
    132  1054							;  .byte %10000110
    133  1054							;  .byte %10000110
    134  1054							;  .byte %01111100
    135  1054							;  .byte %01000110
    136  1054							;  .byte %01000110
    137  1054							;  .byte %00111100
    138  1054				   ZeroL
    139  1054							;  .byte %01111100
    140  1054							;  .byte %10000110
    141  1054							;  .byte %10000110
    142  1054							;  .byte %10000110
    143  1054							;  .byte %10000110
    144  1054							;  .byte %01000110
    145  1054							;  .byte %00111100
    146  1054
    147  1054		       fe		      .byte.b	%11111110
    148  1055		       82		      .byte.b	%10000010
    149  1056		       82		      .byte.b	%10000010
    150  1057		       82		      .byte.b	%10000010
    151  1058		       82		      .byte.b	%10000010
    152  1059		       82		      .byte.b	%10000010
    153  105a		       fe		      .byte.b	%11111110
    154  105b
    155  105b				   ThreeL
    156  105b		       fe		      .byte.b	%11111110
    157  105c		       02		      .byte.b	%00000010
    158  105d		       02		      .byte.b	%00000010
    159  105e		       1e		      .byte.b	%00011110
    160  105f		       02		      .byte.b	%00000010
    161  1060		       02		      .byte.b	%00000010
    162  1061		       fe		      .byte.b	%11111110
    163  1062				   OneL
    164  1062		       10		      .byte.b	%00010000
    165  1063		       10		      .byte.b	%00010000
    166  1064		       10		      .byte.b	%00010000
    167  1065		       10		      .byte.b	%00010000
    168  1066		       10		      .byte.b	%00010000
    169  1067		       10		      .byte.b	%00010000
    170  1068		       10		      .byte.b	%00010000
    171  1069
    172  1069				   SevenL
    173  1069
    174  1069		       10		      .byte.b	%00010000
    175  106a		       10		      .byte.b	%00010000
    176  106b		       10		      .byte.b	%00010000
    177  106c		       1e		      .byte.b	%00011110
    178  106d		       02		      .byte.b	%00000010
    179  106e		       02		      .byte.b	%00000010
    180  106f							;  .byte %11111110
    181  106f
    182  106f							;    .byte %00010000
    183  106f							;    .byte %00010000
    184  106f							;    .byte %00010000
    185  106f							;    .byte %00011000
    186  106f							;    .byte %00001100
    187  106f							;    .byte %10000110
    188  106f							;    ;.byte %11111110
    189  106f				   TwoL
    190  106f		       fe		      .byte.b	%11111110
    191  1070		       80		      .byte.b	%10000000
    192  1071		       80		      .byte.b	%10000000
    193  1072		       fe		      .byte.b	%11111110
    194  1073		       02		      .byte.b	%00000010
    195  1074		       02		      .byte.b	%00000010
    196  1075		       fe		      .byte.b	%11111110
    197  1076
    198  1076				   FiveL
    199  1076		       fe		      .byte.b	%11111110
    200  1077		       02		      .byte.b	%00000010
    201  1078		       02		      .byte.b	%00000010
    202  1079		       fe		      .byte.b	%11111110
    203  107a		       80		      .byte.b	%10000000
    204  107b		       80		      .byte.b	%10000000
    205  107c		       f0		      .byte.b	%11110000
    206  107d
    207  107d				   FourL
    208  107d		       10		      .byte.b	%00010000
    209  107e		       10		      .byte.b	%00010000
    210  107f		       10		      .byte.b	%00010000
    211  1080		       fe		      .byte.b	%11111110
    212  1081		       90		      .byte.b	%10010000
    213  1082		       90		      .byte.b	%10010000
    214  1083		       90		      .byte.b	%10010000
    215  1084
    216  1084
    217  1084				   ZL
    218  1084		       7f		      .byte.b	%01111111
    219  1085		       40		      .byte.b	%01000000
    220  1086		       40		      .byte.b	%01000000
    221  1087		       7f		      .byte.b	%01111111
    222  1088		       01		      .byte.b	%00000001
    223  1089		       01		      .byte.b	%00000001
    224  108a		       0f		      .byte.b	%00001111
    225  108b
    226  108b				   EL
    227  108b		       7f		      .byte.b	%01111111
    228  108c		       40		      .byte.b	%01000000
    229  108d		       40		      .byte.b	%01000000
    230  108e		       78		      .byte.b	%01111000
    231  108f		       40		      .byte.b	%01000000
    232  1090		       40		      .byte.b	%01000000
    233  1091		       7f		      .byte.b	%01111111
    234  1092
    235  1092				   RL
    236  1092		       48		      .byte.b	%01001000
    237  1093		       48		      .byte.b	%01001000
    238  1094		       48		      .byte.b	%01001000
    239  1095		       7f		      .byte.b	%01111111
    240  1096		       41		      .byte.b	%01000001
    241  1097		       41		      .byte.b	%01000001
    242  1098		       7f		      .byte.b	%01111111
    243  1099
    244  1099				   PL
    245  1099		       40		      .byte.b	%01000000
    246  109a		       40		      .byte.b	%01000000
    247  109b		       40		      .byte.b	%01000000
    248  109c		       7f		      .byte.b	%01111111
    249  109d		       41		      .byte.b	%01000001
    250  109e		       41		      .byte.b	%01000001
    251  109f		       7f		      .byte.b	%01111111
    252  10a0
    253  10a0				   AL
    254  10a0		       41		      .byte.b	%01000001
    255  10a1		       41		      .byte.b	%01000001
    256  10a2		       41		      .byte.b	%01000001
    257  10a3		       7f		      .byte.b	%01111111
    258  10a4		       41		      .byte.b	%01000001
    259  10a5		       41		      .byte.b	%01000001
    260  10a6		       7f		      .byte.b	%01111111
    261  10a7
    262  10a7				   GL
    263  10a7		       7f		      .byte.b	%01111111
    264  10a8		       41		      .byte.b	%01000001
    265  10a9		       41		      .byte.b	%01000001
    266  10aa		       4f		      .byte.b	%01001111
    267  10ab		       40		      .byte.b	%01000000
    268  10ac		       40		      .byte.b	%01000000
    269  10ad		       7f		      .byte.b	%01111111
    270  10ae
    271  10ae
    272  10ae				   CharL
    273  10ae		       7f		      .byte.b	%01111111
    274  10af		       40		      .byte.b	%01000000
    275  10b0		       41		      .byte.b	%01000001
    276  10b1		       40		      .byte.b	%01000000
    277  10b2		       40		      .byte.b	%01000000
    278  10b3		       40		      .byte.b	%01000000
    279  10b4		       40		      .byte.b	%01000000
    280  10b5
    281  10b5				   CharK
    282  10b5		       41		      .byte.b	%01000001
    283  10b6		       41		      .byte.b	%01000001
    284  10b7		       41		      .byte.b	%01000001
    285  10b8		       7f		      .byte.b	%01111111
    286  10b9		       48		      .byte.b	%01001000
    287  10ba		       48		      .byte.b	%01001000
    288  10bb		       48		      .byte.b	%01001000
    289  10bc
    290  10bc				   CharO
    291  10bc		       7f		      .byte.b	%01111111
    292  10bd		       41		      .byte.b	%01000001
    293  10be		       41		      .byte.b	%01000001
    294  10bf		       41		      .byte.b	%01000001
    295  10c0		       41		      .byte.b	%01000001
    296  10c1		       41		      .byte.b	%01000001
    297  10c2		       7f		      .byte.b	%01111111
    298  10c3
    299  10c3
    300  10c3							; level "name" characters (left only!):
    301  10c3
    302  10c3				   CharN
    303  10c3				   kCharK
    304  10c3				   CharH
    305  10c3				   CharA
    306  10c3				   CharJ
    307  10c3				   CharP
    308  10c3				   CharB
    309  10c3							;CharO
    310  10c3				   CharC
    311  10c3				   CharI
    312  10c3				   CharD
    313  10c3				   CharG
    314  10c3				   CharE
    315  10c3							;CharL:
    316  10c3				   CharF
    317  10c3				   CharM
    318  10c3		       00 00 00 00*	      ds	7,0
    319  10ca
    320  10ca				   charPlace
    321  10ca		       0c		      .byte.b	%00001100
    322  10cb		       0c		      .byte.b	%00001100
    323  10cc		       0c		      .byte.b	%00001100
    324  10cd		       0c		      .byte.b	%00001100
    325  10ce		       0c		      .byte.b	%00001100
    326  10cf		       00		      .byte.b	%00000000
    327  10d0		       0c		      .byte.b	%00001100
    328  10d1
    329  10d1							;-------------------------------------------------------------------------------------
    330  10d1				   PosTbl
    331  10d1		       40		      .byte.b	$40
    332  10d2		       31 22 13 04*	      .byte.b	$31, $22, $13, $04, $f5, $e6, $d7, $c8
    333  10da		       b9		      .byte.b	$b9
    334  10db
    335  10db
    336  10db							;------------------------------------------------------------------------------
    337  10db							; RAM-BASED SUBROUTINES...
    338  10db							; NOTE: When calling these routines, remember you are actually calling the ROM routine
    339  10db							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
    340  10db							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
    341  10db							; the RAM-based routine.
    342  10db
    343  1100		       00 00 00 00*	      ALIGN	256	; so SM code needs no HI table
    344  1100
    345  1100		       f1 00	   SM_BASE    =	.
    346  1100
    347  1100							;#IF 0 ;{
    348  1100							;    DEFINE_SUBROUTINE Score3x3
    349  1100							;
    350  1100							;	  sta	  RESP0
    351  1100							;	   sta	   RESP1
    352  1100							;	   lda	   #$$000
    353  1100							;	    sta     GRP0
    354  1100							;	    lda     #$$009
    355  1100							;	    sta     GRP1
    356  1100							;	    lda     #$$202
    357  1100							;	    sta     ENABL
    358  1100							;	    nop
    359  1100							;	    nop
    360  1100							;	    nop
    361  1100							;	    lda     #$$016
    362  1100							;	    ldy     #$$100
    363  1100							;	    ldx     #$$109
    364  1100							;	    sta     GRP0    ; Critical time is right here
    365  1100							;	    stx     GRP1
    366  1100							;	    sty     GRP0
    367  1100							;	    sta     RESP0
    368  1100							;	    sta     RESP1
    369  1100							;	    ldx     #$$116
    370  1100							;	    lda     #$$209
    371  1100							;	    stx     GRP0
    372  1100							;	    sta     GRP1
    373  1100							;	    lda     #$$200
    374  1100							;	    sta     GRP0
    375  1100							;	    sta     RESP0
    376  1100							;	    sta     RESP1
    377  1100							;	    lda     #$$216
    378  1100							;	    nop
    379  1100							;	    sta     GRP0
    380  1100							;
    381  1100							;	      rts
    382  1100							;#ENDIF ;}
    383  1100
    384  1100
    385  1100							;------------------------------------------------------------------------------
    386  1100				   Score1x6Fix SUBROUTINE
      0  1100					      DEFINE_SUBROUTINE	DrawDigits1x6
      1  1100		       00 02	   BANK_DrawDigits1x6 =	_CURRENT_BANK
      2  1100					      SUBROUTINE
      3  1100				   DrawDigits1x6
    388  1100							;					     @07
    389  1100		       ba		      tsx		; 2
    390  1101
    391  1101		       20 02 f2 	      jsr	PrepareDrawDigits	;56 = 58    @65
    392  1104
    393  1104		       86 db		      stx	tmpStack	; 3 =	3
    394  1106
    395  1106				   LoopDraw1x6		;
    396  1106				   SMDIGIT0
    397  1106		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    398  1109		       85 42		      sta	WSYNC	; 3
    399  110b							;---------------------------------------------------------------
    400  110b		       85 6a		      sta	HMOVE	; 3
      0  110d					      SLEEP	3	; 3 =	6
      1  110d				   .CYCLES    SET	3
      2  110d
      3  110d				  -	      IF	.CYCLES < 2
      4  110d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  110d				  -	      ERR
      6  110d					      ENDIF
      7  110d
      8  110d					      IF	.CYCLES & 1
      9  110d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  110d		       04 00		      nop	0
     11  110f				  -	      ELSE
     12  110f				  -	      bit	VSYNC
     13  110f					      ENDIF
     14  110f				   .CYCLES    SET	.CYCLES - 3
     15  110f					      ENDIF
     16  110f
     17  110f				  -	      REPEAT	.CYCLES / 2
     18  110f				  -	      nop
     19  110f					      REPEND
    402  110f		       85 5b		      sta	GRP0	; 3
    403  1111				   SMDIGIT1
    404  1111		       b9 53 f0 	      lda	ZeroL-1,y	; 4
    405  1114		       85 5c		      sta	GRP1	; 3
    406  1116				   SMDIGIT2
    407  1116		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    408  1119		       85 5b		      sta	GRP0	; 3 = 17
    409  111b				   SMDIGIT5
    410  111b		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    411  111e		       9a		      txs		; 2
    412  111f				   SMDIGIT3
    413  111f		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    414  1122				   SMDIGIT4
    415  1122		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    416  1125		       85 6b		      sta	HMCLR	; 3
    417  1127		       86 5c		      stx	GRP1	; 3
    418  1129		       85 5b		      sta	GRP0	; 3 = 23
    419  112b
    420  112b		       ba		      tsx		; 2
    421  112c		       86 5c		      stx	GRP1	; 3
    422  112e		       85 5b		      sta	GRP0	; 3 =	8
    423  1130
    424  1130		       88		      dey		; 2
      0  1131					      CHECKPAGE_BNE	LoopDraw1x6	;2/3= 5    @58/59
      8  1131					      LIST	ON
      9  1131		       d0 d3		      bne	LoopDraw1x6
    426  1133
    427  1133		       a6 db		      ldx	tmpStack	; 3
    428  1135		       9a		      txs		; 2
    429  1136				   ExitDigitKernel6
      0  1136					      SLEEP	3	; 3
      1  1136				   .CYCLES    SET	3
      2  1136
      3  1136				  -	      IF	.CYCLES < 2
      4  1136				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1136				  -	      ERR
      6  1136					      ENDIF
      7  1136
      8  1136					      IF	.CYCLES & 1
      9  1136					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1136		       04 00		      nop	0
     11  1138				  -	      ELSE
     12  1138				  -	      bit	VSYNC
     13  1138					      ENDIF
     14  1138				   .CYCLES    SET	.CYCLES - 3
     15  1138					      ENDIF
     16  1138
     17  1138				  -	      REPEAT	.CYCLES / 2
     18  1138				  -	      nop
     19  1138					      REPEND
    431  1138		       4c 77 f1 	      jmp	ExitDigitKernel	; 3 = 11    @69
    432  113b
    433  113b
    434  113b							;------------------------------------------------------------------------------
    435  113b				   Score2x4Fix SUBROUTINE
      0  113b					      DEFINE_SUBROUTINE	DrawDigits2x4
      1  113b		       00 02	   BANK_DrawDigits2x4 =	_CURRENT_BANK
      2  113b					      SUBROUTINE
      3  113b				   DrawDigits2x4
    437  113b
    438  113b
    439  113b							; Subroutine by Thomas Jentzsch.  Magic!
    440  113b							; This subroutine draws two 4-digit scores on the screen, side-by-side. Amazing!
    441  113b
    442  113b							;sta COLUBK
    443  113b
    444  113b		       20 02 f2 	      jsr	PrepareDrawDigits	;56 = 56    @63
    445  113e
    446  113e		       85 6a		      sta	HMOVE	; 3
      0  1140					      SLEEP	4	; 4  =  7
      1  1140				   .CYCLES    SET	4
      2  1140
      3  1140				  -	      IF	.CYCLES < 2
      4  1140				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1140				  -	      ERR
      6  1140					      ENDIF
      7  1140
      8  1140				  -	      IF	.CYCLES & 1
      9  1140				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1140				  -	      nop	0
     11  1140				  -	      ELSE
     12  1140				  -	      bit	VSYNC
     13  1140				  -	      ENDIF
     14  1140				  -.CYCLES    SET	.CYCLES - 3
     15  1140					      ENDIF
     16  1140
     17  1140					      REPEAT	.CYCLES / 2
     18  1140		       ea		      nop
     17  1140					      REPEND
     18  1141		       ea		      nop
     19  1142					      REPEND
    448  1142
    449  1142				   LoopDraw2x4		;	     @70
    450  1142				   SM_TARGET3
    451  1142		       b9 07 f3 	      lda	DequalsR-1,y	; 4		     G
    452  1145							;---------------------------------------------------------------
    453  1145		       85 5b		      sta	GRP0	; 3
    454  1147				   SM_TARGET2
    455  1147		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     A
    456  114a		       85 5c		      sta	GRP1	; 3
    457  114c				   SM_TARGET1
    458  114c		       b9 31 f3 	      lda	ZeroR-1,y	; 4		     M
    459  114f		       85 5b		      sta	GRP0	; 3
    460  1151				   SM_TARGET0
    461  1151		       be 53 f0 	      ldx	ZeroL-1,y	; 4		     E
    462  1154		       85 50		      sta	RESP0	; 3 = 28    @22
    463  1156		       85 51		      sta	RESP1	; 3 =	3    @25
    464  1158				   SM_Time3
    465  1158		       b9 15 f3 	      lda	ClockR-1,y	; 4		     O
    466  115b		       86 5c		      stx	GRP1	; 3
    467  115d		       85 5b		      sta	GRP0	; 3
    468  115f				   SM_Time2
    469  115f		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     V
    470  1162		       85 5c		      sta	GRP1	; 3
    471  1164				   SM_Time1
    472  1164		       b9 31 f3 	      lda	ZeroR-1,y	; 4		     E
    473  1167		       85 5b		      sta	GRP0	; 3
    474  1169		       85 50		      sta	RESP0	; 3 = 27    @52 (was 54)
    475  116b		       85 51		      sta	RESP1	; 3 =	3    @55
    476  116d				   SM_Time0
    477  116d		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     R
    478  1170		       85 5c		      sta	GRP1	; 3
    479  1172		       85 5b		      sta	GRP0	; 3
    480  1174		       88		      dey		; 2
      0  1175					      CHECKPAGE_BNE	LoopDraw2x4	;2/3=15    @70
      8  1175					      LIST	ON
      9  1175		       d0 cb		      bne	LoopDraw2x4
    482  1177
    483  1177				   ExitDigitKernel		;	     @69
    484  1177		       84 5b		      sty	GRP0	; 3
    485  1179		       84 5c		      sty	GRP1	; 3
    486  117b							;---------------------------------------------------------------
    487  117b		       84 5b		      sty	GRP0	; 3	     @02
    488  117d
    489  117d							; Contribution by Thomas Jentzsch
    490  117d							; Rewrite/Optimised for single sprite AD
    491  117d
    492  117d		       a6 9f		      ldx	ManDrawX	; 3
    493  117f		       bd d1 f0 	      lda	PosTbl,x	; 4
    494  1182		       85 60		      sta	HMP0	; 3
    495  1184		       29 0f		      and	#$0f	; 2
    496  1186		       f0 04		      beq	.zeroPos	; 2/3=15
    497  1188		       aa		      tax		; 2
    498  1189				   .loopWait
    499  1189		       ca		      dex		; 2
    500  118a		       d0 fd		      bne	.loopWait	; 2/3= 6
    501  118c				   .zeroPos
    502  118c		       a2 70		      ldx	#$70	; 2	     magic value #1 for Cosmic Ark stars
    503  118e		       85 50		      sta	RESP0	; 3 =	5    @22..67 (@look around!)
    504  1190
    505  1190		       85 42		      sta	WSYNC
    506  1192		       85 6a		      sta	HMOVE	; 3
    507  1194
    508  1194		       a5 b0		      lda	BGColour	; 3
    509  1196		       85 49		      sta	COLUBK	;3
    510  1198
    511  1198		       86 62		      stx	HMM0	; 3	     for extra life stars!
    512  119a
    513  119a		       a9 15		      lda	#%00010101	; 2	 double width missile, double width player
    514  119c		       85 44		      sta	NUSIZ0	; 3
    515  119e		       85 45		      sta	NUSIZ1
    516  11a0		       84 65		      sty	VDELP0	; 3	 y = 0!
    517  11a2
      0  11a2					      SLEEP	5
      1  11a2				   .CYCLES    SET	5
      2  11a2
      3  11a2				  -	      IF	.CYCLES < 2
      4  11a2				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11a2				  -	      ERR
      6  11a2					      ENDIF
      7  11a2
      8  11a2					      IF	.CYCLES & 1
      9  11a2					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11a2		       04 00		      nop	0
     11  11a4				  -	      ELSE
     12  11a4				  -	      bit	VSYNC
     13  11a4					      ENDIF
     14  11a4				   .CYCLES    SET	.CYCLES - 3
     15  11a4					      ENDIF
     16  11a4
     17  11a4					      REPEAT	.CYCLES / 2
     18  11a4		       ea		      nop
     19  11a5					      REPEND
    519  11a5
    520  11a5		       a5 a2		      lda	ManLastDirection	; 3
    521  11a7		       85 4b		      sta	REFP0	; 3
    522  11a9
    523  11a9							;sta WSYNC		  ; 3
    524  11a9		       60		      rts		; 6	     @21
    525  11aa
    526  11aa							;------------------------------------------------------------------------------
    527  11aa				   Score3x2Fix SUBROUTINE
      0  11aa					      DEFINE_SUBROUTINE	DrawDigits3x2
      1  11aa		       00 02	   BANK_DrawDigits3x2 =	_CURRENT_BANK
      2  11aa					      SUBROUTINE
      3  11aa				   DrawDigits3x2
    529  11aa							;					     @07
    530  11aa		       a9 16		      lda	#%010110	; 2
    531  11ac		       a0 ef		      ldy	#$f0-1	; 2		     moved slightly out of center to match 1x6 display position
    532  11ae		       20 08 f2 	      jsr	PrepareDrawDigits2	;49 = 53    @60
    533  11b1
    534  11b1		       a9 00		      lda	#0
    535  11b3		       85 66		      sta	VDELP1
    536  11b5				   LoopDraw3x2		;
    537  11b5		       85 42		      sta	WSYNC	; 3
    538  11b7							;---------------------------------------------------------------
    539  11b7		       85 6a		      sta	HMOVE	; 3 =	3
    540  11b9		       b9 c2 f0 	      lda	CharP-1,y	; 4
    541  11bc		       85 5b		      sta	GRP0	; 3
    542  11be				   SMPLAYER
    543  11be		       b9 3f f3 	      lda	OneR-1,y	; 4
    544  11c1		       85 5c		      sta	GRP1	; 3 = 14    @17
    545  11c3		       b9 c9 f0 	      lda	charPlace-1,y	; 4
    546  11c6				   SMMEN
    547  11c6		       be 38 f3 	      ldx	ThreeR-1,y	; 4 =	8
      0  11c9					      SLEEP	5	;   =	5
      1  11c9				   .CYCLES    SET	5
      2  11c9
      3  11c9				  -	      IF	.CYCLES < 2
      4  11c9				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11c9				  -	      ERR
      6  11c9					      ENDIF
      7  11c9
      8  11c9					      IF	.CYCLES & 1
      9  11c9					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11c9		       04 00		      nop	0
     11  11cb				  -	      ELSE
     12  11cb				  -	      bit	VSYNC
     13  11cb					      ENDIF
     14  11cb				   .CYCLES    SET	.CYCLES - 3
     15  11cb					      ENDIF
     16  11cb
     17  11cb					      REPEAT	.CYCLES / 2
     18  11cb		       ea		      nop
     19  11cc					      REPEND
    549  11cc		       85 5b		      sta	GRP0	; 3
    550  11ce				   SMLEVELX
    551  11ce		       b9 c2 f0 	      lda	CharA-1,y	; 4
    552  11d1		       85 6b		      sta	HMCLR	; 3 = 10    @40
    553  11d3		       86 5c		      stx	GRP1	; 3 =	3    @43
    554  11d5		       85 5b		      sta	GRP0	; 3
    555  11d7				   SMLEVEL
    556  11d7		       b9 3f f3 	      lda	OneR-1,y	; 4
    557  11da		       85 5c		      sta	GRP1	; 3 = 10    @53
    558  11dc
    559  11dc		       88		      dey		; 2
      0  11dd					      CHECKPAGE_BNE	LoopDraw3x2	;2/3= 5    @58
      8  11dd					      LIST	ON
      9  11dd		       d0 d6		      bne	LoopDraw3x2
    561  11df							;					     @57
      0  11df					      SLEEP	3	; 3
      1  11df				   .CYCLES    SET	3
      2  11df
      3  11df				  -	      IF	.CYCLES < 2
      4  11df				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11df				  -	      ERR
      6  11df					      ENDIF
      7  11df
      8  11df					      IF	.CYCLES & 1
      9  11df					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11df		       04 00		      nop	0
     11  11e1				  -	      ELSE
     12  11e1				  -	      bit	VSYNC
     13  11e1					      ENDIF
     14  11e1				   .CYCLES    SET	.CYCLES - 3
     15  11e1					      ENDIF
     16  11e1
     17  11e1				  -	      REPEAT	.CYCLES / 2
     18  11e1				  -	      nop
     19  11e1					      REPEND
    563  11e1		       4c 36 f1 	      jmp	ExitDigitKernel6	; 9 = 12    @69  'BEQ' WAS A DANGEROUS ASSUMPTION OF STATUS FLAG!!
    564  11e4
    565  11e4
    566  11e4							;------------------------------------------------------------------------------
    567  11e4
    568  11e4				   ScoreKernelLo
    569  11e4		       3b		      .byte.b	<Score2x4Fix	; TARGETs, time
    570  11e5		       00		      .byte.b	<Score1x6Fix	; score
    571  11e6		       aa		      .byte.b	<Score3x2Fix	; player, lives, level
    572  11e7		       00		      .byte.b	<Score1x6Fix	; high score
    573  11e8
      0  11e8					      CHECKPAGE	DrawDigits1x6	; AD: the jump requires all in the same page, so let's enforce that
      8  11e8					      LIST	ON
    575  11e8
    576  11e8							;------------------------------------------------------------------------------
    577  11e8
      0  11e8					      DEFINE_SUBROUTINE	DrawDigits
      1  11e8		       00 02	   BANK_DrawDigits =	_CURRENT_BANK
      2  11e8					      SUBROUTINE
      3  11e8				   DrawDigits
    579  11e8
    580  11e8				   VblankLoopGame
    581  11e8		       ac 84 02 	      ldy	INTIM
    582  11eb		       d0 fb		      bne	VblankLoopGame
    583  11ed
    584  11ed					      IF	WAIT_FOR_INITIAL_DRAW
    585  11ed		       a4 ae		      ldy	blankState
    586  11ef		       f0 02		      beq	state0
    587  11f1		       a0 02		      ldy	#2
    588  11f3				   state0
    589  11f3					      ENDIF
    590  11f3		       84 41		      sty	VBLANK	; 3	     <-- 0
    591  11f5							;lda scoringFlags	  ; 3
    592  11f5							;and #DISPLAY_FLAGS		    ; 2
    593  11f5							;tax			  ; 2
    594  11f5
    595  11f5		       a2 00		      ldx	#0
    596  11f7
    597  11f7							;    DEFINE_SUBROUTINE DrawDigit2
    598  11f7							;
    599  11f7							;    ; Generic interface to scoring routine
    600  11f7
    601  11f7		       bd e4 f1 	      lda	ScoreKernelLo,x	; 4
    602  11fa
    603  11fa		       85 42		      sta	WSYNC	; 3
    604  11fc		       8d 00 f6 	      sta	SMJUMP+1+RAM_WRITE	; 4
    605  11ff				   SMJUMP
    606  11ff		       4c 00 f1 	      jmp	DrawDigits1x6	; 3 =	7    @07
    607  1202
    608  1202							;---------------------------------------------------------------
    609  1202
      0  1202					      DEFINE_SUBROUTINE	PrepareDrawDigits
      1  1202		       00 02	   BANK_PrepareDrawDigits =	_CURRENT_BANK
      2  1202					      SUBROUTINE
      3  1202				   PrepareDrawDigits
    611  1202							;					     @13
    612  1202		       a0 d1		      ldy	#$d1	; 2
    613  1204		       a9 13		      lda	#%010011	; 2
    614  1206		       85 66		      sta	VDELP1	; 3 =	7
    615  1208				   PrepareDrawDigits2		;	    @17/20
    616  1208		       84 65		      sty	VDELP0	; 3 =	3
    617  120a
    618  120a		       85 45		      sta	NUSIZ1	; 3
    619  120c		       85 44		      sta	NUSIZ0	; 3 =	6
    620  120e
    621  120e		       8d 4b 00 	      sta.w	REFP0	; 4		     bit 3 is always clear
    622  1211		       85 50		      sta	RESP0	; 3	     @33/36
    623  1213		       85 51		      sta	RESP1	; 3 = 10    @36/39
    624  1215
    625  1215		       84 60		      sty	HMP0	; 3
    626  1217		       c8		      iny		; 2
    627  1218		       84 61		      sty	HMP1	; 3 =	8
    628  121a				   SMCOLOR
    629  121a		       a0 9a		      ldy	#SCORE_COL	; 2
    630  121c		       84 46		      sty	COLUP0	; 3
    631  121e		       84 47		      sty	COLUP1	; 3 =	8
    632  1220
    633  1220		       a0 07		      ldy	#DIGIT_H	; 2
    634  1222		       60		      rts		; 6 =	8
    635  1223							; total: 27
    636  1223
    637  1223
    638  1223							;------------------------------------------------------------------------------
      0  1223					      DEFINE_SUBROUTINE	UpdateScore
      1  1223		       00 02	   BANK_UpdateScore =	_CURRENT_BANK
      2  1223					      SUBROUTINE
      3  1223				   UpdateScore
    640  1223							; a = added score value
    641  1223
    642  1223							; initially switch to score:
    643  1223		       a0 01		      ldy	#DISPLAY_SCORE
    644  1225		       84 db		      sty	newDisplay
    645  1227
    646  1227		       18		      clc
    647  1228		       f8		      sed
    648  1229		       a0 04		      ldy	#SM_OFS_SCORE
    649  122b				   .loopScore
    650  122b		       79 8f f3 	      adc	ScoreCurrent-SM_OFS_SCORE,y
    651  122e		       99 8f f7 	      sta	ScoreCurrent-SM_OFS_SCORE+RAM_WRITE,y
    652  1231		       08		      php
    653  1232							; *** bonus life every 500 points: ***
    654  1232							;	  cpy #SM_OFS_SCORE+1
    655  1232							;	  bne .skipBonusLife
    656  1232							;	  tax
    657  1232
    658  1232							;	  and #$0f
    659  1232							;	  beq .bonusLife		      ; 000?
    660  1232							;	  cmp #$05
    661  1232							;	  bne .noBonusLife		      ; 500?
    662  1232							;.bonusLife:
    663  1232							; add extra life, limited to 9
    664  1232
    665  1232							;	  lda ManCount
    666  1232							;	  and #$0f
    667  1232							;	  cmp #9
    668  1232							;	  bcs .noBonusLife
    669  1232							;	  inc ManCount
    670  1232
    671  1232							; bonus life has priority over score:
    672  1232							;	  lda #DISPLAY_LIVES
    673  1232							;	  sta newDisplay
    674  1232							;lda #EXTRA_LIFE_TIMER
    675  1232							;sta extraLifeTimer
    676  1232
    677  1232				   .noBonusLife
    678  1232		       8a		      txa
    679  1233				   .skipBonusLife
    680  1233		       20 ae f2 	      jsr	SetupBCDPtr
    681  1236		       28		      plp
    682  1237		       a9 00		      lda	#0
    683  1239		       b0 f0		      bcs	.loopScore
    684  123b		       d8		      cld
    685  123c
    686  123c							; switch display
    687  123c							;lda scoringFlags
    688  123c							;and #DISPLAY_FLAGS
    689  123c							;cmp newDisplay		      ; lower priority than current?
    690  123c							;beq .restartTime
    691  123c							;bcs .skipNew
    692  123c							;eor scoringFlags		      ; remove existing score mode
    693  123c							;ora newDisplay		      ; switch to new score mode
    694  123c							;sta scoringFlags
    695  123c				   .restartTime
    696  123c							;lda #SCORING_TIMER		      ; maybe always restart timer?
    697  123c							;sta scoringTimer
    698  123c				   .skipNew
    699  123c
    700  123c		       60		      rts
    701  123d
    702  123d							;---------------------------------------------------------------------------
    703  123d
      0  123d					      DEFINE_SUBROUTINE	SwapPlayers
      1  123d		       00 02	   BANK_SwapPlayers =	_CURRENT_BANK
      2  123d					      SUBROUTINE
      3  123d				   SwapPlayers
    705  123d
    706  123d							; assume no new high score:
    707  123d		       a0 ff		      ldy	#-1
    708  123f		       84 de		      sty	highScoreSK
    709  1241
    710  1241							; update highscore after last live:
    711  1241							;lda ManCount
    712  1241							;and #$0f			      ; player has lives left?
    713  1241							;bne .playerAlive		      ; YES, so we don't check high score
    714  1241
    715  1241							; check for a new high score:
    716  1241							;	  ldy #-1
    717  1241		       18		      clc		; score has to be at least 1 bigger!
    718  1242				   .loopCheckHighScore
    719  1242		       c8		      iny
    720  1243		       b9 93 f3 	      lda	ScoreCurrent,y
    721  1246		       f9 9d f3 	      sbc	HighScore,y
    722  1249		       98		      tya
    723  124a		       49 02		      eor	#2
    724  124c		       d0 f4		      bne	.loopCheckHighScore
    725  124e		       90 0d		      bcc	.noHighScore
    726  1250
    727  1250							; new high score, update:
    728  1250		       a2 04		      ldx	#5-1
    729  1252				   .loopSetHighScore
    730  1252		       bd 93 f3 	      lda	ScoreCurrent,x
    731  1255		       9d 9d f7 	      sta	HighScore+RAM_WRITE,x
    732  1258		       95 de		      sta	highScoreSK,x
    733  125a		       ca		      dex
    734  125b		       10 f5		      bpl	.loopSetHighScore
    735  125d				   .noHighScore
    736  125d
    737  125d				   .playerAlive
    738  125d							;lda ManCount
    739  125d							;and #$f0			      ; other player has lives left?
    740  125d							;beq .otherPlayerDead		      ; NO, so we don't swap scores
    741  125d
    742  125d							; save the current player variables to the player's backup:
    743  125d		       a0 02		      ldy	#3-1
    744  125f				   .swapScore
    745  125f		       be 98 f3 	      ldx	PlayerScores,y
    746  1262		       b9 93 f3 	      lda	ScoreCurrent,y
    747  1265		       99 98 f7 	      sta	PlayerScores+RAM_WRITE,y
    748  1268		       8a		      txa
    749  1269		       99 93 f7 	      sta	ScoreCurrent+RAM_WRITE,y
    750  126c		       88		      dey
    751  126d		       10 f0		      bpl	.swapScore
    752  126f
    753  126f							; swap levelx and level:
    754  126f		       a2 01		      ldx	#1
    755  1271				   .loopLevelXLevel
    756  1271		       bc 9b f3 	      ldy	PlayerLevelX,x
    757  1274		       b5 b1		      lda	levelX,x
    758  1276		       9d 9b f7 	      sta	PlayerLevelX+RAM_WRITE,x
    759  1279		       94 b1		      sty	levelX,x
    760  127b		       ca		      dex
    761  127c		       10 f3		      bpl	.loopLevelXLevel
    762  127e
    763  127e				   .otherPlayerDead
    764  127e		       60		      rts
    765  127f
    766  127f							;---------------------------------------------------------------------------
    767  127f
    768  127f				   HighScoreColTbl
    769  127f		       44 44		      .byte.b	SCORE_COL_HIGH_NTSC, SCORE_COL_HIGH_NTSC
    770  1281		       66 66		      .byte.b	SCORE_COL_HIGH_PAL, SCORE_COL_HIGH_PAL
    771  1283
      0  1283					      DEFINE_SUBROUTINE	GeneralScoringSetups
      1  1283		       00 02	   BANK_GeneralScoringSetups =	_CURRENT_BANK
      2  1283					      SUBROUTINE
      3  1283				   GeneralScoringSetups
    773  1283
    774  1283		       a0 04		      ldy	#SM_OFS_SCORE
    775  1285				   .loopScore2
    776  1285							;lda scoringFlags
    777  1285							;and #DISPLAY_FLAGS
    778  1285							;cmp #DISPLAY_HIGH
    779  1285							;ldx Platform
    780  1285							;lda HighScoreColTbl,x
    781  1285							;tax
    782  1285							;lda HighScore-SM_OFS_SCORE,y
    783  1285							;bcs .showHighScore
    784  1285		       a2 9a		      ldx	#SCORE_COL
    785  1287		       b9 8f f3 	      lda	ScoreCurrent-SM_OFS_SCORE,y
    786  128a				   .showHighScore
    787  128a		       8e 1b f6 	      stx	SMCOLOR+1+RAM_WRITE
    788  128d		       20 ae f2 	      jsr	SetupBCDPtr
    789  1290		       c0 07		      cpy	#SM_OFS_SCORE+3
    790  1292		       90 f1		      bcc	.loopScore2
    791  1294
    792  1294							; display number of lives in leftmost digit of middle score XX nX XX
    793  1294
    794  1294							;lda ManCount
    795  1294							;and #$0f
    796  1294							;tay
    797  1294							;lda DigitVectorLOr,y
    798  1294							;sta SMMEN+1+RAM_WRITE
    799  1294
    800  1294							; modify player number pointer (Xp XX XX)
    801  1294
    802  1294							;ldy whichPlayer
    803  1294							;lda DigitVectorLOr+1,y
    804  1294							;sta SMPLAYER+1+RAM_WRITE
    805  1294
    806  1294							; fall through
    807  1294
    808  1294							;    ;---------------------------------------------------------------------------
    809  1294
    810  1294							; modify levelx character pointer (XX XX cX)
    811  1294
    812  1294							;ldx #<charPlace-1
    813  1294							;lda levelDisplay
    814  1294							;cmp #$80
    815  1294							;and #$1f
    816  1294							;tay
    817  1294							;bcs .intermission
    818  1294							;ldx CharVectorLO,y
    819  1294							;ldy level
    820  1294							;.intermission
    821  1294							;stx SMLEVELX+1+RAM_WRITE
    822  1294
    823  1294							; modify level number pointer (XX XX Xl)
    824  1294
    825  1294							;lda DigitVectorLOr+1,y
    826  1294							;sta SMLEVEL+1+RAM_WRITE
    827  1294
    828  1294							;---------------------------------------------------------------------------
    829  1294
    830  1294		       4c a5 f2 	      jmp	SetupTimePtr	; modify time pointers
    831  1297
    832  1297							;------------------------------------------------------------------------------
    833  1297							;    DEFINE_SUBROUTINE SetupGameOverPtr
    834  1297
    835  1297							;		  ldy #8-1
    836  1297							;.loopGameOver:
    837  1297							;		  ldx SMGameOverOfs,y
    838  1297							;		  lda SMGameOverPtr,y
    839  1297							;		  sta SM_BASE+1+RAM_WRITE,x
    840  1297							;		  dey
    841  1297							;		  bpl .loopGameOver
    842  1297
    843  1297							;		  rts
    844  1297
    845  1297							;SMGameOverOfs:
    846  1297							;		  .byte <SM_TARGET3-SM_BASE, <SM_TARGET2-SM_BASE
    847  1297							;		  .byte <SM_TARGET1-SM_BASE, <SM_TARGET0-SM_BASE
    848  1297							;		  .byte <SM_Time3-SM_BASE, <SM_Time2-SM_BASE
    849  1297							;		  .byte <SM_Time1-SM_BASE, <SM_Time0-SM_BASE
    850  1297							;SMGameOverPtr:
    851  1297							;		  .byte <CharG-1, <CharAL-1, <CharM-1, <CharEL-1
    852  1297							;		  .byte <CharO-1, <CharVL-1, <CharE-1, <CharRL-1
    853  1297
    854  1297							;------------------------------------------------------------------------------
    855  1297
      0  1297					      DEFINE_SUBROUTINE	DrawBCD_targetsRequired
      1  1297		       00 02	   BANK_DrawBCD_targetsRequired =	_CURRENT_BANK
      2  1297					      SUBROUTINE
      3  1297				   DrawBCD_targetsRequired
    857  1297							; Show current TARGET counter in the top left
    858  1297
    859  1297		       a0 00		      ldy	#SM_OFS_TARGETS
    860  1299		       a5 b4		      lda	BCD_targetsRequired
    861  129b		       20 ae f2 	      jsr	SetupBCDPtr
    862  129e
    863  129e		       a9 b0		      lda	#ID_TARGET<<4	; if no extra targets, display the normal icon
    864  12a0							;bit scoringFlags		      ;
    865  12a0		       4c ae f2 	      jmp	SetupBCDPtr
    866  12a3							;lda #ID_EXTRA<<4		      ; otherwise, display the extra icon
    867  12a3							;bvc SetupBCDPtr
    868  12a3							;ora #1			      ; display 1xx targets
    869  12a3							;bne SetupBCDPtr		      ; unconditional
    870  12a3
    871  12a3							;------------------------------------------------------------------------------
      0  12a3					      DEFINE_SUBROUTINE	DrawTime
      1  12a3		       00 02	   BANK_DrawTime =	_CURRENT_BANK
      2  12a3					      SUBROUTINE
      3  12a3				   DrawTime
    873  12a3
    874  12a3							; mid-digit-change, but we may be required to flash/display
    875  12a3		       a0 02		      ldy	#SM_OFS_TIME
    876  12a5							;------------------------------------------------------------------------------
      0  12a5					      DEFINE_SUBROUTINE	SetupTimePtr
      1  12a5		       00 02	   BANK_SetupTimePtr =	_CURRENT_BANK
      2  12a5					      SUBROUTINE
      3  12a5				   SetupTimePtr
    878  12a5
    879  12a5		       a5 b5		      lda	BCD_moveCounter
    880  12a7		       20 ae f2 	      jsr	SetupBCDPtr
    881  12aa		       a5 b6		      lda	BCD_moveCounter+1
    882  12ac		       09 d0		      ora	#ID_CLOCK<<4
    883  12ae
    884  12ae							; fall through
    885  12ae
    886  12ae							;------------------------------------------------------------------------------
      0  12ae					      DEFINE_SUBROUTINE	SetupBCDPtr
      1  12ae		       00 02	   BANK_SetupBCDPtr =	_CURRENT_BANK
      2  12ae					      SUBROUTINE
      3  12ae				   SetupBCDPtr
    888  12ae
    889  12ae							; a = BCD value
    890  12ae							; y = SM table offset
    891  12ae
    892  12ae		       48		      pha
    893  12af		       29 0f		      and	#$0f
    894  12b1		       aa		      tax
    895  12b2		       bd 0e f0 	      lda	DigitVectorLO,x	; low nibble: left aligned chars
    896  12b5		       be 19 f0 	      ldx	SMTblLSB,y
    897  12b8		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    898  12bb		       68		      pla
    899  12bc		       4a		      lsr
    900  12bd		       4a		      lsr
    901  12be		       4a		      lsr
    902  12bf		       4a		      lsr
    903  12c0		       aa		      tax
    904  12c1		       bd 00 f0 	      lda	DigitVectorLOr,x	; high nibble: right aligned chars
    905  12c4		       be 20 f0 	      ldx	SMTblMSB,y
    906  12c7		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    907  12ca
    908  12ca		       c8		      iny
    909  12cb
    910  12cb		       a5 be		      lda	ROM_Bank
    911  12cd				   RTS
    912  12cd		       60		      rts
    913  12ce
      0  12ce					      OPTIONAL_PAGEBREAK	"LeftDigits", (DIGIT_H*13)	; cannot index across page!
 PAGE BREAK INSERTED FOR  LeftDigits
 REQUESTED SIZE =  $5b
 WASTED SPACE =  $32
 PAGEBREAK LOCATION =  $f300
     10  1300					      LIST	ON
    915  1300
    916  1300					      IF	<. = 0
    917  1300		       00		      .byte.b	0	; required!
    918  1301					      ENDIF
    919  1301
    920  1301				   BLANKR
    921  1301		       00 00 00 00*	      .ds	DIGIT_H, 0
    922  1308
    923  1308				   DequalsR
    924  1308		       00		      .byte.b	%00000000
    925  1309		       00		      .byte.b	%00000000
    926  130a		       f0		      .byte.b	%11110000
    927  130b		       00		      .byte.b	%00000000
    928  130c		       f0		      .byte.b	%11110000
    929  130d		       00		      .byte.b	%00000000
    930  130e		       f0		      .byte.b	%11110000
    931  130f				   DplusR
    932  130f		       10		      .byte.b	%00010000
    933  1310		       28		      .byte.b	%00101000
    934  1311		       6c		      .byte.b	%01101100
    935  1312		       c6		      .byte.b	%11000110
    936  1313		       6c		      .byte.b	%01101100
    937  1314		       28		      .byte.b	%00101000
    938  1315		       10		      .byte.b	%00010000
    939  1316
    940  1316				   ClockR
    941  1316		       00		      .byte.b	%00000000
    942  1317		       48		      .byte.b	%01001000
    943  1318		       fc		      .byte.b	%11111100
    944  1319		       48		      .byte.b	%01001000
    945  131a		       48		      .byte.b	%01001000
    946  131b		       fc		      .byte.b	%11111100
    947  131c		       48		      .byte.b	%01001000
    948  131d				   NineR
    949  131d		       0f		      .byte.b	%00001111
    950  131e		       01		      .byte.b	%00000001
    951  131f		       01		      .byte.b	%00000001
    952  1320		       7f		      .byte.b	%01111111
    953  1321		       41		      .byte.b	%01000001
    954  1322		       41		      .byte.b	%01000001
    955  1323		       7f		      .byte.b	%01111111
    956  1324				   SixR
    957  1324		       7f		      .byte.b	%01111111
    958  1325		       41		      .byte.b	%01000001
    959  1326		       41		      .byte.b	%01000001
    960  1327		       7f		      .byte.b	%01111111
    961  1328		       40		      .byte.b	%01000000
    962  1329		       40		      .byte.b	%01000000
    963  132a		       78		      .byte.b	%01111000
    964  132b				   EightR
    965  132b							;  .byte %00111110
    966  132b							;  .byte %01000011
    967  132b							;  .byte %01000011
    968  132b							;  .byte %00111110
    969  132b							;  .byte %00100011
    970  132b							;  .byte %00100011
    971  132b							;  .byte %00011110
    972  132b
    973  132b
    974  132b		       7f		      .byte.b	%01111111
    975  132c		       41		      .byte.b	%01000001
    976  132d		       41		      .byte.b	%01000001
    977  132e		       7f		      .byte.b	%01111111
    978  132f		       41		      .byte.b	%01000001
    979  1330		       41		      .byte.b	%01000001
    980  1331		       7f		      .byte.b	%01111111
    981  1332
    982  1332				   ZeroR
    983  1332		       7f		      .byte.b	%01111111
    984  1333		       41		      .byte.b	%01000001
    985  1334		       41		      .byte.b	%01000001
    986  1335		       41		      .byte.b	%01000001
    987  1336		       41		      .byte.b	%01000001
    988  1337		       41		      .byte.b	%01000001
    989  1338		       7f		      .byte.b	%01111111
    990  1339
    991  1339							;	  .byte %00111110
    992  1339							;	  .byte %01000011
    993  1339							;	  .byte %01000011
    994  1339							;	  .byte %01000011
    995  1339							;	  .byte %01000011
    996  1339							;	  .byte %00100011
    997  1339							;	  .byte %00011110
    998  1339				   ThreeR
    999  1339		       7f		      .byte.b	%01111111
   1000  133a		       01		      .byte.b	%00000001
   1001  133b		       01		      .byte.b	%00000001
   1002  133c		       0f		      .byte.b	%00001111
   1003  133d		       01		      .byte.b	%00000001
   1004  133e		       01		      .byte.b	%00000001
   1005  133f		       7f		      .byte.b	%01111111
   1006  1340				   OneR
   1007  1340		       08		      .byte.b	%00001000
   1008  1341		       08		      .byte.b	%00001000
   1009  1342		       08		      .byte.b	%00001000
   1010  1343		       08		      .byte.b	%00001000
   1011  1344		       08		      .byte.b	%00001000
   1012  1345		       08		      .byte.b	%00001000
   1013  1346		       08		      .byte.b	%00001000
   1014  1347
   1015  1347				   SevenR
   1016  1347		       08		      .byte.b	%00001000
   1017  1348		       08		      .byte.b	%00001000
   1018  1349		       08		      .byte.b	%00001000
   1019  134a		       0f		      .byte.b	%00001111
   1020  134b		       01		      .byte.b	%00000001
   1021  134c		       01		      .byte.b	%00000001
   1022  134d		       7f		      .byte.b	%01111111
   1023  134e
   1024  134e				   TwoR
   1025  134e		       7f		      .byte.b	%01111111
   1026  134f		       40		      .byte.b	%01000000
   1027  1350		       40		      .byte.b	%01000000
   1028  1351		       7f		      .byte.b	%01111111
   1029  1352		       01		      .byte.b	%00000001
   1030  1353		       01		      .byte.b	%00000001
   1031  1354		       7f		      .byte.b	%01111111
   1032  1355				   FiveR
   1033  1355		       7f		      .byte.b	%01111111
   1034  1356		       01		      .byte.b	%00000001
   1035  1357		       01		      .byte.b	%00000001
   1036  1358		       7f		      .byte.b	%01111111
   1037  1359		       40		      .byte.b	%01000000
   1038  135a		       40		      .byte.b	%01000000
   1039  135b		       78		      .byte.b	%01111000
   1040  135c				   FourR
   1041  135c		       08		      .byte.b	%00001000
   1042  135d		       08		      .byte.b	%00001000
   1043  135e		       08		      .byte.b	%00001000
   1044  135f		       7f		      .byte.b	%01111111
   1045  1360		       48		      .byte.b	%01001000
   1046  1361		       48		      .byte.b	%01001000
   1047  1362		       48		      .byte.b	%01001000
   1048  1363
   1049  1363							;CharAL:
   1050  1363							;    .byte %11100110
   1051  1363							;    .byte %11100110
   1052  1363							;    .byte %11111110
   1053  1363							;    .byte %11100110
   1054  1363							;    .byte %11100110
   1055  1363							;    .byte %01111100
   1056  1363							;    .byte %00111000
   1057  1363							;CharEL:
   1058  1363							;    .byte %11111110
   1059  1363							;    .byte %11111110
   1060  1363							;    .byte %11100000
   1061  1363							;    .byte %11100000
   1062  1363							;    .byte %11111100
   1063  1363							;    .byte %11100000
   1064  1363							;    .byte %11111110
   1065  1363							;CharRL:
   1066  1363							;    .byte %11100110
   1067  1363							;    .byte %11100110
   1068  1363							;    .byte %11111100
   1069  1363							;    .byte %11111100
   1070  1363							;    .byte %11100110
   1071  1363							;    .byte %11100110
   1072  1363							;    .byte %11111100
   1073  1363							;CharVL:
   1074  1363							;    .byte %00111000
   1075  1363							;    .byte %01111100
   1076  1363							;    .byte %11100110
   1077  1363							;    .byte %11100110
   1078  1363							;    .byte %11100110
   1079  1363							;    .byte %11100110
   1080  1363							;    .byte %11100110
   1081  1363
      0  1363					      CHECKPAGE	BLANKR
      8  1363					      LIST	ON
   1083  1363
   1084  1363							;---------------------------------------------------------------------------
   1085  1363
      0  1363					      DEFINE_SUBROUTINE	GameInitialise
      1  1363		       00 02	   BANK_GameInitialise =	_CURRENT_BANK
      2  1363					      SUBROUTINE
      3  1363				   GameInitialise
   1087  1363
   1088  1363							; copy loaded SK high score into scoring RAM:
   1089  1363		       a2 02		      ldx	#3-1
   1090  1365				   .loopCopyHighScore
   1091  1365		       b5 de		      lda	highScoreSK,x
   1092  1367		       c9 ff		      cmp	#$ff
   1093  1369		       f0 06		      beq	.noSaveKey
   1094  136b		       9d 9d f7 	      sta	HighScore+RAM_WRITE,x
   1095  136e		       ca		      dex
   1096  136f		       10 f4		      bpl	.loopCopyHighScore
   1097  1371				   .noSaveKey
   1098  1371
   1099  1371							; clear both players scores
   1100  1371		       a0 05		      ldy	#2*3-1
   1101  1373		       a9 00		      lda	#0
   1102  1375				   .loopClearScore
   1103  1375		       99 93 f7 	      sta	ScoreCurrent+RAM_WRITE,y
   1104  1378		       88		      dey
   1105  1379		       10 fa		      bpl	.loopClearScore
   1106  137b
   1107  137b							; copy levelX and level for other player and SaveKey:
   1108  137b		       a5 b1		      lda	levelX
   1109  137d		       8d 9b f7 	      sta	PlayerLevelX+RAM_WRITE
   1110  1380		       a5 e1		      lda	startingLevel
   1111  1382		       8d 96 f7 	      sta	StartLevelX+RAM_WRITE
   1112  1385		       a5 b2		      lda	level
   1113  1387		       8d 9c f7 	      sta	PlayerLevel+RAM_WRITE
   1114  138a		       8d 97 f7 	      sta	StartLevel+RAM_WRITE
   1115  138d
   1116  138d
   1117  138d		       a9 00		      lda	#0
   1118  138f		       8d a2 f3 	      sta	SecondFrac
   1119  1392
   1120  1392		       60		      rts
   1121  1393
   1122  1393							;---------------------------------------------------------------------------
   1123  1393
   1124  1393		       00 00 00    ScoreCurrent ds	3, 0
   1125  1396							; start levelx and level have to be after ScoreCurrent!
   1126  1396		       00	   StartLevelX .byte.b	0
   1127  1397		       00	   StartLevel .byte.b	0
   1128  1398		       00 00 00    PlayerScores ds	3, 0
   1129  139b							; levelx and level have to be consecutive variables!
   1130  139b		       00	   PlayerLevelX .byte.b	0
   1131  139c		       00	   PlayerLevel .byte.b	0
   1132  139d		       00 00 00 00*HighScore  ds	3+2, 0	; two extra bytes to save code
   1133  13a2
   1134  13a2
   1135  13a2		       00	   SecondFrac ds	1
   1136  13a3
      0  13a3					      DEFINE_SUBROUTINE	NotchTime
      1  13a3		       00 02	   BANK_NotchTime =	_CURRENT_BANK
      2  13a3					      SUBROUTINE
      3  13a3				   NotchTime
   1138  13a3
   1139  13a3		       a6 80		      ldx	Platform
   1140  13a5
   1141  13a5		       18		      clc
   1142  13a6		       ad a2 f3 	      lda	SecondFrac
   1143  13a9		       69 01		      adc	#1
   1144  13ab		       dd bc f3 	      cmp	Notch,x
   1145  13ae		       90 08		      bcc	notched
   1146  13b0
   1147  13b0		       a9 00		      lda	#0
   1148  13b2
   1149  13b2		       e6 ce		      inc	seconds
   1150  13b4		       d0 02		      bne	notched
   1151  13b6		       e6 cf		      inc	seconds+1
   1152  13b8
   1153  13b8		       8d a2 f7    notched    sta	SecondFrac + RAM_WRITE
   1154  13bb		       60		      rts
   1155  13bc
   1156  13bc		       39 39 39 32 Notch      .byte.b	57, 57, 57, 50
   1157  13c0
   1158  13c0							;------------------------------------------------------------------------------
   1159  13c0
      0  13c0					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING"
      1  13c0
      2  13c0
      3  13c0		       03 c0	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING (1K) SIZE =  $3c0 , FREE= $40
      4  13c0					      ECHO	"ROM_SHADOW_OF_BANK_SCORING", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  13c0				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  13c0				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  13c0				  -	      ERR
      8  13c0					      endif
   1161  13c0
   1162  13c0							;------------------------------------------------------------------------------
   1163  13c0
   1164  13c0							; LEVEL DATA banks can go anywhere - *EXCEPT* for the same bank as the level
   1165  13c0							; decoder.  Ironic, isn't it?	They calculate a constant -- MAX_LEVEL_SIZE
   1166  13c0							; which is used as a buffer size inside UnpackLevel.  It's not important if
   1167  13c0							; this is defined before or after, as once the levels have processed it will be
   1168  13c0							; correct. Note, that levels should all be defined BEFORE *OR* AFTER the
   1169  13c0							; UnpackLevel code -- but that they should not be both, nor in the same bank.
   1170  13c0							; TODO: verify above is still valid
   1171  13c0
   1172  13c0
      0  13c0					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING -- full 2K"
      1  13c0		       03 c0	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING -- full 2K (2K) SIZE =  $3c0 , FREE= $440
      2  13c0					      ECHO	"ROM_SHADOW_OF_BANK_SCORING -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  13c0				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  13c0				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  13c0				  -	      ERR
      6  13c0					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 3
      0  13c0					      include	"BANK_GENERIC.asm"
      1  13c0							;    Sokoboo - a Sokoban implementation
      2  13c0							;    using a generic tile-based display engine for the Atari 2600
      3  13c0							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  13c0							;
      5  13c0							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  13c0							;
      7  13c0							;    Code related to the generic tile-based display engine was developed by
      8  13c0							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  13c0							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  13c0							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  13c0							;
     12  13c0							;    Code related to music and sound effects uses the TIATracker music player
     13  13c0							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  13c0							;    directory for Apache licensing details.
     15  13c0							;
     16  13c0							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  13c0							;    See the copyright notices in the License directory for a list of level
     18  13c0							;    contributors.
     19  13c0							;
     20  13c0							;    Except where otherwise indicated, this software is released under the
     21  13c0							;    following licensing arrangement...
     22  13c0							;
     23  13c0							;    This program is free software: you can redistribute it and/or modify
     24  13c0							;    it under the terms of the GNU General Public License as published by
     25  13c0							;    the Free Software Foundation, either version 3 of the License, or
     26  13c0							;    (at your option) any later version.
     27  13c0							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  13c0
     29  13c0							;    This program is distributed in the hope that it will be useful,
     30  13c0							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  13c0							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  13c0							;    GNU General Public License for more details.
     33  13c0
     34  13c0							;------------------------------------------------------------------------------
     35  13c0							;##############################################################################
     36  13c0							;------------------------------------------------------------------------------
     37  13c0
      0  13c0					      NEWBANK	GENERIC_BANK_1
      1  1ddf ????				      SEG	GENERIC_BANK_1
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	GENERIC_BANK_1
     39  1800
      0  1800					      DEFINE_1K_SEGMENT	DECODE_LEVEL_SHADOW
      1  1800					      ALIGN	$400
      2  1800				   SEGMENT_DECODE_LEVEL_SHADOW SET	*
      3  1800				   BANK_DECODE_LEVEL_SHADOW SET	_CURRENT_BANK
------- FILE DecodeLevel.asm LEVEL 3 PASS 3
      0  1800					      include	"DecodeLevel.asm"
      1  1800							;    Sokoboo - a Sokoban implementation
      2  1800							;    using a generic tile-based display engine for the Atari 2600
      3  1800							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1800							;
      5  1800							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1800							;
      7  1800							;    Code related to the generic tile-based display engine was developed by
      8  1800							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1800							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1800							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1800							;
     12  1800							;    Code related to music and sound effects uses the TIATracker music player
     13  1800							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1800							;    directory for Apache licensing details.
     15  1800							;
     16  1800							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1800							;    See the copyright notices in the License directory for a list of level
     18  1800							;    contributors.
     19  1800							;
     20  1800							;    Except where otherwise indicated, this software is released under the
     21  1800							;    following licensing arrangement...
     22  1800							;
     23  1800							;    This program is free software: you can redistribute it and/or modify
     24  1800							;    it under the terms of the GNU General Public License as published by
     25  1800							;    the Free Software Foundation, either version 3 of the License, or
     26  1800							;    (at your option) any later version.
     27  1800							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1800
     29  1800							;    This program is distributed in the hope that it will be useful,
     30  1800							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1800							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1800							;    GNU General Public License for more details.
     33  1800
     34  1800
     35  1800
     36  1800				   finX
     37  1800							; now put the soil in - fill from the outsides
     38  1800
     39  1800		       a9 01		      lda	#CHARACTER_SOIL
     40  1802		       85 8b		      sta	POS_Type
     41  1804
     42  1804		       a9 1f		      lda	#SIZE_BOARD_Y-1
     43  1806		       85 88		      sta	POS_Y
     44  1808
     45  1808		       a9 1f	   xlin       lda	#SIZE_BOARD_X-1
     46  180a		       85 87		      sta	POS_X
     47  180c		       20 26 f8    zap1       jsr	GetBoardCharacter__CALL_FROM_RAM__
     48  180f		       c9 01		      cmp	#CHARACTER_SOIL
     49  1811		       f0 07		      beq	kg2a
     50  1813		       c9 00		      cmp	#0
     51  1815		       d0 07		      bne	endzap1
     52  1817		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
     53  181a		       c6 87	   kg2a       dec	POS_X
     54  181c		       10 ee		      bpl	zap1
     55  181e
     56  181e		       a9 00	   endzap1    lda	#0
     57  1820		       85 87		      sta	POS_X
     58  1822		       20 26 f8    zap2       jsr	GetBoardCharacter__CALL_FROM_RAM__
     59  1825		       c9 01		      cmp	#CHARACTER_SOIL
     60  1827		       f0 07		      beq	kg2
     61  1829		       c9 00		      cmp	#0
     62  182b		       d0 0b		      bne	endzap2
     63  182d		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
     64  1830		       e6 87	   kg2	      inc	POS_X
     65  1832		       a5 87		      lda	POS_X
     66  1834		       c9 20		      cmp	#SIZE_BOARD_X
     67  1836		       d0 ea		      bne	zap2
     68  1838
     69  1838		       c6 88	   endzap2    dec	POS_Y
     70  183a		       10 cc		      bpl	xlin
     71  183c
     72  183c
     73  183c		       a9 1f		      lda	#SIZE_BOARD_X-1
     74  183e		       85 87		      sta	POS_X
     75  1840
     76  1840		       a9 1f	   ylin       lda	#SIZE_BOARD_Y-1
     77  1842		       85 88		      sta	POS_Y
     78  1844		       20 26 f8    zapy1      jsr	GetBoardCharacter__CALL_FROM_RAM__
     79  1847		       c9 01		      cmp	#CHARACTER_SOIL
     80  1849		       f0 07		      beq	kg3
     81  184b		       c9 00		      cmp	#0
     82  184d		       d0 07		      bne	endzapy1
     83  184f		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
     84  1852		       c6 88	   kg3	      dec	POS_Y
     85  1854		       10 ee		      bpl	zapy1
     86  1856
     87  1856		       a9 00	   endzapy1   lda	#0
     88  1858		       85 88		      sta	POS_Y
     89  185a		       20 26 f8    zapy2      jsr	GetBoardCharacter__CALL_FROM_RAM__
     90  185d		       c9 01		      cmp	#CHARACTER_SOIL
     91  185f		       f0 07		      beq	kg3b
     92  1861		       c9 00		      cmp	#0
     93  1863		       d0 0b		      bne	endzapy2
     94  1865		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
     95  1868		       e6 88	   kg3b       inc	POS_Y
     96  186a		       a5 88		      lda	POS_Y
     97  186c		       c9 20		      cmp	#SIZE_BOARD_Y
     98  186e		       d0 ea		      bne	zapy2
     99  1870
    100  1870		       c6 87	   endzapy2   dec	POS_X
    101  1872		       10 cc		      bpl	ylin
    102  1874		       60		      rts
    103  1875
    104  1875							;A	 steel wall
    105  1875							;B	 soil (surround)
    106  1875							;C	 box
    107  1875
    108  1875					      MAC	ntscpal
    109  1875					      .byte	{1}+{2}
    110  1875					      NTSC_TO_PAL	{1},{2}
    111  1875					      ENDM		; {col} {intensity}
    112  1875
    113  1875
    114  1875
    115  1875				   t16
    116  1875		       00		      .byte.b	$00
    117  1876		       20		      .byte.b	$20	; don't use "10"!
    118  1877		       20		      .byte.b	$20
    119  1878		       30		      .byte.b	$30
    120  1879		       40		      .byte.b	$40
    121  187a		       50		      .byte.b	$50
    122  187b		       60		      .byte.b	$60
    123  187c		       70		      .byte.b	$70
    124  187d		       80		      .byte.b	$80
    125  187e		       90		      .byte.b	$90
    126  187f		       a0		      .byte.b	$A0
    127  1880		       b0		      .byte.b	$B0
    128  1881		       c0		      .byte.b	$C0
    129  1882		       d0		      .byte.b	$D0
    130  1883		       e0		      .byte.b	$E0
    131  1884		       f0		      .byte.b	$F0
    132  1885
    133  1885				   inten
    134  1885		       0a		      .byte.b	$08+PALETTE_INTENSITY_ADJUST
    135  1886		       0c		      .byte.b	$0A+PALETTE_INTENSITY_ADJUST
    136  1887		       0c		      .byte.b	$0A+PALETTE_INTENSITY_ADJUST
    137  1888		       0a		      .byte.b	$08+PALETTE_INTENSITY_ADJUST
    138  1889		       0a		      .byte.b	$08+PALETTE_INTENSITY_ADJUST
    139  188a		       0a		      .byte.b	$08+PALETTE_INTENSITY_ADJUST
    140  188b		       0c		      .byte.b	$0A+PALETTE_INTENSITY_ADJUST
    141  188c		       0c		      .byte.b	$0A+PALETTE_INTENSITY_ADJUST
    142  188d		       0c		      .byte.b	$0A+PALETTE_INTENSITY_ADJUST	; deep blue
    143  188e		       0c		      .byte.b	$0A+PALETTE_INTENSITY_ADJUST
    144  188f		       0a		      .byte.b	$08+PALETTE_INTENSITY_ADJUST
    145  1890		       0a		      .byte.b	$08+PALETTE_INTENSITY_ADJUST
    146  1891		       0a		      .byte.b	$08+PALETTE_INTENSITY_ADJUST
    147  1892		       0c		      .byte.b	$0A+PALETTE_INTENSITY_ADJUST
    148  1893		       0c		      .byte.b	$0A+PALETTE_INTENSITY_ADJUST
    149  1894		       0c		      .byte.b	$0A+PALETTE_INTENSITY_ADJUST
    150  1895
    151  1895
    152  1895
      0  1895					      DEFINE_SUBROUTINE	UnpackLevel
      1  1895		       00 03	   BANK_UnpackLevel =	_CURRENT_BANK
      2  1895					      SUBROUTINE
      3  1895				   UnpackLevel
    154  1895
    155  1895		       85 bf		      sta	RAM_Bank
    156  1897
    157  1897							; has to be done before decoding the level to have the platform right:
    158  1897							;	    SET_PLATFORM
    159  1897
    160  1897		       a9 03		      lda	#BANK_UnpackLevel	; the *ROM* bank of this routine (NOT RAM)
    161  1899		       85 be		      sta	ROM_Bank	; GetROMByte returns to this bank
    162  189b
    163  189b
    164  189b
    165  189b		       a9 01		      lda	#CHARACTER_SOIL
    166  189d		       85 8b		      sta	POS_Type
    167  189f
    168  189f		       a9 1f		      lda	#SIZE_BOARD_Y-1
    169  18a1		       85 88		      sta	POS_Y
    170  18a3		       a9 1f	   xyLine     lda	#SIZE_BOARD_X-1
    171  18a5		       85 87		      sta	POS_X
    172  18a7		       20 3a f8    xyClear    jsr	PutBoardCharacterFromRAM
    173  18aa		       c6 87		      dec	POS_X
    174  18ac		       10 f9		      bpl	xyClear
    175  18ae		       c6 88		      dec	POS_Y
    176  18b0		       10 f1		      bpl	xyLine
    177  18b2
    178  18b2		       a9 04		      lda	#4
    179  18b4		       85 db		      sta	base_x
    180  18b6		       a9 04		      lda	#4
    181  18b8		       85 dc		      sta	base_y
    182  18ba
    183  18ba		       a5 c1		      lda	NextLevelTrigger
    184  18bc		       09 80		      ora	#BIT_NEXTLEVEL
    185  18be		       85 c1		      sta	NextLevelTrigger
    186  18c0
    187  18c0
    188  18c0		       20 52 fd 	      jsr	Random
    189  18c3		       29 0f		      and	#$F
    190  18c5		       aa		      tax
    191  18c6		       bd 75 f0 	      lda	t16,x
    192  18c9		       1d 85 f0 	      ora	inten,x
    193  18cc		       85 c8		      sta	icc_colour
    194  18ce
    195  18ce		       20 52 fd    ranother   jsr	Random
    196  18d1		       29 0f		      and	#$F
    197  18d3		       aa		      tax
    198  18d4		       bd 75 f0 	      lda	t16,x
    199  18d7		       1d 85 f0 	      ora	inten,x
    200  18da		       38		      sec
    201  18db		       e9 02		      sbc	#2
    202  18dd		       85 ca		      sta	icc_colour+2	; mortar, lid
    203  18df
    204  18df							;sec
    205  18df		       e5 c8		      sbc	icc_colour
    206  18e1		       b0 04		      bcs	posicc
    207  18e3		       49 ff		      eor	#$FF
    208  18e5		       69 01		      adc	#1
    209  18e7		       c9 31	   posicc     cmp	#$31
    210  18e9		       90 e3		      bcc	ranother	; don't allow similar colours
    211  18eb
    212  18eb
    213  18eb
    214  18eb							; Update the level colours (self-modifying) in each of the character line banks
    215  18eb
    216  18eb		       20 18 fe 	      jsr	CopyColoursToScreenLines
    217  18ee
    218  18ee		       a9 00		      lda	#$00
    219  18f0		       85 b5		      sta	BCD_moveCounter
    220  18f2		       85 b6		      sta	BCD_moveCounterHi
    221  18f4		       85 b7		      sta	takebackIndex
    222  18f6		       85 b8		      sta	takebackBaseIndex
    223  18f8		       85 b4		      sta	BCD_targetsRequired	; # of targets that do NOT have boxes on them
    224  18fa
    225  18fa							;		ldx Platform
    226  18fa							;		lda theThrottler,x
    227  18fa							;		sta ThrottleSpeed
    228  18fa
    229  18fa							; first fill bg with character_soil
    230  18fa							; then rle unpack level
    231  18fa							; change level colours
    232  18fa
    233  18fa		       a9 00		      lda	#0
    234  18fc		       85 87		      sta	POS_X
    235  18fe		       85 88		      sta	POS_Y
    236  1900		       85 94		      sta	BoardLimit_Width
    237  1902		       85 95		      sta	BoardLimit_Height
    238  1904
    239  1904				   GetNextItem
    240  1904
    241  1904		       a9 01		      lda	#1
    242  1906		       85 dd		      sta	upk_length
    243  1908		       a9 00		      lda	#0
    244  190a		       85 de		      sta	upk_column	; reuse var - this flags a digit already
    245  190c
    246  190c		       e6 ba	   Get2       inc	Board_AddressR
    247  190e		       d0 02		      bne	addrOK
    248  1910		       e6 bb		      inc	Board_AddressR+1
    249  1912				   addrOK
    250  1912
    251  1912		       a5 ab		      lda	LEVEL_bank
    252  1914		       a0 00		      ldy	#0
    253  1916		       20 0f f8 	      jsr	GetROMByte
    254  1919		       85 df		      sta	upk_temp	;scratch
    255  191b
    256  191b		       c9 00		      cmp	#0
    257  191d		       d0 03		      bne	parse
    258  191f		       4c 00 f0 	      jmp	finX
    259  1922				   parse
    260  1922		       c9 3a		      cmp	#"9"+1
    261  1924		       b0 1e		      bcs	notDigit
    262  1926		       c9 30		      cmp	#"0"
    263  1928		       90 1a		      bcc	notDigit
    264  192a
    265  192a		       a5 de		      lda	upk_column
    266  192c		       f0 09		      beq	firstDig
    267  192e
    268  192e		       a5 dd		      lda	upk_length
    269  1930		       0a		      asl
    270  1931		       0a		      asl
    271  1932		       0a		      asl
    272  1933		       65 dd		      adc	upk_length
    273  1935		       65 dd		      adc	upk_length
    274  1937
    275  1937		       18	   firstDig   clc
    276  1938		       65 df		      adc	upk_temp
    277  193a		       38		      sec
    278  193b		       e9 30		      sbc	#"0"
    279  193d		       85 dd		      sta	upk_length
    280  193f		       e6 de		      inc	upk_column	; flag we have seen a digit
    281  1941		       4c 0c f1 	      jmp	Get2
    282  1944
    283  1944		       c9 7c	   notDigit   cmp	#"|"	; newline
    284  1946		       d0 11		      bne	checkWall
    285  1948
    286  1948							; Handle new-line
    287  1948		       a9 00		      lda	#0
    288  194a		       85 87		      sta	POS_X
    289  194c		       e6 88		      inc	POS_Y
    290  194e
    291  194e
    292  194e		       a5 88		      lda	POS_Y
    293  1950		       c5 95		      cmp	BoardLimit_Height
    294  1952		       90 02		      bcc	wOK2
    295  1954		       85 95		      sta	BoardLimit_Height	;???^^^
    296  1956				   wOK2
    297  1956
    298  1956		       4c 04 f1 	      jmp	GetNextItem
    299  1959
    300  1959		       c9 23	   checkWall  cmp	#"#"	; wall
    301  195b		       d0 09		      bne	checkForGap
    302  195d
    303  195d		       a5 c7		      lda	rnd
    304  195f		       29 03		      and	#3
    305  1961		       18		      clc
    306  1962		       69 06		      adc	#CHARACTER_STEEL
    307  1964		       d0 62		      bne	WriteChars
    308  1966
    309  1966		       c9 20	   checkForGap cmp	#32
    310  1968		       f0 08		      beq	writeGap
    311  196a		       c9 2d		      cmp	#"-"
    312  196c		       f0 04		      beq	writeGap
    313  196e		       c9 5f		      cmp	#"_"
    314  1970		       d0 05		      bne	checkForMan
    315  1972
    316  1972		       a9 00	   writeGap   lda	#CHARACTER_BLANK
    317  1974		       4c c8 f1 	      jmp	WriteChars
    318  1977
    319  1977				   checkForMan
    320  1977		       c9 2b		      cmp	#"+"	; player on goal square
    321  1979		       d0 07		      bne	notPlayerGoal
    322  197b
    323  197b		       20 3e fd 	      jsr	RegisterTarget
    324  197e
    325  197e							; put goal square, init player with POS_VAR = CHARACTER_TARGET
    326  197e
    327  197e		       a9 03		      lda	#CHARACTER_TARGET
    328  1980		       d0 06		      bne	genPlayer
    329  1982
    330  1982				   notPlayerGoal
    331  1982		       c9 40		      cmp	#"@"	; player on normal square
    332  1984		       d0 29		      bne	checkBox
    333  1986
    334  1986		       a9 00		      lda	#CHARACTER_BLANK
    335  1988
    336  1988				   genPlayer
    337  1988
    338  1988		       85 8c		      sta	POS_VAR	; character man is on
    339  198a
    340  198a		       18		      clc
    341  198b		       a5 87		      lda	POS_X
    342  198d		       48		      pha
    343  198e		       65 db		      adc	base_x
    344  1990		       85 87		      sta	POS_X
    345  1992		       85 9d		      sta	ManX
    346  1994
    347  1994		       a5 88		      lda	POS_Y
    348  1996		       48		      pha
    349  1997		       65 dc		      adc	base_y
    350  1999		       85 88		      sta	POS_Y
    351  199b		       85 9e		      sta	ManY
    352  199d
    353  199d							; POS_X     x position
    354  199d							; POS_Y     y position
    355  199d							; POS_VAR   CHARACTER UNDER MAN TO RESTORE
    356  199d							; POS_Type  type of object
    357  199d
    358  199d		       a9 00		      lda	#TYPE_MAN
    359  199f		       85 8b		      sta	POS_Type	;	 creature TYPE
    360  19a1		       20 ff f8 	      jsr	InsertObjectStackFromRAM	;6+94(B)
    361  19a4
    362  19a4		       68		      pla
    363  19a5		       85 88		      sta	POS_Y
    364  19a7		       68		      pla
    365  19a8		       85 87		      sta	POS_X
    366  19aa
    367  19aa		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    368  19ac		       4c c8 f1 	      jmp	WriteChars
    369  19af
    370  19af		       c9 24	   checkBox   cmp	#"$"
    371  19b1		       d0 04		      bne	checkBoxTarget
    372  19b3
    373  19b3		       a9 02		      lda	#CHARACTER_BOX
    374  19b5		       d0 11		      bne	WriteChars
    375  19b7
    376  19b7		       c9 2a	   checkBoxTarget cmp	#"*"
    377  19b9		       d0 04		      bne	checkTarget
    378  19bb
    379  19bb		       a9 0a		      lda	#CHARACTER_BOX_ON_TARGET
    380  19bd		       d0 09		      bne	WriteChars
    381  19bf
    382  19bf		       c9 2e	   checkTarget cmp	#"."
    383  19c1		       f0 03		      beq	targ
    384  19c3		       4c 04 f1 	      jmp	GetNextItem
    385  19c6				   targ
    386  19c6
    387  19c6		       a9 03		      lda	#CHARACTER_TARGET
    388  19c8
    389  19c8		       85 8b	   WriteChars sta	POS_Type
    390  19ca
    391  19ca		       18	   Wc2x       clc
    392  19cb		       a5 87		      lda	POS_X
    393  19cd		       48		      pha
    394  19ce		       65 db		      adc	base_x
    395  19d0		       85 87		      sta	POS_X
    396  19d2
    397  19d2		       a5 88		      lda	POS_Y
    398  19d4		       48		      pha
    399  19d5		       65 dc		      adc	base_y
    400  19d7		       c9 20		      cmp	#SIZE_BOARD_Y
    401  19d9		       b0 05		      bcs	whoops
    402  19db		       85 88		      sta	POS_Y
    403  19dd
    404  19dd
    405  19dd		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    406  19e0
    407  19e0		       a5 8b	   whoops     lda	POS_Type
    408  19e2		       c9 03		      cmp	#CHARACTER_TARGET
    409  19e4		       d0 03		      bne	notargdet
    410  19e6		       20 3e fd 	      jsr	RegisterTarget
    411  19e9				   notargdet
    412  19e9
    413  19e9		       68		      pla
    414  19ea		       85 88		      sta	POS_Y
    415  19ec		       68		      pla
    416  19ed		       85 87		      sta	POS_X
    417  19ef
    418  19ef		       18		      clc
    419  19f0		       69 01		      adc	#1
    420  19f2		       85 87		      sta	POS_X
    421  19f4
    422  19f4		       c5 94		      cmp	BoardLimit_Width
    423  19f6		       90 02		      bcc	wOK
    424  19f8		       85 94		      sta	BoardLimit_Width
    425  19fa				   wOK
    426  19fa
    427  19fa		       c6 dd		      dec	upk_length
    428  19fc		       d0 cc		      bne	Wc2x
    429  19fe		       4c 04 f1 	      jmp	GetNextItem
    430  1a01
    431  1a01				   finishedUnpack
    432  1a01
    433  1a01		       60		      rts
    434  1a01					      endif
------- FILE BANK_GENERIC.asm
     42  1a02
      0  1a02					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1 (DECODE_LEVEL)"
      1  1a02
      2  1a02
      3  1a02		       02 02	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (DECODE_LEVEL) (1K) SIZE =  $202 , FREE= $1fe
      4  1a02					      ECHO	"GENERIC_BANK_1 (DECODE_LEVEL)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1a02				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  1a02				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1a02				  -	      ERR
      8  1a02					      endif
     44  1a02
     45  1a02							;------------------------------------------------------------------------------
     46  1a02							; ... the above is a RAM-copied section -- the following is ROM-only.	Note that
     47  1a02							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     48  1a02							; bank finishes.  Just continue on from where it left off...
     49  1a02							;------------------------------------------------------------------------------
     50  1a02
      0  1a02					      DEFINE_SUBROUTINE	Cart_Init	; in GENERIC_BANK_1
      1  1a02		       00 03	   BANK_Cart_Init =	_CURRENT_BANK
      2  1a02					      SUBROUTINE
      3  1a02				   Cart_Init
     52  1a02
     53  1a02							; Note the variables from the title selection are incredibly transient an can be stomped
     54  1a02							; at any time.  So they need to be used immediately.
     55  1a02
     56  1a02
     57  1a02							; odd usage below is to prevent any possibility of variable stomping/assumptions
     58  1a02
     59  1a02		       a9 01		      lda	#1
     60  1a04		       a2 00		      ldx	#0	;sLevel				      ; level # from title select
     61  1a06		       a0 00		      ldy	#0	;sJoysticks
     62  1a08		       84 aa		      sty	jtoggle
     63  1a0a		       86 b2		      stx	level
     64  1a0c		       a9 00		      lda	#0
     65  1a0e		       85 e1		      sta	startingLevel
     66  1a10
     67  1a10		       85 b1		      sta	levelX
     68  1a12							;		  sta levelX+1
     69  1a12
      0  1a12					      LOAD_ANIMATION	IDLE
      1  1a12		       a9 4a		      lda	#<Animation_IDLE
      2  1a14		       85 9a		      sta	animation
      3  1a16		       a9 f0		      lda	#>Animation_IDLE
      4  1a18		       85 9b		      sta	animation+1
      5  1a1a		       a9 00		      lda	#0
      6  1a1c		       85 9c		      sta	animation_delay
      7  1a1e		       a9 02		      lda	#ANIMATION_IDLE_ID
      8  1a20		       85 a6		      sta	ManAnimationID
     71  1a22
     72  1a22		       a9 00		      lda	#0
     73  1a24		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     74  1a27		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     75  1a2a		       85 6b		      sta	HMCLR
     76  1a2c
     77  1a2c							; cleanup remains of title screen
     78  1a2c		       85 5b		      sta	GRP0
     79  1a2e		       85 5c		      sta	GRP1
     80  1a30							;?		   sta GRP0
     81  1a30
     82  1a30		       a9 10		      lda	#%00010000	; 2	 double width missile, double width player
     83  1a32		       85 44		      sta	NUSIZ0	; 3
     84  1a34		       85 45		      sta	NUSIZ1
     85  1a36
     86  1a36		       85 86		      sta	ScreenDrawPhase	; sequences the sections of gameplay/screen drawing
     87  1a38		       85 c4		      sta	ethnic
     88  1a3a
     89  1a3a		       a9 04		      lda	#%100	; players/missiles BEHIND BG
     90  1a3c		       85 4a		      sta	CTRLPF
     91  1a3e
     92  1a3e		       a9 ff		      lda	#$FF
     93  1a40		       85 81		      sta	DrawStackPointer
     94  1a42		       85 92		      sta	BufferedJoystick
     95  1a44
     96  1a44							;lda #DIRECTION_BITS		  ;???
     97  1a44							;sta ManLastDirection
     98  1a44
     99  1a44							;lda #0
    100  1a44							;		  sta ObjStackPtr		  ; object stack index of last entry
    101  1a44							;		  sta ObjStackPtr+1
    102  1a44							;		  sta ObjStackNum
    103  1a44							;		  sta ObjIterator
    104  1a44
    105  1a44							;sta sortPtr
    106  1a44							;lda #<(-1)
    107  1a44							;sta sortRequired
    108  1a44
    109  1a44							; read high score from SaveKey and store in highScoreSK,
    110  1a44							; which is transferred to high score variable in RAM by GeneralScoringSetups
    111  1a44
    112  1a44		       4c db f3 	      jmp	ReadSaveKey
    113  1a47
    114  1a47							;------------------------------------------------------------------------------
    115  1a47
      0  1a47					      DEFINE_SUBROUTINE	SwapPlayersGeneric
      1  1a47		       00 03	   BANK_SwapPlayersGeneric =	_CURRENT_BANK
      2  1a47					      SUBROUTINE
      3  1a47				   SwapPlayersGeneric
    117  1a47
    118  1a47							; at the start of a level (or player, doesn't matter) we grab the current state of the colour/B&W switch
    119  1a47							; into the gameMode variable.
    120  1a47
    121  1a47							;		  lda gameMode
    122  1a47							;		  and #~(BW_SWITCH|GAMEMODE_PAUSED)
    123  1a47							;		  sta gameMode
    124  1a47							;		  lda SWCHB
    125  1a47							;		  and #BW_SWITCH
    126  1a47							;		  ora gameMode			  ; COLOR/B&W @start of level stored in gameMode -- so now we just detect a CHANGE is pause
    127  1a47							;		  sta gameMode			  ; also, BIT7=0 -- system is NOT paused
    128  1a47
    129  1a47
    130  1a47							; restart level
    131  1a47		       a5 c1		      lda	NextLevelTrigger
    132  1a49		       29 bf		      and	#<(~BIT_NEXTLIFE)
    133  1a4b		       85 c1		      sta	NextLevelTrigger
    134  1a4d
    135  1a4d							; if new high score was set by SwapPlayers, update it:
    136  1a4d
    137  1a4d		       4c 01 f4 	      jmp	WriteSaveKey
    138  1a50
    139  1a50
    140  1a50							;------------------------------------------------------------------------------
    141  1a50
      0  1a50					      DEFINE_SUBROUTINE	CreateCreatures
      1  1a50		       00 03	   BANK_CreateCreatures =	_CURRENT_BANK
      2  1a50					      SUBROUTINE
      3  1a50				   CreateCreatures
    143  1a50
    144  1a50							; Calculate rightmost value for scrolling edge.  .
    145  1a50
    146  1a50		       85 be		      sta	ROM_Bank
    147  1a52
    148  1a52		       38		      sec
    149  1a53		       a5 94		      lda	BoardLimit_Width
    150  1a55		       e9 09		      sbc	#SCREEN_WIDTH-1
    151  1a57		       85 94		      sta	BoardEdge_Right	; absolute rightmost scroll value
    152  1a59
    153  1a59							;		  sec			     already set
    154  1a59		       a5 95		      lda	BoardLimit_Height
    155  1a5b		       e9 07		      sbc	#SCREEN_LINES-1
    156  1a5d		       85 95		      sta	BoardEdge_Bottom	; absolute bottommost scroll value
    157  1a5f
    158  1a5f							; kludge position scroll roughly at player
    159  1a5f
    160  1a5f							;		  sec			 already set
    161  1a5f		       a5 9d		      lda	ManX
    162  1a61		       e9 05		      sbc	#5
    163  1a63		       b0 02		      bcs	notL0
    164  1a65		       a9 00		      lda	#0
    165  1a67		       85 97	   notL0      sta	BoardScrollX
    166  1a69
    167  1a69		       38		      sec
    168  1a6a		       a5 9e		      lda	ManY
    169  1a6c		       e9 04		      sbc	#4
    170  1a6e		       b0 02		      bcs	notU0
    171  1a70		       a9 00		      lda	#0
    172  1a72		       85 96	   notU0      sta	BoardScrollY
    173  1a74
    174  1a74		       a9 00		      lda	#0
    175  1a76		       85 a1		      sta	ManMode
    176  1a78							;sta ManDelayCount
    177  1a78		       85 b9		      sta	TakebackInhibit
    178  1a7a		       85 db		      sta	base_x
    179  1a7c		       85 dc		      sta	base_y
    180  1a7e		       85 a4		      sta	ManPushCounter
    181  1a80
    182  1a80
    183  1a80		       a9 ff		      lda	#$FF
    184  1a82		       85 af		      sta	LastSpriteY
    185  1a84		       85 a6		      sta	ManAnimationID
    186  1a86		       85 cb		      sta	FadeComplete	; start fading
    187  1a88		       85 cc		      sta	FadeOutComplete	; flags "not fading out"
    188  1a8a
    189  1a8a		       a9 14		      lda	#20
    190  1a8c		       85 cd		      sta	fadeslow
    191  1a8e
    192  1a8e							;lda #DIRECTION_BITS		  ;????
    193  1a8e							;sta ManLastDirection		  ; duplicate?
    194  1a8e
    195  1a8e		       60		      rts
    196  1a8f
    197  1a8f							;-------------------------------------------------------------------------------------
    198  1a8f
      0  1a8f					      DEFINE_SUBROUTINE	LevelInit	; in GENERIC_BANK_1
      1  1a8f		       00 03	   BANK_LevelInit =	_CURRENT_BANK
      2  1a8f					      SUBROUTINE
      3  1a8f				   LevelInit
    200  1a8f
    201  1a8f		       a9 00		      lda	#0
    202  1a91		       85 83		      sta	ObjStackPtr
    203  1a93		       85 84		      sta	ObjStackPtr+1	; kill all creatures
    204  1a95		       85 82		      sta	ObjStackNum
    205  1a97		       85 c2		      sta	ObjIterator
    206  1a99
    207  1a99		       85 98		      sta	scrollBits
    208  1a9b		       85 86		      sta	ScreenDrawPhase
    209  1a9d
    210  1a9d		       85 b0		      sta	BGColour
    211  1a9f		       85 c0		      sta	ColourTimer
    212  1aa1		       85 a5		      sta	LookingAround
    213  1aa3
    214  1aa3		       a9 ff		      lda	#255
    215  1aa5		       85 b3		      sta	Throttle
    216  1aa7		       85 92		      sta	BufferedJoystick
    217  1aa9
    218  1aa9		       a9 00		      lda	#0
    219  1aab		       85 59		      sta	AUDV0
    220  1aad		       85 5a		      sta	AUDV1	; turn off music while levels init
    221  1aaf							;		  sta AUDC0
    222  1aaf
    223  1aaf							;		  sta VBLANK
    224  1aaf
    225  1aaf
    226  1aaf		       85 81		      sta	DrawStackPointer
    227  1ab1
    228  1ab1							;lda #DISPLAY_TIME ;DISPLAY_SCORE
    229  1ab1							;sta scoringFlags
    230  1ab1							;lda #0 ;SCORING_TIMER_FIRST		      ; We want the first timer display to be long, to show level and lives
    231  1ab1							;sta scoringTimer
    232  1ab1
    233  1ab1		       18		      clc
    234  1ab2		       a5 c4		      lda	ethnic
    235  1ab4		       69 10		      adc	#16
    236  1ab6		       c9 40		      cmp	#4*16
    237  1ab8		       90 02		      bcc	ethOK
    238  1aba		       a9 00		      lda	#0
    239  1abc		       85 c4	   ethOK      sta	ethnic
    240  1abe
    241  1abe		       60		      rts
    242  1abf
    243  1abf							;-------------------------------------------------------------------------------------
    244  1abf
      0  1abf					      DEFINE_SUBROUTINE	Resync
      1  1abf		       00 03	   BANK_Resync =	_CURRENT_BANK
      2  1abf					      SUBROUTINE
      3  1abf				   Resync
      0  1abf					      RESYNC
      1  1abf
      2  1abf		       a9 02		      lda	#%10
      3  1ac1		       85 41		      sta	VBLANK
      4  1ac3
      5  1ac3		       a2 08		      ldx	#8
      6  1ac5				   .loopResync
      0  1ac5					      VERTICAL_SYNC
      1  1ac5		       a9 0e		      lda	#%1110
      2  1ac7		       85 42	   .VSLP1     sta	WSYNC
      3  1ac9		       85 40		      sta	VSYNC
      4  1acb		       4a		      lsr
      5  1acc		       d0 f9		      bne	.VSLP1
      8  1ace
      9  1ace		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  1ad0		       a5 80		      lda	Platform
     11  1ad2		       49 02		      eor	#PAL_50
     12  1ad4		       d0 02		      bne	.ntsc
     13  1ad6		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  1ad8				   .ntsc
     15  1ad8				   .loopWait
     16  1ad8		       85 42		      sta	WSYNC
     17  1ada		       85 42		      sta	WSYNC
     18  1adc		       88		      dey
     19  1add		       d0 f9		      bne	.loopWait
     20  1adf		       ca		      dex
     21  1ae0		       d0 e3		      bne	.loopResync
    247  1ae2		       60	   Ret	      rts
    248  1ae3
    249  1ae3							;---------------------------------------------------------------------------
    250  1ae3
      0  1ae3					      DEFINE_SUBROUTINE	TrackPlayer	; =76
      1  1ae3		       00 03	   BANK_TrackPlayer =	_CURRENT_BANK
      2  1ae3					      SUBROUTINE
      3  1ae3				   TrackPlayer
    252  1ae3
    253  1ae3		       a5 a5		      lda	LookingAround	; 3
    254  1ae5		       d0 36		      bne	EarlyAbortx	; 2/3	     don't track when looking around
    255  1ae7
    256  1ae7		       00 02	   .SCRL_START_LEFT =	2
    257  1ae7		       00 08	   .SCRL_START_RIGHT =	SCREEN_WIDTH-.SCRL_START_LEFT
    258  1ae7		       00 02	   .SCRL_START_UP =	2
    259  1ae7		       00 06	   .SCRL_START_DOWN =	SCREEN_LINES-.SCRL_START_UP
    260  1ae7
    261  1ae7		       a5 9d		      lda	ManX	; 3
    262  1ae9		       38		      sec		; 2
    263  1aea		       e5 97		      sbc	BoardScrollX	; 3
    264  1aec		       a8		      tay		; 2 = 10	  for later use
    265  1aed
    266  1aed		       a9 ff		      lda	#-1	; 2
    267  1aef		       c0 02		      cpy	#.SCRL_START_LEFT	; 2
    268  1af1		       30 06		      bmi	.startXScroll	; 2/3
    269  1af3		       c0 08		      cpy	#.SCRL_START_RIGHT	; 2
    270  1af5		       30 0b		      bmi	.skipXScroll	; 2/3
    271  1af7		       a9 01		      lda	#1	; 2 = 12
    272  1af9
    273  1af9		       18	   .startXScroll clc		; 2
    274  1afa		       65 97		      adc	BoardScrollX	; 3
    275  1afc		       c5 94		      cmp	BoardEdge_Right	; 3
    276  1afe		       b0 02		      bcs	.skipXScroll	; 2/3
    277  1b00		       85 97		      sta	BoardScrollX	; 3 = 13
    278  1b02
    279  1b02				   .skipXScroll
    280  1b02
    281  1b02							; = 35 worst
    282  1b02
    283  1b02		       a5 9e		      lda	ManY	; 3
    284  1b04		       38		      sec		; 2
    285  1b05		       e5 96		      sbc	BoardScrollY	; 3
    286  1b07		       a8		      tay		; 2 = 10	  for later use
    287  1b08
    288  1b08		       a9 ff		      lda	#-1	; 2
    289  1b0a		       c0 02		      cpy	#.SCRL_START_UP	; 2
    290  1b0c		       30 06		      bmi	.startYScroll	; 2/3
    291  1b0e		       c0 06		      cpy	#.SCRL_START_DOWN	; 2
    292  1b10		       30 0b		      bmi	.skipYScroll	; 2/3
    293  1b12		       a9 01		      lda	#1	; 2 = 12
    294  1b14
    295  1b14		       18	   .startYScroll clc		; 2
    296  1b15		       65 96		      adc	BoardScrollY	; 3
    297  1b17		       c5 95		      cmp	BoardEdge_Bottom	; 3
    298  1b19		       b0 02		      bcs	.skipYScroll	; 2/3
    299  1b1b		       85 96		      sta	BoardScrollY	; 3 = 13
    300  1b1d
    301  1b1d				   .skipYScroll
    302  1b1d
    303  1b1d							; = 35 worst
    304  1b1d
    305  1b1d		       60	   EarlyAbortx rts		; 6 =	6
    306  1b1e
    307  1b1e
    308  1b1e							;------------------------------------------------------------------------------
    309  1b1e
    310  1b1e							; This is a GOOD home for these tables.
    311  1b1e
      0  1b1e					      DEFINE_SUBROUTINE	TS_PhaseVectorLO
      1  1b1e		       00 03	   BANK_TS_PhaseVectorLO =	_CURRENT_BANK
      2  1b1e					      SUBROUTINE
      3  1b1e				   TS_PhaseVectorLO
    313  1b1e
    314  1b1e							; Gives LO byte of addresses of subroutines for timeslice processing
    315  1b1e							; note +31✅ cycles at start of the function called
    316  1b1e
    317  1b1e		       58		      .byte.b	<ProcessObjStack	; abort = 46✅
    318  1b1f		       5d		      .byte.b	<DrawFullScreen	; abort = 46✅
    319  1b20		       b4		      .byte.b	<BuildDrawStack	; abort = 54✅
    320  1b21		       bb		      .byte.b	<DrawAIntoStack	; abort = 54✅
    321  1b22		       91		      .byte.b	<SwitchObjects	; abort = 46✅
    322  1b23
    323  1b23				   TS_PhaseVectorHI
    324  1b23
    325  1b23							; Gives HI byte of addresses of subroutines for timeslice processing
    326  1b23
    327  1b23		       f8		      .byte.b	>ProcessObjStack
    328  1b24		       f3		      .byte.b	>DrawFullScreen
    329  1b25		       fb		      .byte.b	>BuildDrawStack
    330  1b26		       fb		      .byte.b	>DrawAIntoStack
    331  1b27		       f8		      .byte.b	>SwitchObjects
    332  1b28
    333  1b28				   TS_PhaseBank
    334  1b28
    335  1b28							; Gives bank of subroutines for timeslice processing
    336  1b28
    337  1b28		       0f		      .byte.b	BANK_ProcessObjStack
    338  1b29		       0a		      .byte.b	BANK_DrawFullScreen
    339  1b2a		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack
    340  1b2b		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack2
    341  1b2c		       0f		      .byte.b	BANK_SwitchObjects
    342  1b2d
    343  1b2d							;------------------------------------------------------------------------------
    344  1b2d
    345  1b2d				   OverscanTime
    346  1b2d		       23 23		      .byte.b	OVERSCAN_TIM_NTSC, OVERSCAN_TIM_NTSC
    347  1b2f		       29 23		      .byte.b	OVERSCAN_TIM_PAL, OVERSCAN_TIM_NTSC
    348  1b31
    349  1b31
    350  1b31		       00 12	   THROT_BASE =	18
    351  1b31				   theThrottler
    352  1b31		       12 12 15 12	      .byte.b	THROT_BASE, THROT_BASE, THROT_BASE*60/50, THROT_BASE
    353  1b35
      0  1b35					      DEFINE_SUBROUTINE	PostScreenCleanup
      1  1b35		       00 03	   BANK_PostScreenCleanup =	_CURRENT_BANK
      2  1b35					      SUBROUTINE
      3  1b35				   PostScreenCleanup
    355  1b35
    356  1b35		       c8		      iny		; --> 0
    357  1b36
    358  1b36		       84 49		      sty	COLUBK	; starts colour change bottom score area, wraps to top score area
    359  1b38							; + moved here so we don't see a minor colour artefact bottom of screen when look-arounding
    360  1b38
    361  1b38		       84 4d		      sty	PF0	; why wasn't this here?  I saw colour glitching in score area!
    362  1b3a							; TJ: no idea why, but you had removed it in revision 758 ;)
    363  1b3a							; completely accidental -- one of our cats may have deleted it.
    364  1b3a		       84 4e		      sty	PF1
    365  1b3c		       84 4f		      sty	PF2
    366  1b3e		       84 5d		      sty	ENAM0
    367  1b40		       84 5b		      sty	GRP0	; when look-scrolling, we can see feet at the top if these aren't here
    368  1b42		       84 5c		      sty	GRP1	; 30/12/2011 -- fix dots @ top!
    369  1b44
    370  1b44							; D1 VBLANK turns off beam
    371  1b44
    372  1b44		       a9 42		      lda	#%01000010	; bit6 is not required
    373  1b46		       85 41		      sta	VBLANK	; end of screen - enter blanking
    374  1b48
    375  1b48							;------------------------------------------------------------------------------
    376  1b48							; This is where the PAL system has a bit of extra time on a per-frame basis.
    377  1b48
    378  1b48		       a6 80		      ldx	Platform
    379  1b4a		       bd 2d f3 	      lda	OverscanTime,x
    380  1b4d		       8d 96 02 	      sta	TIM64T
    381  1b50
    382  1b50							; Background colour priorities. Increasing order of priority...
    383  1b50							;	black -- nothing happening
    384  1b50							;	looking around			     lookingAround<0		     BLUE
    385  1b50							;	when paused			     gameMode... BIT7		     RED
    386  1b50							;	when the door opens (flash)	     ColourTimer>0		     WHITE
    387  1b50
    388  1b50		       a6 80		      ldx	Platform
    389  1b52		       bd 31 f3 	      lda	theThrottler,x
    390  1b55		       18		      clc
    391  1b56		       65 b3		      adc	Throttle
    392  1b58		       b0 02		      bcs	noVerflo
    393  1b5a		       85 b3		      sta	Throttle
    394  1b5c				   noVerflo
    395  1b5c
    396  1b5c							;----------------------------------------------------------------------------------------------
    397  1b5c
    398  1b5c							; has to be done AFTER screen display, because it disables the effect!
    399  1b5c							;SLEEP 6
    400  1b5c							;lda rnd		      ; 3     randomly reposition the Cosmic Ark missile
    401  1b5c							;sta HMM0		      ; 3     this assumes that HMOVE is called at least once/frame
    402  1b5c
    403  1b5c							; "Flash" has highest BG colour priority
    404  1b5c
    405  1b5c		       a5 c0		      lda	ColourTimer
    406  1b5e		       f0 08		      beq	noFlashBG
    407  1b60		       c6 c0		      dec	ColourTimer
    408  1b62		       d0 04		      bne	noFlashBG
    409  1b64		       a9 00		      lda	#0
    410  1b66		       85 b0		      sta	BGColour
    411  1b68							;lda ColourFlash
    412  1b68							;lda FlashColour,x
    413  1b68				   noFlashBG
    414  1b68							;	 sta BGColour
    415  1b68
    416  1b68							; Create a 'standardised' joystick with D4-D7 having bits CLEAR if the appropriate direction is chosen.
    417  1b68
    418  1b68		       ad 80 02 	      lda	SWCHA
    419  1b6b		       25 92		      and	BufferedJoystick
    420  1b6d		       85 92		      sta	BufferedJoystick
    421  1b6f
    422  1b6f		       60		      rts
    423  1b70
    424  1b70							;------------------------------------------------------------------------------
    425  1b70
------- FILE i2c_v2.2.inc LEVEL 3 PASS 3
      0  1b70					      include	"i2c_v2.2.inc"
      1  1b70							;
      2  1b70							; i2c_v2.2.inc
      3  1b70							;
      4  1b70							;
      5  1b70							; AtariVox EEPROM Driver
      6  1b70							;
      7  1b70							; By Alex Herbert, 2004
      8  1b70							;
      9  1b70							; Optimisations by Thomas Jentzsch, 2006/2008
     10  1b70							;
     11  1b70
     12  1b70
     13  1b70							; I/O Constants
     14  1b70
     15  1b70		       00 04	   I2C_SDA_MASK equ	$04
     16  1b70		       00 08	   I2C_SCL_MASK equ	$08
     17  1b70
     18  1b70
     19  1b70							; Signalling Macros
     20  1b70
     21  1b70							;  MAC     I2C_SCL_0
     22  1b70							;    lda     #$00
     23  1b70							;    sta     SWCHA
     24  1b70							;  ENDM
     25  1b70
     26  1b70							;  MAC     I2C_SCL_1
     27  1b70							;    lda     #I2C_SCL_MASK
     28  1b70							;    sta     SWCHA
     29  1b70							;  ENDM
     30  1b70
     31  1b70							;  MAC     I2C_SDA_IN
     32  1b70							;    lda     #I2C_SCL_MASK
     33  1b70							;    sta     SWACNT
     34  1b70							;  ENDM
     35  1b70
     36  1b70							;  MAC     I2C_SDA_OUT
     37  1b70							;    lda     #I2C_SCL_MASK|I2C_SDA_MASK
     38  1b70							;    sta     SWACNT
     39  1b70							;  ENDM
     40  1b70
     41  1b70
     42  1b70					      MAC	i2c_start
     43  1b70							; I2C_SCL_1
     44  1b70					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2	; 2	     I2C_SCL_MASK
     45  1b70					      sta	SWCHA	; 4
     46  1b70							; I2C_SDA_OUT
     47  1b70					      lsr		; 2	     I2C_SCL_MASK|I2C_SDA_MASK
     48  1b70					      sta	SWACNT	; 4
     49  1b70							; total: 12 cycles
     50  1b70					      ENDM
     51  1b70
     52  1b70
     53  1b70					      MAC	i2c_txbit
     54  1b70							; I2C_SCL_0
     55  1b70					      lda	#%0011	; 2
     56  1b70					      sta	SWCHA	; 4
     57  1b70							; set bit
     58  1b70					      adc	#%1000	; 2
     59  1b70					      sta	SWACNT	; 4	     SDA = !C (a = %1000 / %1100)
     60  1b70							; I2C_SCL_1
     61  1b70					      lda	#I2C_SCL_MASK	; 2
     62  1b70					      sta	SWCHA	; 4
     63  1b70							; total: 18 cycles
     64  1b70					      ENDM
     65  1b70
     66  1b70
     67  1b70					      MAC	i2c_txnack
     68  1b70							; I2C_SCL_0
     69  1b70					      lda	#I2C_SCL_MASK*2	; 2	     $00
     70  1b70					      sta	SWCHA	; 4
     71  1b70							; I2C_SDA_IN
     72  1b70					      lsr		; 2	     I2C_SCL_MASK
     73  1b70					      sta	SWACNT	; 4
     74  1b70							; I2C_SCL_1
     75  1b70					      nop		; 2	     required for timing!
     76  1b70					      sta	SWCHA	; 4	     I2C_SCL_MASK
     77  1b70							; total: 18 cycles
     78  1b70					      ENDM
     79  1b70
     80  1b70
     81  1b70							; Subroutine Macros
     82  1b70
     83  1b70					      MAC	i2c_subs
     84  1b70
     85  1b70				   i2c_startread
     86  1b70							; use V to flag if previous byte needs ACK
     87  1b70					      ldy	#%10100001	; 2	     eeprom read command
     88  1b70					      .byte	$2c	; 2
     89  1b70				   i2c_startwrite
     90  1b70					      ldy	#%10100000	; 2	     eeprom write command
     91  1b70					      I2C_START		;12	     start signal (clears V flag)
     92  1b70					      tya		; 2 = 16
     93  1b70				   i2c_txbyte
     94  1b70					      eor	#$ff	; 2	     invert data byte
     95  1b70					      sec		; 2
     96  1b70					      rol		; 2 =	6    shift loop bit into a
     97  1b70				   i2c_txbyteloop
     98  1b70					      tay		; 2
     99  1b70					      I2C_TXBIT		;18	     transmit
    100  1b70					      tya		; 2
    101  1b70					      asl		; 2	     shift next bit into C
    102  1b70					      bne	i2c_txbyteloop	; 2= 26/27
    103  1b70
    104  1b70							; receive acknowledge bit
    105  1b70
    106  1b70					      beq	i2c_rxbit	;43 = 43
    107  1b70							; i2c_txbyte: 264 cycles
    108  1b70							;-------------------------------------------------------------------------------
    109  1b70
    110  1b70				   i2c_rxbyte
    111  1b70					      bvc	i2c_rxskipack	; 2	     previous byte needs acknowledge?
    112  1b70					      jsr	i2c_txack	;24	     transmit acknowledge bit
    113  1b70
    114  1b70				   i2c_rxskipack
    115  1b70					      bit	i2c_rxbyte	; 4	     set V - next byte(s) require acknowledge
    116  1b70
    117  1b70					      lda	#1	; 2
    118  1b70				   i2c_rxbyteloop
    119  1b70					      tay		; 2 =	2
    120  1b70				   i2c_rxbit		;	     receive bit in C
    121  1b70					      I2C_TXNACK		;18 = 18
    122  1b70
    123  1b70					      lda	SWCHA	; 4
    124  1b70					      lsr		; 2
    125  1b70					      lsr		; 2
    126  1b70					      lsr		; 2 = 10    C = SDA
    127  1b70
    128  1b70					      tya		; 2
    129  1b70					      rol		; 2	     rotate into Y
    130  1b70					      bcc	i2c_rxbyteloop	; 2=	6/7
    131  1b70
    132  1b70							; received byte in A
    133  1b70					      rts		; 6 =	6
    134  1b70							; i2c_rxbit:  40 cycles
    135  1b70							; i2c_rxbyte: 310/333 cycles
    136  1b70							;-------------------------------------------------------------------------------
    137  1b70
    138  1b70				   i2c_stopread
    139  1b70					      bvc	i2c_stopwrite	; 2
    140  1b70					      ldy	#$80	; 2
    141  1b70					      jsr	i2c_rxbit	;46	     transmit no-acknowledge
    142  1b70
    143  1b70				   i2c_stopwrite
    144  1b70					      jsr	i2c_txack	;30
    145  1b70
    146  1b70							; return port to input mode
    147  1b70					      lda	#0	; 2	     0
    148  1b70					      sta	SWACNT	; 4
    149  1b70					      rts		; 6 = 12
    150  1b70							; i2c_stopread:  45/92
    151  1b70							; i2c_stopwrite: 42
    152  1b70							;-------------------------------------------------------------------------------
    153  1b70
    154  1b70				   i2c_txack
    155  1b70							; I2C_SCL_0
    156  1b70					      lda	#0	; 2	     $00
    157  1b70					      sta	SWCHA	; 4
    158  1b70							; I2C_SDA_OUT
    159  1b70					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)	; 2	     I2C_SCL_MASK|I2C_SDA_MASK
    160  1b70					      sta	SWACNT	; 4
    161  1b70							; I2C_SCL_1
    162  1b70					      asl		; 2	     I2C_SCL_MASK
    163  1b70					      sta	SWCHA	; 4
    164  1b70
    165  1b70					      rts		; 6
    166  1b70							; total: 24 cycles
    167  1b70							;-------------------------------------------------------------------------------
    168  1b70
    169  1b70					      ENDM
    170  1b70
    171  1b70
    172  1b70
------- FILE BANK_GENERIC.asm
    427  1b70
      0  1b70					      i2c_subs
      1  1b70
      2  1b70				   i2c_startread
      3  1b70
      4  1b70		       a0 a1		      ldy	#%10100001
      5  1b72		       2c		      .byte.b	$2c
      6  1b73				   i2c_startwrite
      7  1b73		       a0 a0		      ldy	#%10100000
      0  1b75					      I2C_START
      1  1b75
      2  1b75		       a9 18		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2
      3  1b77		       8d 80 02 	      sta	SWCHA
      4  1b7a
      5  1b7a		       4a		      lsr
      6  1b7b		       8d 81 02 	      sta	SWACNT
      7  1b7e
      9  1b7e		       98		      tya
     10  1b7f				   i2c_txbyte
     11  1b7f		       49 ff		      eor	#$ff
     12  1b81		       38		      sec
     13  1b82		       2a		      rol
     14  1b83				   i2c_txbyteloop
     15  1b83		       a8		      tay
      0  1b84					      I2C_TXBIT
      1  1b84
      2  1b84		       a9 03		      lda	#%0011
      3  1b86		       8d 80 02 	      sta	SWCHA
      4  1b89
      5  1b89		       69 08		      adc	#%1000
      6  1b8b		       8d 81 02 	      sta	SWACNT
      7  1b8e
      8  1b8e		       a9 08		      lda	#I2C_SCL_MASK
      9  1b90		       8d 80 02 	      sta	SWCHA
     10  1b93
     17  1b93		       98		      tya
     18  1b94		       0a		      asl
     19  1b95		       d0 ec		      bne	i2c_txbyteloop
     20  1b97
     21  1b97
     22  1b97
     23  1b97		       f0 0b		      beq	i2c_rxbit
     24  1b99
     25  1b99
     26  1b99
     27  1b99				   i2c_rxbyte
     28  1b99		       50 03		      bvc	i2c_rxskipack
     29  1b9b		       20 cc f3 	      jsr	i2c_txack
     30  1b9e
     31  1b9e				   i2c_rxskipack
     32  1b9e		       2c 99 f3 	      bit	i2c_rxbyte
     33  1ba1
     34  1ba1		       a9 01		      lda	#1
     35  1ba3				   i2c_rxbyteloop
     36  1ba3		       a8		      tay
     37  1ba4				   i2c_rxbit
      0  1ba4					      I2C_TXNACK
      1  1ba4
      2  1ba4		       a9 10		      lda	#I2C_SCL_MASK*2
      3  1ba6		       8d 80 02 	      sta	SWCHA
      4  1ba9
      5  1ba9		       4a		      lsr
      6  1baa		       8d 81 02 	      sta	SWACNT
      7  1bad
      8  1bad		       ea		      nop
      9  1bae		       8d 80 02 	      sta	SWCHA
     10  1bb1
     39  1bb1
     40  1bb1		       ad 80 02 	      lda	SWCHA
     41  1bb4		       4a		      lsr
     42  1bb5		       4a		      lsr
     43  1bb6		       4a		      lsr
     44  1bb7
     45  1bb7		       98		      tya
     46  1bb8		       2a		      rol
     47  1bb9		       90 e8		      bcc	i2c_rxbyteloop
     48  1bbb
     49  1bbb
     50  1bbb		       60		      rts
     51  1bbc
     52  1bbc
     53  1bbc
     54  1bbc
     55  1bbc				   i2c_stopread
     56  1bbc		       50 05		      bvc	i2c_stopwrite
     57  1bbe		       a0 80		      ldy	#$80
     58  1bc0		       20 a4 f3 	      jsr	i2c_rxbit
     59  1bc3
     60  1bc3				   i2c_stopwrite
     61  1bc3		       20 cc f3 	      jsr	i2c_txack
     62  1bc6
     63  1bc6
     64  1bc6		       a9 00		      lda	#0
     65  1bc8		       8d 81 02 	      sta	SWACNT
     66  1bcb		       60		      rts
     67  1bcc
     68  1bcc
     69  1bcc
     70  1bcc
     71  1bcc				   i2c_txack
     72  1bcc
     73  1bcc		       a9 00		      lda	#0
     74  1bce		       8d 80 02 	      sta	SWCHA
     75  1bd1
     76  1bd1		       a9 0c		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)
     77  1bd3		       8d 81 02 	      sta	SWACNT
     78  1bd6
     79  1bd6		       0a		      asl
     80  1bd7		       8d 80 02 	      sta	SWCHA
     81  1bda
     82  1bda		       60		      rts
     83  1bdb
     84  1bdb
     85  1bdb
    429  1bdb
    430  1bdb				   HandleSaveKey SUBROUTINE
    431  1bdb
    432  1bdb		       2f 00	   SAVEKEY_ADR =	$2F00	;	     tentative address for Sokoban (64 bytes)
    433  1bdb
    434  1bdb							;------------------------------------------------------------------------------
      0  1bdb					      DEFINE_SUBROUTINE	ReadSaveKey	; = 2371
      1  1bdb		       00 03	   BANK_ReadSaveKey =	_CURRENT_BANK
      2  1bdb					      SUBROUTINE
      3  1bdb				   ReadSaveKey
    436  1bdb
    437  1bdb							; assume no SaveKey found:
    438  1bdb		       a9 ff		      lda	#$ff	; 2	     return $ff if no SaveKey found
    439  1bdd		       85 e0		      sta	highScoreSK+2	; 3
    440  1bdf
    441  1bdf							; setup SaveKey:
    442  1bdf		       a5 e1		      lda	startingLevel	; 3	     load start levelX*5 and level
    443  1be1		       a6 b2		      ldx	level	; 3
    444  1be3		       20 1c f4 	      jsr	SetupSaveKey	;6+853
    445  1be6		       90 52		      bcc	NoSKfound	; 2/3
    446  1be8
    447  1be8							;    lda     #$34
    448  1be8							;    sta     COLUBK
    449  1be8
    450  1be8							; start read
    451  1be8		       20 c3 f3 	      jsr	i2c_stopwrite	;6+42	     end of "fake" write
    452  1beb		       20 70 f3 	      jsr	i2c_startread	;6+284      Start signal and $a1 command byte
    453  1bee
    454  1bee							; read high score:
    455  1bee		       a2 02		      ldx	#3-1	; 2 = 1187
    456  1bf0				   .loopRead
    457  1bf0		       20 99 f3 	      jsr	i2c_rxbyte	;6+333      read byte from EEPROM
    458  1bf3		       c9 ff		      cmp	#$ff	; 2	     EEPROM slot empty?
    459  1bf5		       d0 02		      bne	.skipEmpty	; 2/3	      no, skip clear
    460  1bf7		       a9 00		      lda	#0	; 2	     clear EEPROM slot
    461  1bf9				   .skipEmpty
    462  1bf9		       95 de		      sta	highScoreSK,x	; 4
    463  1bfb		       ca		      dex		; 2
    464  1bfc		       10 f2		      bpl	.loopRead	; 2/3= 354
    465  1bfe
    466  1bfe							; stop read:
    467  1bfe		       4c bc f3 	      jmp	i2c_stopread	;3+92=95    terminate read
    468  1c01
    469  1c01							;------------------------------------------------------------------------------
      0  1c01					      DEFINE_SUBROUTINE	WriteSaveKey	; = 1751
      1  1c01		       00 03	   BANK_WriteSaveKey =	_CURRENT_BANK
      2  1c01					      SUBROUTINE
      3  1c01				   WriteSaveKey
    471  1c01
    472  1c01							; check if new high score:
    473  1c01		       a6 de		      ldx	highScoreSK	; 3
    474  1c03		       e8		      inx		; 2
    475  1c04		       f0 34		      beq	NoSKfound	; 2/3	     no new high score, abort
    476  1c06
    477  1c06							; setup SaveKey:
    478  1c06		       a5 e1		      lda	startingLevel	; 3	     load start levelX*5 and level
    479  1c08		       a6 e2		      ldx	startLevel	; 3
    480  1c0a		       20 1c f4 	      jsr	SetupSaveKey	; 6+853
    481  1c0d		       90 2b		      bcc	NoSKfound	; 2/3
    482  1c0f
    483  1c0f							;    lda     #$64
    484  1c0f							;    sta     COLUBK
    485  1c0f
    486  1c0f							; write high score:
    487  1c0f		       a2 02		      ldx	#3-1	; 2 = 841
    488  1c11				   .loopWrite
    489  1c11		       b5 de		      lda	highScoreSK,x	; 4
    490  1c13		       20 7f f3 	      jsr	i2c_txbyte	;6+264      transmit to EEPROM
    491  1c16		       ca		      dex		; 2
    492  1c17		       10 f8		      bpl	.loopWrite	; 2/3= 837
    493  1c19
    494  1c19							; stop write:
    495  1c19		       4c c3 f3 	      jmp	i2c_stopwrite	; 3+42= 45  terminate write and commit to memory
    496  1c1c
    497  1c1c
    498  1c1c							;------------------------------------------------------------------------------
    499  1c1c
      0  1c1c					      DEFINE_SUBROUTINE	SetupSaveKey	; = 853
      1  1c1c		       00 03	   BANK_SetupSaveKey =	_CURRENT_BANK
      2  1c1c					      SUBROUTINE
      3  1c1c				   SetupSaveKey
    501  1c1c
    502  1c1c							; calculate slot;
    503  1c1c							; a = levelX
    504  1c1c							; x = level (0..4)
    505  1c1c		       85 e3		      sta	offsetSK	; 3
    506  1c1e		       8a		      txa		; 2
    507  1c1f		       18		      clc		; 2
    508  1c20		       65 e3		      adc	offsetSK	; 3
    509  1c22		       85 e3		      sta	offsetSK	; 3
    510  1c24		       0a		      asl		; 2	     multiply by 3
    511  1c25		       65 e3		      adc	offsetSK	; 3
    512  1c27		       69 00		      adc	#<SAVEKEY_ADR	; 2
    513  1c29		       aa		      tax		; 2 = 22
    514  1c2a							; detect SaveKey:
    515  1c2a		       20 73 f3 	      jsr	i2c_startwrite	;6+280
    516  1c2d		       d0 0a		      bne	.exitSK	; 2/3
    517  1c2f
    518  1c2f							; setup address:
    519  1c2f		       b8		      clv		; 2
    520  1c30		       a9 2f		      lda	#>SAVEKEY_ADR	; 2	     upper byte of address
    521  1c32		       20 7f f3 	      jsr	i2c_txbyte	;6+264
    522  1c35		       8a		      txa		; 2	     x = lower byte offset
    523  1c36		       4c 7f f3 	      jmp	i2c_txbyte	;3+264      returns C==1
    524  1c39
    525  1c39				   .exitSK
    526  1c39		       18		      clc
    527  1c3a				   NoSKfound
    528  1c3a		       60		      rts
    529  1c3a					      ENDIF
    530  1c3b
    531  1c3b							;----------------------------------------------------------------------
    532  1c3b
    533  1c3b
      0  1c3b					      DEFINE_SUBROUTINE	GenerateHighScoreCode
      1  1c3b		       00 03	   BANK_GenerateHighScoreCode =	_CURRENT_BANK
      2  1c3b					      SUBROUTINE
      3  1c3b				   GenerateHighScoreCode
    535  1c3b
    536  1c3b							;rdm = random.randint(1,3)
    537  1c3b							;encoding = [
    538  1c3b							;    (rdm << 5) | (seconds >> 8),
    539  1c3b							;    seconds & 0xFF,
    540  1c3b							;    level,
    541  1c3b							;    moves >> 8,
    542  1c3b							;    moves & 0xFF
    543  1c3b							;]
    544  1c3b
    545  1c3b		       1f ff	   MAX_SECOND_COUNT =	%1111111111111
    546  1c3b
    547  1c3b		       a5 cf		      lda	seconds+1
    548  1c3d		       c9 1f		      cmp	#>MAX_SECOND_COUNT
    549  1c3f		       90 10		      bcc	secRangeOK
    550  1c41		       d0 06		      bne	secAdjust
    551  1c43		       a5 ce		      lda	seconds
    552  1c45		       c9 ff		      cmp	#<MAX_SECOND_COUNT
    553  1c47		       90 08		      bcc	secRangeOK
    554  1c49
    555  1c49		       a9 ff	   secAdjust  lda	#<MAX_SECOND_COUNT
    556  1c4b		       85 ce		      sta	seconds
    557  1c4d		       a9 1f		      lda	#>MAX_SECOND_COUNT
    558  1c4f		       85 cf		      sta	seconds+1
    559  1c51
    560  1c51				   secRangeOK
    561  1c51
    562  1c51
    563  1c51
    564  1c51		       20 52 fd    rerandom   jsr	Random
    565  1c54		       29 03		      and	#%11
    566  1c56		       f0 f9		      beq	rerandom
    567  1c58
    568  1c58							;randomiser = (rdm << 6) | (rdm << 4) | (rdm << 2) | rdm
    569  1c58
    570  1c58		       aa		      tax
    571  1c59		       bd a9 f5 	      lda	RandomMaskByte,x
    572  1c5c		       85 ee		      sta	randomiser
    573  1c5e
    574  1c5e		       a5 cf		      lda	seconds+1
    575  1c60		       85 e9		      sta	encoding+0	;    (rdm << 5) | (seconds >> 8),
    576  1c62		       a5 ce		      lda	seconds
    577  1c64		       85 ea		      sta	encoding+1	;    seconds & 0xFF,
    578  1c66
    579  1c66		       a5 b1		      lda	levelX
    580  1c68		       85 eb		      sta	encoding+2	;    level, should be < 128
    581  1c6a
    582  1c6a							; f'n ugly convert 2 byte (4-digit) BCD into 2 byte binary...
    583  1c6a
    584  1c6a		       a5 b6	   rangedOK   lda	BCD_moveCounter+1
    585  1c6c		       4a		      lsr
    586  1c6d		       4a		      lsr
    587  1c6e		       4a		      lsr
    588  1c6f		       4a		      lsr		; THOUSANDS 0-9
    589  1c70		       0a		      asl
    590  1c71		       aa		      tax
    591  1c72		       bd cb f5 	      lda	Times1000,x
    592  1c75		       85 e7		      sta	binMoves
    593  1c77		       bd cc f5 	      lda	Times1000+1,x
    594  1c7a		       85 e8		      sta	binMoves+1
    595  1c7c
    596  1c7c		       a5 b6		      lda	BCD_moveCounter+1
    597  1c7e		       29 0f		      and	#$F	; HUNDREDS 0-9
    598  1c80		       0a		      asl
    599  1c81		       aa		      tax
    600  1c82
    601  1c82		       a5 e7		      lda	binMoves
    602  1c84		       7d b7 f5 	      adc	Times100,x
    603  1c87		       85 e7		      sta	binMoves
    604  1c89		       a5 e8		      lda	binMoves+1
    605  1c8b		       7d b8 f5 	      adc	Times100+1,x
    606  1c8e		       85 e8		      sta	binMoves+1
    607  1c90
    608  1c90		       a5 b5		      lda	BCD_moveCounter
    609  1c92		       29 0f		      and	#$F	;   UNITS 0-9
    610  1c94		       18		      clc
    611  1c95		       65 e7		      adc	binMoves
    612  1c97		       85 e7		      sta	binMoves
    613  1c99		       a5 e8		      lda	binMoves+1
    614  1c9b		       69 00		      adc	#0
    615  1c9d		       85 e8		      sta	binMoves+1
    616  1c9f
    617  1c9f		       a5 b5		      lda	BCD_moveCounter
    618  1ca1		       4a		      lsr
    619  1ca2		       4a		      lsr
    620  1ca3		       4a		      lsr
    621  1ca4		       4a		      lsr		; tens
    622  1ca5		       aa		      tax
    623  1ca6		       18		      clc
    624  1ca7		       a5 e7		      lda	binMoves
    625  1ca9		       7d ad f5 	      adc	Times10,x
    626  1cac		       85 e7		      sta	binMoves
    627  1cae		       a5 e8		      lda	binMoves+1
    628  1cb0		       69 00		      adc	#0
    629  1cb2		       85 e8		      sta	binMoves+1
    630  1cb4
    631  1cb4		       0f ff	   MAX_MOVE_COUNT =	$FFF
    632  1cb4
    633  1cb4		       a5 e8		      lda	binMoves+1
    634  1cb6		       c9 0f		      cmp	#>MAX_MOVE_COUNT
    635  1cb8		       90 10		      bcc	movRangeOK
    636  1cba		       d0 06		      bne	movAdjust
    637  1cbc		       a5 e7		      lda	binMoves
    638  1cbe		       c9 ff		      cmp	#<MAX_MOVE_COUNT
    639  1cc0		       90 08		      bcc	movRangeOK
    640  1cc2
    641  1cc2		       a9 ff	   movAdjust  lda	#<MAX_MOVE_COUNT
    642  1cc4		       85 e7		      sta	binMoves
    643  1cc6		       a9 0f		      lda	#>MAX_MOVE_COUNT
    644  1cc8		       85 e8		      sta	binMoves+1
    645  1cca
    646  1cca				   movRangeOK
    647  1cca
    648  1cca		       a5 e7		      lda	binMoves
    649  1ccc		       85 ed		      sta	encoding+4
    650  1cce		       a5 e8		      lda	binMoves+1
    651  1cd0		       85 ec		      sta	encoding+3
    652  1cd2
    653  1cd2							; generate a checksum
    654  1cd2
    655  1cd2		       18		      clc
    656  1cd3		       a5 e9		      lda	encoding
    657  1cd5		       65 ea		      adc	encoding+1
    658  1cd7		       18		      clc
    659  1cd8		       65 eb		      adc	encoding+2
    660  1cda		       18		      clc
    661  1cdb		       65 ec		      adc	encoding+3
    662  1cdd		       18		      clc
    663  1cde		       65 ed		      adc	encoding+4	;checksum = sum(encoding) & 0xF
    664  1ce0		       0a		      asl
    665  1ce1		       0a		      asl
    666  1ce2		       0a		      asl
    667  1ce3		       0a		      asl
    668  1ce4		       05 ec		      ora	encoding+3
    669  1ce6		       85 ec		      sta	encoding+3	;encoding[3] |= (checksum << 4)
    670  1ce8
    671  1ce8				   CompletedPlainEncode
    672  1ce8
    673  1ce8							;for i in range(len(encoding)):
    674  1ce8							;    encoding[i] ^= randomiser
    675  1ce8
    676  1ce8		       a2 04		      ldx	#4
    677  1cea		       b5 e9	   xorencode  lda	encoding,x
    678  1cec		       45 ee		      eor	randomiser
    679  1cee		       95 e9		      sta	encoding,x
    680  1cf0		       ca		      dex
    681  1cf1		       10 f7		      bpl	xorencode
    682  1cf3
    683  1cf3							; put randomiser in D6,D5 of encoding[0]
    684  1cf3
    685  1cf3		       a5 ee		      lda	randomiser
    686  1cf5		       4a		      lsr
    687  1cf6		       29 60		      and	#%01100000
    688  1cf8		       85 ee		      sta	randomiser
    689  1cfa
    690  1cfa		       a5 e9		      lda	encoding
    691  1cfc		       29 1f		      and	#%00011111
    692  1cfe		       05 ee		      ora	randomiser
    693  1d00		       85 e9		      sta	encoding
    694  1d02
    695  1d02
    696  1d02							; because they were 0, and have now been xor'd with randomiser...
    697  1d02							; for top 3 bits, D7D6 now hold the relevant randomiser value. D5 is same as D7 for what it's worth
    698  1d02							; write the encoded bytes for 6502.ts emulator to intercept for web triggering
    699  1d02
    700  1d02		       a2 00		      ldx	#0
    701  1d04		       b5 e9	   emulNotify lda	encoding,x
    702  1d06		       85 48		      sta	INPT0	; for web interface triggering
    703  1d08		       e8		      inx
    704  1d09		       e0 05		      cpx	#5
    705  1d0b		       90 f7		      bcc	emulNotify
    706  1d0d		       86 49		      stx	INPT1	; for web interface triggering
    707  1d0f
    708  1d0f							; we now have a binary version of the encoding.
    709  1d0f							; Convert this into 12 decimal digits
    710  1d0f
    711  1d0f		       a0 37		      ldy	#55	; --> high byte of 10^11
    712  1d11		       a2 00		      ldx	#0
    713  1d13				   decimalise
    714  1d13		       a9 00		      lda	#0
    715  1d15		       95 db		      sta	decimal,x
    716  1d17
    717  1d17		       38		      sec
    718  1d18				   subonedecdigit
    719  1d18				   .OFFSET    SET	4
    720  1d18					      REPEAT	5
    721  1d18		       a5 ed		      lda	encoding + .OFFSET
    722  1d1a		       f9 71 f5 	      sbc	DecimalDigit + .OFFSET,y
    723  1d1d		       85 ed		      sta	encoding + .OFFSET
    724  1d1d				   .OFFSET    SET	.OFFSET - 1
    720  1d1d					      REPEND
    721  1d1f		       a5 ec		      lda	encoding + .OFFSET
    722  1d21		       f9 70 f5 	      sbc	DecimalDigit + .OFFSET,y
    723  1d24		       85 ec		      sta	encoding + .OFFSET
    724  1d24				   .OFFSET    SET	.OFFSET - 1
    720  1d24					      REPEND
    721  1d26		       a5 eb		      lda	encoding + .OFFSET
    722  1d28		       f9 6f f5 	      sbc	DecimalDigit + .OFFSET,y
    723  1d2b		       85 eb		      sta	encoding + .OFFSET
    724  1d2b				   .OFFSET    SET	.OFFSET - 1
    720  1d2b					      REPEND
    721  1d2d		       a5 ea		      lda	encoding + .OFFSET
    722  1d2f		       f9 6e f5 	      sbc	DecimalDigit + .OFFSET,y
    723  1d32		       85 ea		      sta	encoding + .OFFSET
    724  1d32				   .OFFSET    SET	.OFFSET - 1
    720  1d32					      REPEND
    721  1d34		       a5 e9		      lda	encoding + .OFFSET
    722  1d36		       f9 6d f5 	      sbc	DecimalDigit + .OFFSET,y
    723  1d39		       85 e9		      sta	encoding + .OFFSET
    724  1d39				   .OFFSET    SET	.OFFSET - 1
    725  1d3b					      REPEND
    726  1d3b		       f6 db		      inc	decimal,x
    727  1d3d		       b0 d9		      bcs	subonedecdigit
    728  1d3f
    729  1d3f							; add back on the 'overshoot'
    730  1d3f				   .OFFSET    SET	4
    731  1d3f					      REPEAT	5
    732  1d3f		       a5 ed		      lda	encoding + .OFFSET
    733  1d41		       79 71 f5 	      adc	DecimalDigit + .OFFSET,y
    734  1d44		       85 ed		      sta	encoding + .OFFSET
    735  1d44				   .OFFSET    SET	.OFFSET - 1
    731  1d44					      REPEND
    732  1d46		       a5 ec		      lda	encoding + .OFFSET
    733  1d48		       79 70 f5 	      adc	DecimalDigit + .OFFSET,y
    734  1d4b		       85 ec		      sta	encoding + .OFFSET
    735  1d4b				   .OFFSET    SET	.OFFSET - 1
    731  1d4b					      REPEND
    732  1d4d		       a5 eb		      lda	encoding + .OFFSET
    733  1d4f		       79 6f f5 	      adc	DecimalDigit + .OFFSET,y
    734  1d52		       85 eb		      sta	encoding + .OFFSET
    735  1d52				   .OFFSET    SET	.OFFSET - 1
    731  1d52					      REPEND
    732  1d54		       a5 ea		      lda	encoding + .OFFSET
    733  1d56		       79 6e f5 	      adc	DecimalDigit + .OFFSET,y
    734  1d59		       85 ea		      sta	encoding + .OFFSET
    735  1d59				   .OFFSET    SET	.OFFSET - 1
    731  1d59					      REPEND
    732  1d5b		       a5 e9		      lda	encoding + .OFFSET
    733  1d5d		       79 6d f5 	      adc	DecimalDigit + .OFFSET,y
    734  1d60		       85 e9		      sta	encoding + .OFFSET
    735  1d60				   .OFFSET    SET	.OFFSET - 1
    736  1d62					      REPEND
    737  1d62
    738  1d62		       d6 db		      dec	decimal,x
    739  1d64
    740  1d64		       e8		      inx
    741  1d65
    742  1d65		       88		      dey
    743  1d66		       88		      dey
    744  1d67		       88		      dey
    745  1d68		       88		      dey
    746  1d69		       88		      dey		; point to previous 10^x
    747  1d6a
    748  1d6a		       10 a7		      bpl	decimalise
    749  1d6c
    750  1d6c							; on exit, the 12 decimal digits are in 'decimal'
    751  1d6c
    752  1d6c		       60	   CheckDecimal rts
    753  1d6d
    754  1d6d		       00 00 00 00*DecimalDigit .byte.b	%00000000,%00000000,%00000000,%00000000,%00000001	; 10^0
    755  1d72		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00001010	; 10^1
    756  1d77		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%01100100	; 10^2
    757  1d7c		       00 00 00 03*	      .byte.b	%00000000,%00000000,%00000000,%00000011,%11101000	; 10^3
    758  1d81		       00 00 00 27*	      .byte.b	%00000000,%00000000,%00000000,%00100111,%00010000	; 10^4
    759  1d86		       00 00 01 86*	      .byte.b	%00000000,%00000000,%00000001,%10000110,%10100000	; 10^5
    760  1d8b		       00 00 0f 42*	      .byte.b	%00000000,%00000000,%00001111,%01000010,%01000000	; 10^6
    761  1d90		       00 00 98 96*	      .byte.b	%00000000,%00000000,%10011000,%10010110,%10000000	; 10^7
    762  1d95		       00 05 f5 e1*	      .byte.b	%00000000,%00000101,%11110101,%11100001,%00000000	; 10^8
    763  1d9a		       00 3b 9a ca*	      .byte.b	%00000000,%00111011,%10011010,%11001010,%00000000	; 10^9
    764  1d9f		       02 54 0b e4*	      .byte.b	%00000010,%01010100,%00001011,%11100100,%00000000	; 10^10
    765  1da4		       17 48 76 e8*	      .byte.b	%00010111,%01001000,%01110110,%11101000,%00000000	; 10^11
    766  1da9							;.byte %11101000,%11010100,%10100101,%00010000,%00000000     ; 10^12
    767  1da9
    768  1da9
    769  1da9
    770  1da9		       00 55 aa ff RandomMaskByte .byte.b	0, %01010101, %10101010, %11111111
    771  1dad		       00 0a 14 1e*Times10    .byte.b	0, 10, 20, 30, 40, 50, 60, 70, 80, 90
    772  1db7		       00 00 64 00*Times100   .word.w	0, 100, 200, 300, 400, 500, 600, 700, 800, 900
    773  1dcb		       00 00 e8 03*Times1000  .word.w	0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000
    774  1ddf
      0  1ddf					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  1ddf		       05 df	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $5df , FREE= $221
      2  1ddf					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1ddf				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1ddf				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1ddf				  -	      ERR
      6  1ddf					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS_TABLES.asm LEVEL 2 PASS 3
      0  1ddf					      include	"BANK_LEVELS_TABLES.asm"
      1  1ddf							;    Sokoboo - a Sokoban implementation
      2  1ddf							;    using a generic tile-based display engine for the Atari 2600
      3  1ddf							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1ddf							;
      5  1ddf							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1ddf							;
      7  1ddf							;    Code related to the generic tile-based display engine was developed by
      8  1ddf							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1ddf							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1ddf							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1ddf							;
     12  1ddf							;    Code related to music and sound effects uses the TIATracker music player
     13  1ddf							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1ddf							;    directory for Apache licensing details.
     15  1ddf							;
     16  1ddf							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1ddf							;    See the copyright notices in the License directory for a list of level
     18  1ddf							;    contributors.
     19  1ddf							;
     20  1ddf							;    Except where otherwise indicated, this software is released under the
     21  1ddf							;    following licensing arrangement...
     22  1ddf							;
     23  1ddf							;    This program is free software: you can redistribute it and/or modify
     24  1ddf							;    it under the terms of the GNU General Public License as published by
     25  1ddf							;    the Free Software Foundation, either version 3 of the License, or
     26  1ddf							;    (at your option) any later version.
     27  1ddf							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1ddf
     29  1ddf							;    This program is distributed in the hope that it will be useful,
     30  1ddf							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1ddf							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1ddf							;    GNU General Public License for more details.
     33  1ddf
     34  1ddf							; level definitions
     35  1ddf							; Sample level definitions.
     36  1ddf							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  1ddf							; have as many banks as you like.
     38  1ddf
      0  1ddf					      NEWBANK	LEVELS_TABLES
      1  2246 ????				      SEG	LEVELS_TABLES
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   LEVELS_TABLES SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	LEVELS_TABLES
     40  2000
     41  2000
     42  2000							; The ordering here corresponds to the ordering when playing...
     43  2000
     44  2000					      align	256
      0  2000					      DEFINE_SUBROUTINE	LevelInfoLO
      1  2000		       00 04	   BANK_LevelInfoLO =	_CURRENT_BANK
      2  2000					      SUBROUTINE
      3  2000				   LevelInfoLO
     46  2000		       ff		      .byte.b	<(LEVEL__001_L-1)
     47  2001		       11		      .byte.b	<(LEVEL__001_R-1)
     48  2002		       1d		      .byte.b	<(LEVEL__002_L-1)
     49  2003		       36		      .byte.b	<(LEVEL__002_R-1)
     50  2004		       5e		      .byte.b	<(LEVEL__003_L-1)
     51  2005		       8a		      .byte.b	<(LEVEL__003_R-1)
     52  2006		       b4		      .byte.b	<(LEVEL__004_L-1)
     53  2007		       d7		      .byte.b	<(LEVEL__004_R-1)
     54  2008		       f3		      .byte.b	<(LEVEL__005_L-1)
     55  2009		       25		      .byte.b	<(LEVEL__005_R-1)
     56  200a		       64		      .byte.b	<(LEVEL__006_L-1)
     57  200b		       9f		      .byte.b	<(LEVEL__006_R-1)
     58  200c		       dd		      .byte.b	<(LEVEL__007_L-1)
     59  200d		       0a		      .byte.b	<(LEVEL__007_R-1)
     60  200e		       3d		      .byte.b	<(LEVEL__008_L-1)
     61  200f		       73		      .byte.b	<(LEVEL__008_R-1)
     62  2010		       a4		      .byte.b	<(LEVEL__009_L-1)
     63  2011		       d6		      .byte.b	<(LEVEL__009_R-1)
     64  2012		       06		      .byte.b	<(LEVEL__010_L-1)
     65  2013		       40		      .byte.b	<(LEVEL__010_R-1)
     66  2014		       73		      .byte.b	<(LEVEL__011_L-1)
     67  2015		       a6		      .byte.b	<(LEVEL__011_R-1)
     68  2016		       e0		      .byte.b	<(LEVEL__012_L-1)
     69  2017		       10		      .byte.b	<(LEVEL__012_R-1)
     70  2018		       4c		      .byte.b	<(LEVEL__013_L-1)
     71  2019		       8b		      .byte.b	<(LEVEL__013_R-1)
     72  201a		       be		      .byte.b	<(LEVEL__014_L-1)
     73  201b		       01		      .byte.b	<(LEVEL__014_R-1)
     74  201c		       44		      .byte.b	<(LEVEL__015_L-1)
     75  201d		       79		      .byte.b	<(LEVEL__015_R-1)
     76  201e		       be		      .byte.b	<(LEVEL__016_L-1)
     77  201f		       f5		      .byte.b	<(LEVEL__016_R-1)
     78  2020		       28		      .byte.b	<(LEVEL__017_L-1)
     79  2021		       72		      .byte.b	<(LEVEL__017_R-1)
     80  2022		       b5		      .byte.b	<(LEVEL__018_L-1)
     81  2023		       e9		      .byte.b	<(LEVEL__018_R-1)
     82  2024		       25		      .byte.b	<(LEVEL__019_L-1)
     83  2025		       60		      .byte.b	<(LEVEL__019_R-1)
     84  2026
     85  2026
     86  2026		       00 26	   MAX_LEVEL  =	* - LevelInfoLO
 $26 LEVELS INSTALLED
     87  2026					      ECHO	MAX_LEVEL, "LEVELS INSTALLED"
     88  2026
     89  2100		       00 00 00 00*	      align	256
      0  2100					      DEFINE_SUBROUTINE	LevelInfoHI
      1  2100		       00 04	   BANK_LevelInfoHI =	_CURRENT_BANK
      2  2100					      SUBROUTINE
      3  2100				   LevelInfoHI
     91  2100
     92  2100		       ef		      .byte.b	>(LEVEL__001_L-1)
     93  2101		       f0		      .byte.b	>(LEVEL__001_R-1)
     94  2102		       f0		      .byte.b	>(LEVEL__002_L-1)
     95  2103		       f0		      .byte.b	>(LEVEL__002_R-1)
     96  2104		       f0		      .byte.b	>(LEVEL__003_L-1)
     97  2105		       f0		      .byte.b	>(LEVEL__003_R-1)
     98  2106		       f0		      .byte.b	>(LEVEL__004_L-1)
     99  2107		       f0		      .byte.b	>(LEVEL__004_R-1)
    100  2108		       f0		      .byte.b	>(LEVEL__005_L-1)
    101  2109		       f1		      .byte.b	>(LEVEL__005_R-1)
    102  210a		       f1		      .byte.b	>(LEVEL__006_L-1)
    103  210b		       f1		      .byte.b	>(LEVEL__006_R-1)
    104  210c		       f1		      .byte.b	>(LEVEL__007_L-1)
    105  210d		       f2		      .byte.b	>(LEVEL__007_R-1)
    106  210e		       f2		      .byte.b	>(LEVEL__008_L-1)
    107  210f		       f2		      .byte.b	>(LEVEL__008_R-1)
    108  2110		       f2		      .byte.b	>(LEVEL__009_L-1)
    109  2111		       f2		      .byte.b	>(LEVEL__009_R-1)
    110  2112		       f3		      .byte.b	>(LEVEL__010_L-1)
    111  2113		       f3		      .byte.b	>(LEVEL__010_R-1)
    112  2114		       f3		      .byte.b	>(LEVEL__011_L-1)
    113  2115		       f3		      .byte.b	>(LEVEL__011_R-1)
    114  2116		       f3		      .byte.b	>(LEVEL__012_L-1)
    115  2117		       f4		      .byte.b	>(LEVEL__012_R-1)
    116  2118		       f4		      .byte.b	>(LEVEL__013_L-1)
    117  2119		       f4		      .byte.b	>(LEVEL__013_R-1)
    118  211a		       f4		      .byte.b	>(LEVEL__014_L-1)
    119  211b		       f5		      .byte.b	>(LEVEL__014_R-1)
    120  211c		       f5		      .byte.b	>(LEVEL__015_L-1)
    121  211d		       f5		      .byte.b	>(LEVEL__015_R-1)
    122  211e		       f5		      .byte.b	>(LEVEL__016_L-1)
    123  211f		       f5		      .byte.b	>(LEVEL__016_R-1)
    124  2120		       f6		      .byte.b	>(LEVEL__017_L-1)
    125  2121		       f6		      .byte.b	>(LEVEL__017_R-1)
    126  2122		       f6		      .byte.b	>(LEVEL__018_L-1)
    127  2123		       f6		      .byte.b	>(LEVEL__018_R-1)
    128  2124		       f7		      .byte.b	>(LEVEL__019_L-1)
    129  2125		       f7		      .byte.b	>(LEVEL__019_R-1)
    130  2126
    131  2126				  -	      IF	(* - LevelInfoHI != MAX_LEVEL)
    132  2126				  -	      ECHO	"ERROR: Incorrect LevelInfoHI table!"
    133  2126				  -	      ERR
    134  2126					      ENDIF
    135  2126
    136  2200		       00 00 00 00*	      align	256
      0  2200					      DEFINE_SUBROUTINE	LevelInfoBANK
      1  2200		       00 04	   BANK_LevelInfoBANK =	_CURRENT_BANK
      2  2200					      SUBROUTINE
      3  2200				   LevelInfoBANK
    138  2200
    139  2200		       05		      .byte.b	BANK_LEVEL__001_L
    140  2201		       05		      .byte.b	BANK_LEVEL__001_R
    141  2202		       05		      .byte.b	BANK_LEVEL__002_L
    142  2203		       05		      .byte.b	BANK_LEVEL__002_R
    143  2204		       05		      .byte.b	BANK_LEVEL__003_L
    144  2205		       05		      .byte.b	BANK_LEVEL__003_R
    145  2206		       05		      .byte.b	BANK_LEVEL__004_L
    146  2207		       05		      .byte.b	BANK_LEVEL__004_R
    147  2208		       05		      .byte.b	BANK_LEVEL__005_L
    148  2209		       05		      .byte.b	BANK_LEVEL__005_R
    149  220a		       05		      .byte.b	BANK_LEVEL__006_L
    150  220b		       05		      .byte.b	BANK_LEVEL__006_R
    151  220c		       05		      .byte.b	BANK_LEVEL__007_L
    152  220d		       05		      .byte.b	BANK_LEVEL__007_R
    153  220e		       05		      .byte.b	BANK_LEVEL__008_L
    154  220f		       05		      .byte.b	BANK_LEVEL__008_R
    155  2210		       05		      .byte.b	BANK_LEVEL__009_L
    156  2211		       05		      .byte.b	BANK_LEVEL__009_R
    157  2212		       05		      .byte.b	BANK_LEVEL__010_L
    158  2213		       05		      .byte.b	BANK_LEVEL__010_R
    159  2214		       05		      .byte.b	BANK_LEVEL__011_L
    160  2215		       05		      .byte.b	BANK_LEVEL__011_R
    161  2216		       05		      .byte.b	BANK_LEVEL__012_L
    162  2217		       05		      .byte.b	BANK_LEVEL__012_R
    163  2218		       05		      .byte.b	BANK_LEVEL__013_L
    164  2219		       05		      .byte.b	BANK_LEVEL__013_R
    165  221a		       05		      .byte.b	BANK_LEVEL__014_L
    166  221b		       05		      .byte.b	BANK_LEVEL__014_R
    167  221c		       05		      .byte.b	BANK_LEVEL__015_L
    168  221d		       05		      .byte.b	BANK_LEVEL__015_R
    169  221e		       05		      .byte.b	BANK_LEVEL__016_L
    170  221f		       05		      .byte.b	BANK_LEVEL__016_R
    171  2220		       05		      .byte.b	BANK_LEVEL__017_L
    172  2221		       05		      .byte.b	BANK_LEVEL__017_R
    173  2222		       05		      .byte.b	BANK_LEVEL__018_L
    174  2223		       05		      .byte.b	BANK_LEVEL__018_R
    175  2224		       05		      .byte.b	BANK_LEVEL__019_L
    176  2225		       05		      .byte.b	BANK_LEVEL__019_R
    177  2226
    178  2226
    179  2226				  -	      IF	(* - LevelInfoBANK != MAX_LEVEL)
    180  2226				  -	      ECHO	"ERROR: Incorrect LevelInfoBANK table!"
    181  2226				  -	      ERR
    182  2226					      ENDIF
    183  2226
    184  2226
      0  2226					      DEFINE_SUBROUTINE	GetLevelAddress
      1  2226		       00 04	   BANK_GetLevelAddress =	_CURRENT_BANK
      2  2226					      SUBROUTINE
      3  2226				   GetLevelAddress
    186  2226							; returns address,bank of level #
    187  2226							; Uses overlay LevelLookup
    188  2226							; relies on tables being page-aligned
    189  2226
    190  2226		       18		      clc
    191  2227		       a5 b1		      lda	levelX
    192  2229		       85 db		      sta	levelTable
    193  222b							;		  lda levelX+1
    194  222b		       a9 f0		      lda	#>LevelInfoLO
    195  222d		       85 dc		      sta	levelTable+1
    196  222f
    197  222f		       a0 00		      ldy	#0
    198  2231		       b1 db		      lda	(levelTable),y
    199  2233		       85 ba		      sta	Board_AddressR
    200  2235
    201  2235							;		  lda levelX+1
    202  2235		       a9 f1		      lda	#>LevelInfoHI
    203  2237		       85 dc		      sta	levelTable+1
    204  2239
    205  2239		       b1 db		      lda	(levelTable),y
    206  223b		       85 bb		      sta	Board_AddressR+1
    207  223d
    208  223d							;lda levelX+1
    209  223d		       a9 f2		      lda	#>LevelInfoBANK
    210  223f		       85 dc		      sta	levelTable+1
    211  2241
    212  2241		       b1 db		      lda	(levelTable),y
    213  2243		       85 ab		      sta	LEVEL_bank
    214  2245
    215  2245		       60		      rts
    216  2246
    217  2246
      0  2246					      CHECK_BANK_SIZE	"LEVELS_TABLES -- full 2K"
      1  2246		       02 46	   .TEMP      =	* - BANK_START
 LEVELS_TABLES -- full 2K (2K) SIZE =  $246 , FREE= $5ba
      2  2246					      ECHO	"LEVELS_TABLES -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2246				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2246				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2246				  -	      ERR
      6  2246					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS1.asm LEVEL 2 PASS 3
      0  2246					      include	"BANK_LEVELS1.asm"
      1  2246							;    Sokoboo - a Sokoban implementation
      2  2246							;    using a generic tile-based display engine for the Atari 2600
      3  2246							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  2246							;
      5  2246							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  2246							;
      7  2246							;    Code related to the generic tile-based display engine was developed by
      8  2246							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  2246							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  2246							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  2246							;
     12  2246							;    Code related to music and sound effects uses the TIATracker music player
     13  2246							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  2246							;    directory for Apache licensing details.
     15  2246							;
     16  2246							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  2246							;    See the copyright notices in the License directory for a list of level
     18  2246							;    contributors.
     19  2246							;
     20  2246							;    Except where otherwise indicated, this software is released under the
     21  2246							;    following licensing arrangement...
     22  2246							;
     23  2246							;    This program is free software: you can redistribute it and/or modify
     24  2246							;    it under the terms of the GNU General Public License as published by
     25  2246							;    the Free Software Foundation, either version 3 of the License, or
     26  2246							;    (at your option) any later version.
     27  2246							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  2246
     29  2246							;    This program is distributed in the hope that it will be useful,
     30  2246							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  2246							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  2246							;    GNU General Public License for more details.
     33  2246
      0  2246					      NEWBANK	LEVELS1
      1  2fb5 ????				      SEG	LEVELS1
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   LEVELS1    SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	LEVELS1
     35  2800
     36  2800
     37  2800							;  DEFL _000_SELECT, "12#|#@3-5$.#|10-|10-|12#"
     38  2800
     39  2800							; "SOKWHOLE" collection...
     40  2800
     41  2800
      0  2800					      DEFL	_001_L, "3#|#@#|#$#|#.#|3#"
      0  2800					      START_LEVEL	_001_L
      1  2800				   LEVEL_START SET	*
      2  2800		       00 05	   BANK_LEVEL__001_L =	_CURRENT_BANK
      3  2800				   LEVEL__001_L SUBROUTINE
      4  2800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2800
      2  2800		       33 23 7c 23*	      .byte.b	"3#|#@#|#$#|#.#|3#",0
      0  2812					      END_LEVEL	_001_L
      1  2812		       00 12	   LEVEL_SIZE__001_L =	* - LEVEL_START
      2  2812					      IF	LEVEL_SIZE__001_L > MAX_LEVEL_SIZE
      3  2812				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_L
      4  2812					      ENDIF
      0  2812					      DEFL	_001_R, "5#|#.$@#|5#"
      0  2812					      START_LEVEL	_001_R
      1  2812				   LEVEL_START SET	*
      2  2812		       00 05	   BANK_LEVEL__001_R =	_CURRENT_BANK
      3  2812				   LEVEL__001_R SUBROUTINE
      4  2812				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2812
      2  2812		       35 23 7c 23*	      .byte.b	"5#|#.$@#|5#",0
      0  281e					      END_LEVEL	_001_R
      1  281e		       00 0c	   LEVEL_SIZE__001_R =	* - LEVEL_START
      2  281e				  -	      IF	LEVEL_SIZE__001_R > MAX_LEVEL_SIZE
      3  281e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_R
      4  281e					      ENDIF
      0  281e					      DEFL	_002_L, "3#2-|#.3#|#*$-#|#2-@#|5#"
      0  281e					      START_LEVEL	_002_L
      1  281e				   LEVEL_START SET	*
      2  281e		       00 05	   BANK_LEVEL__002_L =	_CURRENT_BANK
      3  281e				   LEVEL__002_L SUBROUTINE
      4  281e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  281e
      2  281e		       33 23 32 2d*	      .byte.b	"3#2-|#.3#|#*$-#|#2-@#|5#",0
      0  2837					      END_LEVEL	_002_L
      1  2837		       00 19	   LEVEL_SIZE__002_L =	* - LEVEL_START
      2  2837					      IF	LEVEL_SIZE__002_L > MAX_LEVEL_SIZE
      3  2837				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_L
      4  2837					      ENDIF
      0  2837					      DEFL	_002_R, "2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#"
      0  2837					      START_LEVEL	_002_R
      1  2837				   LEVEL_START SET	*
      2  2837		       00 05	   BANK_LEVEL__002_R =	_CURRENT_BANK
      3  2837				   LEVEL__002_R SUBROUTINE
      4  2837				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2837
      2  2837		       32 2d 35 23*	      .byte.b	"2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#",0
      0  285f					      END_LEVEL	_002_R
      1  285f		       00 28	   LEVEL_SIZE__002_R =	* - LEVEL_START
      2  285f					      IF	LEVEL_SIZE__002_R > MAX_LEVEL_SIZE
      3  285f				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_R
      4  285f					      ENDIF
      0  285f					      DEFL	_003_L, "4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-"
      0  285f					      START_LEVEL	_003_L
      1  285f				   LEVEL_START SET	*
      2  285f		       00 05	   BANK_LEVEL__003_L =	_CURRENT_BANK
      3  285f				   LEVEL__003_L SUBROUTINE
      4  285f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  285f
      2  285f		       34 2d 35 23*	      .byte.b	"4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-",0
      0  288b					      END_LEVEL	_003_L
      1  288b		       00 2c	   LEVEL_SIZE__003_L =	* - LEVEL_START
      2  288b					      IF	LEVEL_SIZE__003_L > MAX_LEVEL_SIZE
      3  288b				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_L
      4  288b					      ENDIF
      0  288b					      DEFL	_003_R, "9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-"
      0  288b					      START_LEVEL	_003_R
      1  288b				   LEVEL_START SET	*
      2  288b		       00 05	   BANK_LEVEL__003_R =	_CURRENT_BANK
      3  288b				   LEVEL__003_R SUBROUTINE
      4  288b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  288b
      2  288b		       39 23 7c 23*	      .byte.b	"9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-",0
      0  28b5					      END_LEVEL	_003_R
      1  28b5		       00 2a	   LEVEL_SIZE__003_R =	* - LEVEL_START
      2  28b5				  -	      IF	LEVEL_SIZE__003_R > MAX_LEVEL_SIZE
      3  28b5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_R
      4  28b5					      ENDIF
      0  28b5					      DEFL	_004_L, "5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-"
      0  28b5					      START_LEVEL	_004_L
      1  28b5				   LEVEL_START SET	*
      2  28b5		       00 05	   BANK_LEVEL__004_L =	_CURRENT_BANK
      3  28b5				   LEVEL__004_L SUBROUTINE
      4  28b5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  28b5
      2  28b5		       35 23 2d 7c*	      .byte.b	"5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-",0
      0  28d8					      END_LEVEL	_004_L
      1  28d8		       00 23	   LEVEL_SIZE__004_L =	* - LEVEL_START
      2  28d8				  -	      IF	LEVEL_SIZE__004_L > MAX_LEVEL_SIZE
      3  28d8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_L
      4  28d8					      ENDIF
      0  28d8					      DEFL	_004_R, "-6#|-#4-#|2#-$*$#|#@$3.#|7#"
      0  28d8					      START_LEVEL	_004_R
      1  28d8				   LEVEL_START SET	*
      2  28d8		       00 05	   BANK_LEVEL__004_R =	_CURRENT_BANK
      3  28d8				   LEVEL__004_R SUBROUTINE
      4  28d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  28d8
      2  28d8		       2d 36 23 7c*	      .byte.b	"-6#|-#4-#|2#-$*$#|#@$3.#|7#",0
      0  28f4					      END_LEVEL	_004_R
      1  28f4		       00 1c	   LEVEL_SIZE__004_R =	* - LEVEL_START
      2  28f4				  -	      IF	LEVEL_SIZE__004_R > MAX_LEVEL_SIZE
      3  28f4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_R
      4  28f4					      ENDIF
      0  28f4					      DEFL	_005_L, "3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-"
      0  28f4					      START_LEVEL	_005_L
      1  28f4				   LEVEL_START SET	*
      2  28f4		       00 05	   BANK_LEVEL__005_L =	_CURRENT_BANK
      3  28f4				   LEVEL__005_L SUBROUTINE
      4  28f4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  28f4
      2  28f4		       33 2d 35 23*	      .byte.b	"3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-",0
      0  2926					      END_LEVEL	_005_L
      1  2926		       00 32	   LEVEL_SIZE__005_L =	* - LEVEL_START
      2  2926					      IF	LEVEL_SIZE__005_L > MAX_LEVEL_SIZE
      3  2926				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_L
      4  2926					      ENDIF
      0  2926					      DEFL	_005_R, "6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-"
      0  2926					      START_LEVEL	_005_R
      1  2926				   LEVEL_START SET	*
      2  2926		       00 05	   BANK_LEVEL__005_R =	_CURRENT_BANK
      3  2926				   LEVEL__005_R SUBROUTINE
      4  2926				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2926
      2  2926		       36 23 32 2d*	      .byte.b	"6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-",0
      0  2965					      END_LEVEL	_005_R
      1  2965		       00 3f	   LEVEL_SIZE__005_R =	* - LEVEL_START
      2  2965					      IF	LEVEL_SIZE__005_R > MAX_LEVEL_SIZE
      3  2965				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_R
      4  2965					      ENDIF
      0  2965					      DEFL	_006_L, "5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-"
      0  2965					      START_LEVEL	_006_L
      1  2965				   LEVEL_START SET	*
      2  2965		       00 05	   BANK_LEVEL__006_L =	_CURRENT_BANK
      3  2965				   LEVEL__006_L SUBROUTINE
      4  2965				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2965
      2  2965		       35 23 33 2d*	      .byte.b	"5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-",0
      0  29a0					      END_LEVEL	_006_L
      1  29a0		       00 3b	   LEVEL_SIZE__006_L =	* - LEVEL_START
      2  29a0				  -	      IF	LEVEL_SIZE__006_L > MAX_LEVEL_SIZE
      3  29a0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_L
      4  29a0					      ENDIF
      0  29a0					      DEFL	_006_R, "3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-"
      0  29a0					      START_LEVEL	_006_R
      1  29a0				   LEVEL_START SET	*
      2  29a0		       00 05	   BANK_LEVEL__006_R =	_CURRENT_BANK
      3  29a0				   LEVEL__006_R SUBROUTINE
      4  29a0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  29a0
      2  29a0		       33 23 34 2d*	      .byte.b	"3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-",0
      0  29de					      END_LEVEL	_006_R
      1  29de		       00 3e	   LEVEL_SIZE__006_R =	* - LEVEL_START
      2  29de				  -	      IF	LEVEL_SIZE__006_R > MAX_LEVEL_SIZE
      3  29de				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_R
      4  29de					      ENDIF
      0  29de					      DEFL	_007_L, "6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#"
      0  29de					      START_LEVEL	_007_L
      1  29de				   LEVEL_START SET	*
      2  29de		       00 05	   BANK_LEVEL__007_L =	_CURRENT_BANK
      3  29de				   LEVEL__007_L SUBROUTINE
      4  29de				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  29de
      2  29de		       36 23 2d 7c*	      .byte.b	"6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#",0
      0  2a0b					      END_LEVEL	_007_L
      1  2a0b		       00 2d	   LEVEL_SIZE__007_L =	* - LEVEL_START
      2  2a0b				  -	      IF	LEVEL_SIZE__007_L > MAX_LEVEL_SIZE
      3  2a0b				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_L
      4  2a0b					      ENDIF
      0  2a0b					      DEFL	_007_R, "4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#"
      0  2a0b					      START_LEVEL	_007_R
      1  2a0b				   LEVEL_START SET	*
      2  2a0b		       00 05	   BANK_LEVEL__007_R =	_CURRENT_BANK
      3  2a0b				   LEVEL__007_R SUBROUTINE
      4  2a0b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a0b
      2  2a0b		       34 23 34 2d*	      .byte.b	"4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#",0
      0  2a3e					      END_LEVEL	_007_R
      1  2a3e		       00 33	   LEVEL_SIZE__007_R =	* - LEVEL_START
      2  2a3e				  -	      IF	LEVEL_SIZE__007_R > MAX_LEVEL_SIZE
      3  2a3e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_R
      4  2a3e					      ENDIF
      0  2a3e					      DEFL	_008_L, "2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-"
      0  2a3e					      START_LEVEL	_008_L
      1  2a3e				   LEVEL_START SET	*
      2  2a3e		       00 05	   BANK_LEVEL__008_L =	_CURRENT_BANK
      3  2a3e				   LEVEL__008_L SUBROUTINE
      4  2a3e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a3e
      2  2a3e		       32 2d 35 23*	      .byte.b	"2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-",0
      0  2a74					      END_LEVEL	_008_L
      1  2a74		       00 36	   LEVEL_SIZE__008_L =	* - LEVEL_START
      2  2a74				  -	      IF	LEVEL_SIZE__008_L > MAX_LEVEL_SIZE
      3  2a74				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_L
      4  2a74					      ENDIF
      0  2a74					      DEFL	_008_R, "-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#"
      0  2a74					      START_LEVEL	_008_R
      1  2a74				   LEVEL_START SET	*
      2  2a74		       00 05	   BANK_LEVEL__008_R =	_CURRENT_BANK
      3  2a74				   LEVEL__008_R SUBROUTINE
      4  2a74				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a74
      2  2a74		       2d 35 23 33*	      .byte.b	"-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#",0
      0  2aa5					      END_LEVEL	_008_R
      1  2aa5		       00 31	   LEVEL_SIZE__008_R =	* - LEVEL_START
      2  2aa5				  -	      IF	LEVEL_SIZE__008_R > MAX_LEVEL_SIZE
      3  2aa5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_R
      4  2aa5					      ENDIF
      0  2aa5					      DEFL	_009_L, "-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#"
      0  2aa5					      START_LEVEL	_009_L
      1  2aa5				   LEVEL_START SET	*
      2  2aa5		       00 05	   BANK_LEVEL__009_L =	_CURRENT_BANK
      3  2aa5				   LEVEL__009_L SUBROUTINE
      4  2aa5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2aa5
      2  2aa5		       2d 35 23 2d*	      .byte.b	"-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#",0
      0  2ad7					      END_LEVEL	_009_L
      1  2ad7		       00 32	   LEVEL_SIZE__009_L =	* - LEVEL_START
      2  2ad7				  -	      IF	LEVEL_SIZE__009_L > MAX_LEVEL_SIZE
      3  2ad7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_L
      4  2ad7					      ENDIF
      0  2ad7					      DEFL	_009_R, "-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#"
      0  2ad7					      START_LEVEL	_009_R
      1  2ad7				   LEVEL_START SET	*
      2  2ad7		       00 05	   BANK_LEVEL__009_R =	_CURRENT_BANK
      3  2ad7				   LEVEL__009_R SUBROUTINE
      4  2ad7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ad7
      2  2ad7		       2d 33 23 33*	      .byte.b	"-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#",0
      0  2b07					      END_LEVEL	_009_R
      1  2b07		       00 30	   LEVEL_SIZE__009_R =	* - LEVEL_START
      2  2b07				  -	      IF	LEVEL_SIZE__009_R > MAX_LEVEL_SIZE
      3  2b07				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_R
      4  2b07					      ENDIF
      0  2b07					      DEFL	_010_L, "2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-"
      0  2b07					      START_LEVEL	_010_L
      1  2b07				   LEVEL_START SET	*
      2  2b07		       00 05	   BANK_LEVEL__010_L =	_CURRENT_BANK
      3  2b07				   LEVEL__010_L SUBROUTINE
      4  2b07				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b07
      2  2b07		       32 2d 33 23*	      .byte.b	"2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-",0
      0  2b41					      END_LEVEL	_010_L
      1  2b41		       00 3a	   LEVEL_SIZE__010_L =	* - LEVEL_START
      2  2b41				  -	      IF	LEVEL_SIZE__010_L > MAX_LEVEL_SIZE
      3  2b41				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_L
      4  2b41					      ENDIF
      0  2b41					      DEFL	_010_R, "4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-"
      0  2b41					      START_LEVEL	_010_R
      1  2b41				   LEVEL_START SET	*
      2  2b41		       00 05	   BANK_LEVEL__010_R =	_CURRENT_BANK
      3  2b41				   LEVEL__010_R SUBROUTINE
      4  2b41				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b41
      2  2b41		       34 23 32 2d*	      .byte.b	"4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-",0
      0  2b74					      END_LEVEL	_010_R
      1  2b74		       00 33	   LEVEL_SIZE__010_R =	* - LEVEL_START
      2  2b74				  -	      IF	LEVEL_SIZE__010_R > MAX_LEVEL_SIZE
      3  2b74				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_R
      4  2b74					      ENDIF
      0  2b74					      DEFL	_011_L, "-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-"
      0  2b74					      START_LEVEL	_011_L
      1  2b74				   LEVEL_START SET	*
      2  2b74		       00 05	   BANK_LEVEL__011_L =	_CURRENT_BANK
      3  2b74				   LEVEL__011_L SUBROUTINE
      4  2b74				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b74
      2  2b74		       2d 34 23 32*	      .byte.b	"-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-",0
      0  2ba7					      END_LEVEL	_011_L
      1  2ba7		       00 33	   LEVEL_SIZE__011_L =	* - LEVEL_START
      2  2ba7				  -	      IF	LEVEL_SIZE__011_L > MAX_LEVEL_SIZE
      3  2ba7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_L
      4  2ba7					      ENDIF
      0  2ba7					      DEFL	_011_R, "2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#"
      0  2ba7					      START_LEVEL	_011_R
      1  2ba7				   LEVEL_START SET	*
      2  2ba7		       00 05	   BANK_LEVEL__011_R =	_CURRENT_BANK
      3  2ba7				   LEVEL__011_R SUBROUTINE
      4  2ba7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ba7
      2  2ba7		       32 2d 33 23*	      .byte.b	"2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#",0
      0  2be1					      END_LEVEL	_011_R
      1  2be1		       00 3a	   LEVEL_SIZE__011_R =	* - LEVEL_START
      2  2be1				  -	      IF	LEVEL_SIZE__011_R > MAX_LEVEL_SIZE
      3  2be1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_R
      4  2be1					      ENDIF
      0  2be1					      DEFL	_012_L, "7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#"
      0  2be1					      START_LEVEL	_012_L
      1  2be1				   LEVEL_START SET	*
      2  2be1		       00 05	   BANK_LEVEL__012_L =	_CURRENT_BANK
      3  2be1				   LEVEL__012_L SUBROUTINE
      4  2be1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2be1
      2  2be1		       37 23 33 2d*	      .byte.b	"7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#",0
      0  2c11					      END_LEVEL	_012_L
      1  2c11		       00 30	   LEVEL_SIZE__012_L =	* - LEVEL_START
      2  2c11				  -	      IF	LEVEL_SIZE__012_L > MAX_LEVEL_SIZE
      3  2c11				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_L
      4  2c11					      ENDIF
      0  2c11					      DEFL	_012_R, "-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-"
      0  2c11					      START_LEVEL	_012_R
      1  2c11				   LEVEL_START SET	*
      2  2c11		       00 05	   BANK_LEVEL__012_R =	_CURRENT_BANK
      3  2c11				   LEVEL__012_R SUBROUTINE
      4  2c11				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c11
      2  2c11		       2d 36 23 32*	      .byte.b	"-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-",0
      0  2c4d					      END_LEVEL	_012_R
      1  2c4d		       00 3c	   LEVEL_SIZE__012_R =	* - LEVEL_START
      2  2c4d				  -	      IF	LEVEL_SIZE__012_R > MAX_LEVEL_SIZE
      3  2c4d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_R
      4  2c4d					      ENDIF
      0  2c4d					      DEFL	_013_L, "2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-"
      0  2c4d					      START_LEVEL	_013_L
      1  2c4d				   LEVEL_START SET	*
      2  2c4d		       00 05	   BANK_LEVEL__013_L =	_CURRENT_BANK
      3  2c4d				   LEVEL__013_L SUBROUTINE
      4  2c4d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c4d
      2  2c4d		       32 2d 35 23*	      .byte.b	"2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-",0
      0  2c8c					      END_LEVEL	_013_L
      1  2c8c		       00 3f	   LEVEL_SIZE__013_L =	* - LEVEL_START
      2  2c8c				  -	      IF	LEVEL_SIZE__013_L > MAX_LEVEL_SIZE
      3  2c8c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_L
      4  2c8c					      ENDIF
      0  2c8c					      DEFL	_013_R, "-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-"
      0  2c8c					      START_LEVEL	_013_R
      1  2c8c				   LEVEL_START SET	*
      2  2c8c		       00 05	   BANK_LEVEL__013_R =	_CURRENT_BANK
      3  2c8c				   LEVEL__013_R SUBROUTINE
      4  2c8c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c8c
      2  2c8c		       2d 35 23 32*	      .byte.b	"-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-",0
      0  2cbf					      END_LEVEL	_013_R
      1  2cbf		       00 33	   LEVEL_SIZE__013_R =	* - LEVEL_START
      2  2cbf				  -	      IF	LEVEL_SIZE__013_R > MAX_LEVEL_SIZE
      3  2cbf				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_R
      4  2cbf					      ENDIF
      0  2cbf					      DEFL	_014_L, "6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#"
      0  2cbf					      START_LEVEL	_014_L
      1  2cbf				   LEVEL_START SET	*
      2  2cbf		       00 05	   BANK_LEVEL__014_L =	_CURRENT_BANK
      3  2cbf				   LEVEL__014_L SUBROUTINE
      4  2cbf				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2cbf
      2  2cbf		       36 23 34 2d*	      .byte.b	"6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#",0
      0  2d02					      END_LEVEL	_014_L
      1  2d02		       00 43	   LEVEL_SIZE__014_L =	* - LEVEL_START
      2  2d02					      IF	LEVEL_SIZE__014_L > MAX_LEVEL_SIZE
      3  2d02				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_L
      4  2d02					      ENDIF
      0  2d02					      DEFL	_014_R, "6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-"
      0  2d02					      START_LEVEL	_014_R
      1  2d02				   LEVEL_START SET	*
      2  2d02		       00 05	   BANK_LEVEL__014_R =	_CURRENT_BANK
      3  2d02				   LEVEL__014_R SUBROUTINE
      4  2d02				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d02
      2  2d02		       36 23 33 2d*	      .byte.b	"6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-",0
      0  2d45					      END_LEVEL	_014_R
      1  2d45		       00 43	   LEVEL_SIZE__014_R =	* - LEVEL_START
      2  2d45				  -	      IF	LEVEL_SIZE__014_R > MAX_LEVEL_SIZE
      3  2d45				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_R
      4  2d45					      ENDIF
      0  2d45					      DEFL	_015_L, "2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#"
      0  2d45					      START_LEVEL	_015_L
      1  2d45				   LEVEL_START SET	*
      2  2d45		       00 05	   BANK_LEVEL__015_L =	_CURRENT_BANK
      3  2d45				   LEVEL__015_L SUBROUTINE
      4  2d45				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d45
      2  2d45		       32 2d 35 23*	      .byte.b	"2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#",0
      0  2d7a					      END_LEVEL	_015_L
      1  2d7a		       00 35	   LEVEL_SIZE__015_L =	* - LEVEL_START
      2  2d7a				  -	      IF	LEVEL_SIZE__015_L > MAX_LEVEL_SIZE
      3  2d7a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_L
      4  2d7a					      ENDIF
      0  2d7a					      DEFL	_015_R, "3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-"
      0  2d7a					      START_LEVEL	_015_R
      1  2d7a				   LEVEL_START SET	*
      2  2d7a		       00 05	   BANK_LEVEL__015_R =	_CURRENT_BANK
      3  2d7a				   LEVEL__015_R SUBROUTINE
      4  2d7a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d7a
      2  2d7a		       33 2d 35 23*	      .byte.b	"3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-",0
      0  2dbf					      END_LEVEL	_015_R
      1  2dbf		       00 45	   LEVEL_SIZE__015_R =	* - LEVEL_START
      2  2dbf					      IF	LEVEL_SIZE__015_R > MAX_LEVEL_SIZE
      3  2dbf				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_R
      4  2dbf					      ENDIF
      0  2dbf					      DEFL	_016_L, "4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-"
      0  2dbf					      START_LEVEL	_016_L
      1  2dbf				   LEVEL_START SET	*
      2  2dbf		       00 05	   BANK_LEVEL__016_L =	_CURRENT_BANK
      3  2dbf				   LEVEL__016_L SUBROUTINE
      4  2dbf				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2dbf
      2  2dbf		       34 2d 33 23*	      .byte.b	"4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-",0
      0  2df6					      END_LEVEL	_016_L
      1  2df6		       00 37	   LEVEL_SIZE__016_L =	* - LEVEL_START
      2  2df6				  -	      IF	LEVEL_SIZE__016_L > MAX_LEVEL_SIZE
      3  2df6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_L
      4  2df6					      ENDIF
      0  2df6					      DEFL	_016_R, "5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-"
      0  2df6					      START_LEVEL	_016_R
      1  2df6				   LEVEL_START SET	*
      2  2df6		       00 05	   BANK_LEVEL__016_R =	_CURRENT_BANK
      3  2df6				   LEVEL__016_R SUBROUTINE
      4  2df6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2df6
      2  2df6		       35 23 2d 7c*	      .byte.b	"5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-",0
      0  2e29					      END_LEVEL	_016_R
      1  2e29		       00 33	   LEVEL_SIZE__016_R =	* - LEVEL_START
      2  2e29				  -	      IF	LEVEL_SIZE__016_R > MAX_LEVEL_SIZE
      3  2e29				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_R
      4  2e29					      ENDIF
      0  2e29					      DEFL	_017_L, "5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-"
      0  2e29					      START_LEVEL	_017_L
      1  2e29				   LEVEL_START SET	*
      2  2e29		       00 05	   BANK_LEVEL__017_L =	_CURRENT_BANK
      3  2e29				   LEVEL__017_L SUBROUTINE
      4  2e29				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e29
      2  2e29		       35 23 34 2d*	      .byte.b	"5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-",0
      0  2e73					      END_LEVEL	_017_L
      1  2e73		       00 4a	   LEVEL_SIZE__017_L =	* - LEVEL_START
      2  2e73					      IF	LEVEL_SIZE__017_L > MAX_LEVEL_SIZE
      3  2e73				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_L
      4  2e73					      ENDIF
      0  2e73					      DEFL	_017_R, "3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-"
      0  2e73					      START_LEVEL	_017_R
      1  2e73				   LEVEL_START SET	*
      2  2e73		       00 05	   BANK_LEVEL__017_R =	_CURRENT_BANK
      3  2e73				   LEVEL__017_R SUBROUTINE
      4  2e73				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e73
      2  2e73		       33 2d 34 23*	      .byte.b	"3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-",0
      0  2eb6					      END_LEVEL	_017_R
      1  2eb6		       00 43	   LEVEL_SIZE__017_R =	* - LEVEL_START
      2  2eb6				  -	      IF	LEVEL_SIZE__017_R > MAX_LEVEL_SIZE
      3  2eb6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_R
      4  2eb6					      ENDIF
      0  2eb6					      DEFL	_018_L, "6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#"
      0  2eb6					      START_LEVEL	_018_L
      1  2eb6				   LEVEL_START SET	*
      2  2eb6		       00 05	   BANK_LEVEL__018_L =	_CURRENT_BANK
      3  2eb6				   LEVEL__018_L SUBROUTINE
      4  2eb6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2eb6
      2  2eb6		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#",0
      0  2eea					      END_LEVEL	_018_L
      1  2eea		       00 34	   LEVEL_SIZE__018_L =	* - LEVEL_START
      2  2eea				  -	      IF	LEVEL_SIZE__018_L > MAX_LEVEL_SIZE
      3  2eea				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_L
      4  2eea					      ENDIF
      0  2eea					      DEFL	_018_R, "-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#"
      0  2eea					      START_LEVEL	_018_R
      1  2eea				   LEVEL_START SET	*
      2  2eea		       00 05	   BANK_LEVEL__018_R =	_CURRENT_BANK
      3  2eea				   LEVEL__018_R SUBROUTINE
      4  2eea				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2eea
      2  2eea		       2d 34 23 33*	      .byte.b	"-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#",0
      0  2f26					      END_LEVEL	_018_R
      1  2f26		       00 3c	   LEVEL_SIZE__018_R =	* - LEVEL_START
      2  2f26				  -	      IF	LEVEL_SIZE__018_R > MAX_LEVEL_SIZE
      3  2f26				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_R
      4  2f26					      ENDIF
      0  2f26					      DEFL	_019_L, "4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#"
      0  2f26					      START_LEVEL	_019_L
      1  2f26				   LEVEL_START SET	*
      2  2f26		       00 05	   BANK_LEVEL__019_L =	_CURRENT_BANK
      3  2f26				   LEVEL__019_L SUBROUTINE
      4  2f26				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2f26
      2  2f26		       34 2d 35 23*	      .byte.b	"4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#",0
      0  2f61					      END_LEVEL	_019_L
      1  2f61		       00 3b	   LEVEL_SIZE__019_L =	* - LEVEL_START
      2  2f61				  -	      IF	LEVEL_SIZE__019_L > MAX_LEVEL_SIZE
      3  2f61				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_L
      4  2f61					      ENDIF
      0  2f61					      DEFL	_019_R, "2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#"
      0  2f61					      START_LEVEL	_019_R
      1  2f61				   LEVEL_START SET	*
      2  2f61		       00 05	   BANK_LEVEL__019_R =	_CURRENT_BANK
      3  2f61				   LEVEL__019_R SUBROUTINE
      4  2f61				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2f61
      2  2f61		       32 2d 37 23*	      .byte.b	"2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#",0
      0  2fb1					      END_LEVEL	_019_R
      1  2fb1		       00 50	   LEVEL_SIZE__019_R =	* - LEVEL_START
      2  2fb1					      IF	LEVEL_SIZE__019_R > MAX_LEVEL_SIZE
      3  2fb1				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_R
      4  2fb1					      ENDIF
     80  2fb1
     81  2fb1							;-----------------------------------------------------------
     82  2fb1							; Stella 3E autodetect signature, can live anywhere
     83  2fb1		       85 3e a9 00	      .byte.b	$85, $3E, $A9, $00
     84  2fb5							;-----------------------------------------------------------
     85  2fb5
      0  2fb5					      CHECK_BANK_SIZE	"LEVELS1"
      1  2fb5		       07 b5	   .TEMP      =	* - BANK_START
 LEVELS1 (2K) SIZE =  $7b5 , FREE= $4b
      2  2fb5					      ECHO	"LEVELS1", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2fb5				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2fb5				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2fb5				  -	      ERR
      6  2fb5					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_PlayerFrames.asm LEVEL 2 PASS 3
      0  2fb5					      include	"BANK_PlayerFrames.asm"
      1  2fb5							;    Sokoboo - a Sokoban implementation
      2  2fb5							;    using a generic tile-based display engine for the Atari 2600
      3  2fb5							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  2fb5							;
      5  2fb5							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  2fb5							;
      7  2fb5							;    Code related to the generic tile-based display engine was developed by
      8  2fb5							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  2fb5							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  2fb5							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  2fb5							;
     12  2fb5							;    Code related to music and sound effects uses the TIATracker music player
     13  2fb5							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  2fb5							;    directory for Apache licensing details.
     15  2fb5							;
     16  2fb5							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  2fb5							;    See the copyright notices in the License directory for a list of level
     18  2fb5							;    contributors.
     19  2fb5							;
     20  2fb5							;    Except where otherwise indicated, this software is released under the
     21  2fb5							;    following licensing arrangement...
     22  2fb5							;
     23  2fb5							;    This program is free software: you can redistribute it and/or modify
     24  2fb5							;    it under the terms of the GNU General Public License as published by
     25  2fb5							;    the Free Software Foundation, either version 3 of the License, or
     26  2fb5							;    (at your option) any later version.
     27  2fb5							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  2fb5
     29  2fb5							;    This program is distributed in the hope that it will be useful,
     30  2fb5							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  2fb5							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  2fb5							;    GNU General Public License for more details.
     33  2fb5
      0  2fb5					      NEWBANK	PLAYER_FRAMES
      1  3594 ????				      SEG	PLAYER_FRAMES
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   PLAYER_FRAMES SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	PLAYER_FRAMES
     35  3000
     36  3000							;CL0	  = $0
     37  3000							;CL1	  = $4C   ;yellow
     38  3000							;CL2	  = $68
     39  3000							;CL3	  = $0C   ; cuffs/trim
     40  3000							;CL4	  = $B8   ; jumper
     41  3000							;CL5	  = $b2
     42  3000							;CL6	  = $66
     43  3000
     44  3000		       00 00	   CL0	      =	$0
     45  3000		       00 01	   CL1	      =	1	;$2C	;yellow
     46  3000		       00 02	   CL2	      =	2	;$24
     47  3000		       00 03	   CL3	      =	3	;$6A	; cuffs/trim
     48  3000		       00 04	   CL4	      =	4	;$44
     49  3000		       00 05	   CL5	      =	5	;$B6	; pants
     50  3000		       00 06	   CL6	      =	6	;$64
     51  3000
     52  3000
     53  3000
     54  3000		       00 ff	   JUMP       =	$FF
     55  3000		       00 fe	   FLIP       =	$FE
     56  3000
     57  3000					      MAC	flip
     58  3000					      .byte	FLIP,0
     59  3000					      ENDM
     60  3000
     61  3000					      MAC	goto
     62  3000					      .byte	JUMP
     63  3000					      .byte	ANIMATION_{1}_ID
     64  3000					      ENDM
     65  3000
     66  3000					      MAC	show
     67  3000					      .byte	FRAME_{1},{2}
     68  3000					      ENDM
     69  3000
     70  3000
     71  3000				   ANIM_INDEX SET	0
     72  3000					      MAC	insert_animation
     73  3000				   ANIMATION_{1}_ID =	ANIM_INDEX
     74  3000					      .word	Animation_{1}
     75  3000				   ANIM_INDEX SET	ANIM_INDEX + 2
     76  3000					      ENDM		; {animation address}
     77  3000
     78  3000				   ANIM_TABLE
      0  3000					      INSERT_ANIMATION	WALK
      1  3000		       00 00	   ANIMATION_WALK_ID =	ANIM_INDEX
      2  3000		       18 f0		      .word.w	Animation_WALK
      3  3000				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  3002					      INSERT_ANIMATION	IDLE
      1  3002		       00 02	   ANIMATION_IDLE_ID =	ANIM_INDEX
      2  3002		       4a f0		      .word.w	Animation_IDLE
      3  3002				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  3004					      INSERT_ANIMATION	WIN
      1  3004		       00 04	   ANIMATION_WIN_ID =	ANIM_INDEX
      2  3004		       24 f0		      .word.w	Animation_WIN
      3  3004				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  3006					      INSERT_ANIMATION	WIN2
      1  3006		       00 06	   ANIMATION_WIN2_ID =	ANIM_INDEX
      2  3006		       24 f0		      .word.w	Animation_WIN2
      3  3006				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  3008					      INSERT_ANIMATION	PUSH
      1  3008		       00 08	   ANIMATION_PUSH_ID =	ANIM_INDEX
      2  3008		       ce f0		      .word.w	Animation_PUSH
      3  3008				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  300a					      INSERT_ANIMATION	PUSH0
      1  300a		       00 0a	   ANIMATION_PUSH0_ID =	ANIM_INDEX
      2  300a		       ce f0		      .word.w	Animation_PUSH0
      3  300a				   ANIM_INDEX SET	ANIM_INDEX + 2
     85  300c							;    INSERT_ANIMATION PUSHTRY
      0  300c					      INSERT_ANIMATION	PUSHUP
      1  300c		       00 0c	   ANIMATION_PUSHUP_ID =	ANIM_INDEX
      2  300c		       d8 f0		      .word.w	Animation_PUSHUP
      3  300c				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  300e					      INSERT_ANIMATION	PUSHUP2
      1  300e		       00 0e	   ANIMATION_PUSHUP2_ID =	ANIM_INDEX
      2  300e		       dc f0		      .word.w	Animation_PUSHUP2
      3  300e				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  3010					      INSERT_ANIMATION	PUSHDOWN
      1  3010		       00 10	   ANIMATION_PUSHDOWN_ID =	ANIM_INDEX
      2  3010		       e6 f0		      .word.w	Animation_PUSHDOWN
      3  3010				   ANIM_INDEX SET	ANIM_INDEX + 2
     89  3012
      0  3012					      INSERT_ANIMATION	WALK2
      1  3012		       00 12	   ANIMATION_WALK2_ID =	ANIM_INDEX
      2  3012		       1a f0		      .word.w	Animation_WALK2
      3  3012				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  3014					      INSERT_ANIMATION	TURNAROUND
      1  3014		       00 14	   ANIMATION_TURNAROUND_ID =	ANIM_INDEX
      2  3014		       ba f0		      .word.w	Animation_TURNAROUND
      3  3014				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  3016					      INSERT_ANIMATION	YAWN
      1  3016		       00 16	   ANIMATION_YAWN_ID =	ANIM_INDEX
      2  3016		       c4 f0		      .word.w	Animation_YAWN
      3  3016				   ANIM_INDEX SET	ANIM_INDEX + 2
     93  3018							;    INSERT_ANIMATION PUSH_START
     94  3018
     95  3018
     96  3018				   Animation_WALK
     97  3018
      0  3018					      SHOW	WALK2, 4
      1  3018		       02 04		      .byte.b	FRAME_WALK2,4
     99  301a
    100  301a				   Animation_WALK2
      0  301a					      SHOW	WALK3, 8
      1  301a		       05 08		      .byte.b	FRAME_WALK3,8
      0  301c					      SHOW	WALK2, 8
      1  301c		       02 08		      .byte.b	FRAME_WALK2,8
      0  301e					      SHOW	WALK1, 8
      1  301e		       01 08		      .byte.b	FRAME_WALK1,8
      0  3020					      SHOW	WALK2, 8
      1  3020		       02 08		      .byte.b	FRAME_WALK2,8
      0  3022					      GOTO	WALK2
      1  3022		       ff		      .byte.b	JUMP
      2  3023		       12		      .byte.b	ANIMATION_WALK2_ID
    106  3024
    107  3024
    108  3024				   Animation_WIN
    109  3024
    110  3024				   Animation_WIN2
    111  3024
      0  3024					      SHOW	IDLE1,10
      1  3024		       0d 0a		      .byte.b	FRAME_IDLE1,10
      0  3026					      SHOW	IDLE2,10
      1  3026		       0b 0a		      .byte.b	FRAME_IDLE2,10
      0  3028					      SHOW	IDLE1,10
      1  3028		       0d 0a		      .byte.b	FRAME_IDLE1,10
      0  302a					      SHOW	IDLE2,15
      1  302a		       0b 0f		      .byte.b	FRAME_IDLE2,15
      0  302c					      SHOW	IDLE3,15
      1  302c		       0a 0f		      .byte.b	FRAME_IDLE3,15
      0  302e					      GOTO	WIN2
      1  302e		       ff		      .byte.b	JUMP
      2  302f		       06		      .byte.b	ANIMATION_WIN2_ID
    118  3030
    119  3030
    120  3030
    121  3030
    122  3030				   Animation_WOBBLE
    123  3030
    124  3030							; pretty cool little wobble
    125  3030					      REPEAT	4
      0  3030					      SHOW	WALK2, 10
      1  3030		       02 0a		      .byte.b	FRAME_WALK2,10
      0  3032					      FLIP
      1  3032		       fe 00		      .byte.b	FLIP,0
      0  3034					      SHOW	LOOK2, 10
      1  3034		       11 0a		      .byte.b	FRAME_LOOK2,10
    125  3034					      REPEND
      0  3036					      SHOW	WALK2, 10
      1  3036		       02 0a		      .byte.b	FRAME_WALK2,10
      0  3038					      FLIP
      1  3038		       fe 00		      .byte.b	FLIP,0
      0  303a					      SHOW	LOOK2, 10
      1  303a		       11 0a		      .byte.b	FRAME_LOOK2,10
    125  303a					      REPEND
      0  303c					      SHOW	WALK2, 10
      1  303c		       02 0a		      .byte.b	FRAME_WALK2,10
      0  303e					      FLIP
      1  303e		       fe 00		      .byte.b	FLIP,0
      0  3040					      SHOW	LOOK2, 10
      1  3040		       11 0a		      .byte.b	FRAME_LOOK2,10
    125  3040					      REPEND
      0  3042					      SHOW	WALK2, 10
      1  3042		       02 0a		      .byte.b	FRAME_WALK2,10
      0  3044					      FLIP
      1  3044		       fe 00		      .byte.b	FLIP,0
      0  3046					      SHOW	LOOK2, 10
      1  3046		       11 0a		      .byte.b	FRAME_LOOK2,10
    129  3048					      REPEND
      0  3048					      GOTO	IDLE
      1  3048		       ff		      .byte.b	JUMP
      2  3049		       02		      .byte.b	ANIMATION_IDLE_ID
    131  304a
    132  304a
    133  304a
    134  304a				   Animation_IDLE
    135  304a
    136  304a					      REPEAT	2
    137  304a					      REPEAT	2
      0  304a					      SHOW	BLINK, 2
      1  304a		       0f 02		      .byte.b	FRAME_BLINK,2
      0  304c					      SHOW	WALK2, 255
      1  304c		       02 ff		      .byte.b	FRAME_WALK2,255
    137  304c					      REPEND
      0  304e					      SHOW	BLINK, 2
      1  304e		       0f 02		      .byte.b	FRAME_BLINK,2
      0  3050					      SHOW	WALK2, 255
      1  3050		       02 ff		      .byte.b	FRAME_WALK2,255
    140  3052					      REPEND
    141  3052					      REPEAT	6
      0  3052					      SHOW	HANDLIP1, 20
      1  3052		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  3054					      SHOW	HANDLIP2, 20
      1  3054		       14 14		      .byte.b	FRAME_HANDLIP2,20
    141  3054					      REPEND
      0  3056					      SHOW	HANDLIP1, 20
      1  3056		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  3058					      SHOW	HANDLIP2, 20
      1  3058		       14 14		      .byte.b	FRAME_HANDLIP2,20
    141  3058					      REPEND
      0  305a					      SHOW	HANDLIP1, 20
      1  305a		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  305c					      SHOW	HANDLIP2, 20
      1  305c		       14 14		      .byte.b	FRAME_HANDLIP2,20
    141  305c					      REPEND
      0  305e					      SHOW	HANDLIP1, 20
      1  305e		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  3060					      SHOW	HANDLIP2, 20
      1  3060		       14 14		      .byte.b	FRAME_HANDLIP2,20
    141  3060					      REPEND
      0  3062					      SHOW	HANDLIP1, 20
      1  3062		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  3064					      SHOW	HANDLIP2, 20
      1  3064		       14 14		      .byte.b	FRAME_HANDLIP2,20
    141  3064					      REPEND
      0  3066					      SHOW	HANDLIP1, 20
      1  3066		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  3068					      SHOW	HANDLIP2, 20
      1  3068		       14 14		      .byte.b	FRAME_HANDLIP2,20
    144  306a					      REPEND
    145  306a					      REPEAT	2
      0  306a					      SHOW	BLINK, 2
      1  306a		       0f 02		      .byte.b	FRAME_BLINK,2
      0  306c					      SHOW	WALK2, 255
      1  306c		       02 ff		      .byte.b	FRAME_WALK2,255
    145  306c					      REPEND
      0  306e					      SHOW	BLINK, 2
      1  306e		       0f 02		      .byte.b	FRAME_BLINK,2
      0  3070					      SHOW	WALK2, 255
      1  3070		       02 ff		      .byte.b	FRAME_WALK2,255
    148  3072					      REPEND
    149  3072					      REPEAT	3
      0  3072					      SHOW	TAPFOOT, 10
      1  3072		       15 0a		      .byte.b	FRAME_TAPFOOT,10
      0  3074					      SHOW	WALK2, 5
      1  3074		       02 05		      .byte.b	FRAME_WALK2,5
    149  3074					      REPEND
      0  3076					      SHOW	TAPFOOT, 10
      1  3076		       15 0a		      .byte.b	FRAME_TAPFOOT,10
      0  3078					      SHOW	WALK2, 5
      1  3078		       02 05		      .byte.b	FRAME_WALK2,5
    149  3078					      REPEND
      0  307a					      SHOW	TAPFOOT, 10
      1  307a		       15 0a		      .byte.b	FRAME_TAPFOOT,10
      0  307c					      SHOW	WALK2, 5
      1  307c		       02 05		      .byte.b	FRAME_WALK2,5
    152  307e					      REPEND
    136  307e					      REPEND
    137  307e					      REPEAT	2
      0  307e					      SHOW	BLINK, 2
      1  307e		       0f 02		      .byte.b	FRAME_BLINK,2
      0  3080					      SHOW	WALK2, 255
      1  3080		       02 ff		      .byte.b	FRAME_WALK2,255
    137  3080					      REPEND
      0  3082					      SHOW	BLINK, 2
      1  3082		       0f 02		      .byte.b	FRAME_BLINK,2
      0  3084					      SHOW	WALK2, 255
      1  3084		       02 ff		      .byte.b	FRAME_WALK2,255
    140  3086					      REPEND
    141  3086					      REPEAT	6
      0  3086					      SHOW	HANDLIP1, 20
      1  3086		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  3088					      SHOW	HANDLIP2, 20
      1  3088		       14 14		      .byte.b	FRAME_HANDLIP2,20
    141  3088					      REPEND
      0  308a					      SHOW	HANDLIP1, 20
      1  308a		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  308c					      SHOW	HANDLIP2, 20
      1  308c		       14 14		      .byte.b	FRAME_HANDLIP2,20
    141  308c					      REPEND
      0  308e					      SHOW	HANDLIP1, 20
      1  308e		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  3090					      SHOW	HANDLIP2, 20
      1  3090		       14 14		      .byte.b	FRAME_HANDLIP2,20
    141  3090					      REPEND
      0  3092					      SHOW	HANDLIP1, 20
      1  3092		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  3094					      SHOW	HANDLIP2, 20
      1  3094		       14 14		      .byte.b	FRAME_HANDLIP2,20
    141  3094					      REPEND
      0  3096					      SHOW	HANDLIP1, 20
      1  3096		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  3098					      SHOW	HANDLIP2, 20
      1  3098		       14 14		      .byte.b	FRAME_HANDLIP2,20
    141  3098					      REPEND
      0  309a					      SHOW	HANDLIP1, 20
      1  309a		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  309c					      SHOW	HANDLIP2, 20
      1  309c		       14 14		      .byte.b	FRAME_HANDLIP2,20
    144  309e					      REPEND
    145  309e					      REPEAT	2
      0  309e					      SHOW	BLINK, 2
      1  309e		       0f 02		      .byte.b	FRAME_BLINK,2
      0  30a0					      SHOW	WALK2, 255
      1  30a0		       02 ff		      .byte.b	FRAME_WALK2,255
    145  30a0					      REPEND
      0  30a2					      SHOW	BLINK, 2
      1  30a2		       0f 02		      .byte.b	FRAME_BLINK,2
      0  30a4					      SHOW	WALK2, 255
      1  30a4		       02 ff		      .byte.b	FRAME_WALK2,255
    148  30a6					      REPEND
    149  30a6					      REPEAT	3
      0  30a6					      SHOW	TAPFOOT, 10
      1  30a6		       15 0a		      .byte.b	FRAME_TAPFOOT,10
      0  30a8					      SHOW	WALK2, 5
      1  30a8		       02 05		      .byte.b	FRAME_WALK2,5
    149  30a8					      REPEND
      0  30aa					      SHOW	TAPFOOT, 10
      1  30aa		       15 0a		      .byte.b	FRAME_TAPFOOT,10
      0  30ac					      SHOW	WALK2, 5
      1  30ac		       02 05		      .byte.b	FRAME_WALK2,5
    149  30ac					      REPEND
      0  30ae					      SHOW	TAPFOOT, 10
      1  30ae		       15 0a		      .byte.b	FRAME_TAPFOOT,10
      0  30b0					      SHOW	WALK2, 5
      1  30b0		       02 05		      .byte.b	FRAME_WALK2,5
    152  30b2					      REPEND
    153  30b2					      REPEND
    154  30b2
      0  30b2					      SHOW	LOOK3, 3
      1  30b2		       12 03		      .byte.b	FRAME_LOOK3,3
      0  30b4					      SHOW	LOOK2, 30
      1  30b4		       11 1e		      .byte.b	FRAME_LOOK2,30
      0  30b6					      SHOW	LOOK3, 3
      1  30b6		       12 03		      .byte.b	FRAME_LOOK3,3
    158  30b8
      0  30b8					      GOTO	YAWN
      1  30b8		       ff		      .byte.b	JUMP
      2  30b9		       16		      .byte.b	ANIMATION_YAWN_ID
    160  30ba
    161  30ba
    162  30ba				   Animation_TURNAROUND
    163  30ba
      0  30ba					      SHOW	LOOK3, 1
      1  30ba		       12 01		      .byte.b	FRAME_LOOK3,1
      0  30bc					      SHOW	LOOK2, 1
      1  30bc		       11 01		      .byte.b	FRAME_LOOK2,1
      0  30be					      SHOW	LOOK1, 1
      1  30be		       13 01		      .byte.b	FRAME_LOOK1,1
      0  30c0					      FLIP
      1  30c0		       fe 00		      .byte.b	FLIP,0
      0  30c2					      GOTO	IDLE
      1  30c2		       ff		      .byte.b	JUMP
      2  30c3		       02		      .byte.b	ANIMATION_IDLE_ID
    169  30c4
    170  30c4				   Animation_YAWN
    171  30c4
    172  30c4							;    SHOW WALK2, 50
      0  30c4					      SHOW	IDLE1, 10
      1  30c4		       0d 0a		      .byte.b	FRAME_IDLE1,10
      0  30c6					      SHOW	IDLE2, 20
      1  30c6		       0b 14		      .byte.b	FRAME_IDLE2,20
      0  30c8					      SHOW	IDLE3, 150
      1  30c8		       0a 96		      .byte.b	FRAME_IDLE3,150
      0  30ca					      SHOW	IDLE2, 20
      1  30ca		       0b 14		      .byte.b	FRAME_IDLE2,20
      0  30cc					      GOTO	IDLE
      1  30cc		       ff		      .byte.b	JUMP
      2  30cd		       02		      .byte.b	ANIMATION_IDLE_ID
    178  30ce
    179  30ce
    180  30ce							;Animation_PUSHTRY
    181  30ce							;    .byte FRAME_PUSH1,20
    182  30ce							;    .byte FRAME_PUSH2,20
    183  30ce							;    .byte JUMP,ANIMATION_PUSHTRY_ID
    184  30ce
    185  30ce							;Animation_PUSH_START
    186  30ce
    187  30ce							;    .byte FRAME_WALK2,2
    188  30ce
    189  30ce				   Animation_PUSH
    190  30ce
    191  30ce							;    SHOW LOOKUP, 10
    192  30ce
    193  30ce				   Animation_PUSH0
    194  30ce
      0  30ce					      SHOW	PUSH1, 10
      1  30ce		       0e 0a		      .byte.b	FRAME_PUSH1,10
      0  30d0					      SHOW	PUSH2, 10
      1  30d0		       0c 0a		      .byte.b	FRAME_PUSH2,10
      0  30d2					      SHOW	PUSH3, 10
      1  30d2		       09 0a		      .byte.b	FRAME_PUSH3,10
      0  30d4					      SHOW	PUSH2, 10
      1  30d4		       0c 0a		      .byte.b	FRAME_PUSH2,10
      0  30d6					      GOTO	PUSH0
      1  30d6		       ff		      .byte.b	JUMP
      2  30d7		       0a		      .byte.b	ANIMATION_PUSH0_ID
    200  30d8
    201  30d8				   Animation_PUSHUP
    202  30d8
      0  30d8					      SHOW	LOOKUP, 40
      1  30d8		       04 28		      .byte.b	FRAME_LOOKUP,40
      0  30da					      GOTO	PUSHUP
      1  30da		       ff		      .byte.b	JUMP
      2  30db		       0c		      .byte.b	ANIMATION_PUSHUP_ID
    205  30dc
    206  30dc				   Animation_PUSHUP2
      0  30dc					      SHOW	PUSH_UP_1, 10
      1  30dc		       06 0a		      .byte.b	FRAME_PUSH_UP_1,10
      0  30de					      SHOW	PUSH_UP_2, 10
      1  30de		       08 0a		      .byte.b	FRAME_PUSH_UP_2,10
      0  30e0					      SHOW	PUSH_UP_3, 10
      1  30e0		       07 0a		      .byte.b	FRAME_PUSH_UP_3,10
      0  30e2					      SHOW	PUSH_UP_2, 10
      1  30e2		       08 0a		      .byte.b	FRAME_PUSH_UP_2,10
      0  30e4					      GOTO	PUSHUP2
      1  30e4		       ff		      .byte.b	JUMP
      2  30e5		       0e		      .byte.b	ANIMATION_PUSHUP2_ID
    212  30e6
    213  30e6
    214  30e6				   Animation_PUSHDOWN
    215  30e6							;    SHOW LOOKUP, 20
      0  30e6					      GOTO	PUSH0
      1  30e6		       ff		      .byte.b	JUMP
      2  30e7		       0a		      .byte.b	ANIMATION_PUSH0_ID
    217  30e8
    218  30e8
------- FILE sprites/spriteData.asm LEVEL 3 PASS 3
      0  30e8					      include	"sprites/spriteData.asm"
      1  30e8				   FRAMEDATA_crouch1
      2  30e8		       26		      .byte.b	38	; 23
      3  30e9		       12		      .byte.b	18	; 20
      4  30ea		       5a		      .byte.b	90	; 17
      5  30eb		       fc		      .byte.b	252	; 14
      6  30ec		       18		      .byte.b	24	; 11
      7  30ed		       18		      .byte.b	24	; 8
      8  30ee		       04		      .byte.b	4	; 5
      9  30ef		       00		      .byte.b	0	; 2
     10  30f0		       40		      .byte.b	64	; 22
     11  30f1		       3e		      .byte.b	62	; 19
     12  30f2		       ba		      .byte.b	186	; 16
     13  30f3		       7c		      .byte.b	124	; 13
     14  30f4		       18		      .byte.b	24	; 10
     15  30f5		       0c		      .byte.b	12	; 7
     16  30f6		       1e		      .byte.b	30	; 4
     17  30f7		       00		      .byte.b	0	; 1
     18  30f8		       34		      .byte.b	52	; 21
     19  30f9		       52		      .byte.b	82	; 18
     20  30fa		       be		      .byte.b	190	; 15
     21  30fb		       38		      .byte.b	56	; 12
     22  30fc		       1c		      .byte.b	28	; 9
     23  30fd		       0a		      .byte.b	10	; 6
     24  30fe		       1d		      .byte.b	29	; 3
     25  30ff		       00		      .byte.b	0	; 0
     26  3100
     27  3100				   COLOURDATA_crouch1
     28  3100		       06		      .byte.b	CL6	; 23
     29  3101		       05		      .byte.b	CL5	; 20
     30  3102		       03		      .byte.b	CL3	; 17
     31  3103		       04		      .byte.b	CL4	; 14
     32  3104		       03		      .byte.b	CL3	; 11
     33  3105		       02		      .byte.b	CL2	; 8
     34  3106		       02		      .byte.b	CL2	; 5
     35  3107		       00		      .byte.b	CL0	; 2
     36  3108		       06		      .byte.b	CL6	; 22
     37  3109		       05		      .byte.b	CL5	; 19
     38  310a		       04		      .byte.b	CL4	; 16
     39  310b		       04		      .byte.b	CL4	; 13
     40  310c		       02		      .byte.b	CL2	; 10
     41  310d		       02		      .byte.b	CL2	; 7
     42  310e		       01		      .byte.b	CL1	; 4
     43  310f		       00		      .byte.b	CL0	; 1
     44  3110		       05		      .byte.b	CL5	; 21
     45  3111		       02		      .byte.b	CL2	; 18
     46  3112		       04		      .byte.b	CL4	; 15
     47  3113		       04		      .byte.b	CL4	; 12
     48  3114		       02		      .byte.b	CL2	; 9
     49  3115		       02		      .byte.b	CL2	; 6
     50  3116		       01		      .byte.b	CL1	; 3
     51  3117		       00		      .byte.b	CL0	; 0
     52  3118
     53  3118				   FRAMEDATA_walk1
     54  3118		       44		      .byte.b	68	; 23
     55  3119		       4c		      .byte.b	76	; 20
     56  311a		       28		      .byte.b	40	; 17
     57  311b		       ba		      .byte.b	186	; 14
     58  311c		       7c		      .byte.b	124	; 11
     59  311d		       18		      .byte.b	24	; 8
     60  311e		       0c		      .byte.b	12	; 5
     61  311f		       1e		      .byte.b	30	; 2
     62  3120		       82		      .byte.b	130	; 22
     63  3121		       1c		      .byte.b	28	; 19
     64  3122		       b2		      .byte.b	178	; 16
     65  3123		       bc		      .byte.b	188	; 13
     66  3124		       38		      .byte.b	56	; 10
     67  3125		       1c		      .byte.b	28	; 7
     68  3126		       0a		      .byte.b	10	; 4
     69  3127		       1d		      .byte.b	29	; 1
     70  3128		       6c		      .byte.b	108	; 21
     71  3129		       38		      .byte.b	56	; 18
     72  312a		       ba		      .byte.b	186	; 15
     73  312b		       fc		      .byte.b	252	; 12
     74  312c		       18		      .byte.b	24	; 9
     75  312d		       18		      .byte.b	24	; 6
     76  312e		       04		      .byte.b	4	; 3
     77  312f		       00		      .byte.b	0	; 0
     78  3130
     79  3130				   COLOURDATA_walk1
     80  3130		       06		      .byte.b	CL6	; 23
     81  3131		       05		      .byte.b	CL5	; 20
     82  3132		       05		      .byte.b	CL5	; 17
     83  3133		       04		      .byte.b	CL4	; 14
     84  3134		       04		      .byte.b	CL4	; 11
     85  3135		       02		      .byte.b	CL2	; 8
     86  3136		       02		      .byte.b	CL2	; 5
     87  3137		       01		      .byte.b	CL1	; 2
     88  3138		       06		      .byte.b	CL6	; 22
     89  3139		       05		      .byte.b	CL5	; 19
     90  313a		       02		      .byte.b	CL2	; 16
     91  313b		       04		      .byte.b	CL4	; 13
     92  313c		       04		      .byte.b	CL4	; 10
     93  313d		       02		      .byte.b	CL2	; 7
     94  313e		       02		      .byte.b	CL2	; 4
     95  313f		       01		      .byte.b	CL1	; 1
     96  3140		       05		      .byte.b	CL5	; 21
     97  3141		       05		      .byte.b	CL5	; 18
     98  3142		       03		      .byte.b	CL3	; 15
     99  3143		       04		      .byte.b	CL4	; 12
    100  3144		       03		      .byte.b	CL3	; 9
    101  3145		       02		      .byte.b	CL2	; 6
    102  3146		       02		      .byte.b	CL2	; 3
    103  3147		       00		      .byte.b	CL0	; 0
    104  3148
    105  3148				   FRAMEDATA_walk2
    106  3148		       34		      .byte.b	52	; 23
    107  3149		       28		      .byte.b	40	; 20
    108  314a		       38		      .byte.b	56	; 17
    109  314b		       ba		      .byte.b	186	; 14
    110  314c		       fc		      .byte.b	252	; 11
    111  314d		       18		      .byte.b	24	; 8
    112  314e		       18		      .byte.b	24	; 5
    113  314f		       04		      .byte.b	4	; 2
    114  3150		       00		      .byte.b	0	; 22
    115  3151		       28		      .byte.b	40	; 19
    116  3152		       18		      .byte.b	24	; 16
    117  3153		       ba		      .byte.b	186	; 13
    118  3154		       7c		      .byte.b	124	; 10
    119  3155		       18		      .byte.b	24	; 7
    120  3156		       0c		      .byte.b	12	; 4
    121  3157		       1e		      .byte.b	30	; 1
    122  3158		       28		      .byte.b	40	; 21
    123  3159		       28		      .byte.b	40	; 18
    124  315a		       b2		      .byte.b	178	; 15
    125  315b		       bc		      .byte.b	188	; 12
    126  315c		       38		      .byte.b	56	; 9
    127  315d		       1c		      .byte.b	28	; 6
    128  315e		       0a		      .byte.b	10	; 3
    129  315f		       1d		      .byte.b	29	; 0
    130  3160
    131  3160				   COLOURDATA_walk2
    132  3160		       06		      .byte.b	CL6	; 23
    133  3161		       05		      .byte.b	CL5	; 20
    134  3162		       05		      .byte.b	CL5	; 17
    135  3163		       03		      .byte.b	CL3	; 14
    136  3164		       04		      .byte.b	CL4	; 11
    137  3165		       03		      .byte.b	CL3	; 8
    138  3166		       02		      .byte.b	CL2	; 5
    139  3167		       02		      .byte.b	CL2	; 2
    140  3168		       00		      .byte.b	CL0	; 22
    141  3169		       05		      .byte.b	CL5	; 19
    142  316a		       05		      .byte.b	CL5	; 16
    143  316b		       04		      .byte.b	CL4	; 13
    144  316c		       04		      .byte.b	CL4	; 10
    145  316d		       02		      .byte.b	CL2	; 7
    146  316e		       02		      .byte.b	CL2	; 4
    147  316f		       01		      .byte.b	CL1	; 1
    148  3170		       05		      .byte.b	CL5	; 21
    149  3171		       05		      .byte.b	CL5	; 18
    150  3172		       02		      .byte.b	CL2	; 15
    151  3173		       04		      .byte.b	CL4	; 12
    152  3174		       04		      .byte.b	CL4	; 9
    153  3175		       02		      .byte.b	CL2	; 6
    154  3176		       02		      .byte.b	CL2	; 3
    155  3177		       01		      .byte.b	CL1	; 0
    156  3178
    157  3178				   FRAMEDATA_handlip
    158  3178		       2c		      .byte.b	44	; 23
    159  3179		       28		      .byte.b	40	; 20
    160  317a		       38		      .byte.b	56	; 17
    161  317b		       58		      .byte.b	88	; 14
    162  317c		       fc		      .byte.b	252	; 11
    163  317d		       1a		      .byte.b	26	; 8
    164  317e		       18		      .byte.b	24	; 5
    165  317f		       04		      .byte.b	4	; 2
    166  3180		       00		      .byte.b	0	; 22
    167  3181		       28		      .byte.b	40	; 19
    168  3182		       38		      .byte.b	56	; 16
    169  3183		       b8		      .byte.b	184	; 13
    170  3184		       7e		      .byte.b	126	; 10
    171  3185		       1a		      .byte.b	26	; 7
    172  3186		       0c		      .byte.b	12	; 4
    173  3187		       1e		      .byte.b	30	; 1
    174  3188		       28		      .byte.b	40	; 21
    175  3189		       28		      .byte.b	40	; 18
    176  318a		       28		      .byte.b	40	; 15
    177  318b		       b8		      .byte.b	184	; 12
    178  318c		       3a		      .byte.b	58	; 9
    179  318d		       1e		      .byte.b	30	; 6
    180  318e		       0a		      .byte.b	10	; 3
    181  318f		       1d		      .byte.b	29	; 0
    182  3190
    183  3190				   COLOURDATA_handlip
    184  3190		       01		      .byte.b	CL1	; 23
    185  3191		       02		      .byte.b	CL2	; 20
    186  3192		       02		      .byte.b	CL2	; 17
    187  3193		       06		      .byte.b	CL6	; 14
    188  3194		       03		      .byte.b	CL3	; 11
    189  3195		       06		      .byte.b	CL6	; 8
    190  3196		       04		      .byte.b	CL4	; 5
    191  3197		       04		      .byte.b	CL4	; 2
    192  3198		       00		      .byte.b	CL0	; 22
    193  3199		       02		      .byte.b	CL2	; 19
    194  319a		       02		      .byte.b	CL2	; 16
    195  319b		       03		      .byte.b	CL3	; 13
    196  319c		       03		      .byte.b	CL3	; 10
    197  319d		       04		      .byte.b	CL4	; 7
    198  319e		       04		      .byte.b	CL4	; 4
    199  319f		       05		      .byte.b	CL5	; 1
    200  31a0		       02		      .byte.b	CL2	; 21
    201  31a1		       02		      .byte.b	CL2	; 18
    202  31a2		       04		      .byte.b	CL4	; 15
    203  31a3		       03		      .byte.b	CL3	; 12
    204  31a4		       03		      .byte.b	CL3	; 9
    205  31a5		       04		      .byte.b	CL4	; 6
    206  31a6		       04		      .byte.b	CL4	; 3
    207  31a7		       05		      .byte.b	CL5	; 0
    208  31a8
    209  31a8				   FRAMEDATA_lookup
    210  31a8		       34		      .byte.b	52	; 23
    211  31a9		       28		      .byte.b	40	; 20
    212  31aa		       18		      .byte.b	24	; 17
    213  31ab		       b8		      .byte.b	184	; 14
    214  31ac		       7e		      .byte.b	126	; 11
    215  31ad		       32		      .byte.b	50	; 8
    216  31ae		       70		      .byte.b	112	; 5
    217  31af		       40		      .byte.b	64	; 2
    218  31b0		       00		      .byte.b	0	; 22
    219  31b1		       28		      .byte.b	40	; 19
    220  31b2		       b0		      .byte.b	176	; 16
    221  31b3		       b8		      .byte.b	184	; 13
    222  31b4		       7a		      .byte.b	122	; 10
    223  31b5		       36		      .byte.b	54	; 7
    224  31b6		       58		      .byte.b	88	; 4
    225  31b7		       78		      .byte.b	120	; 1
    226  31b8		       28		      .byte.b	40	; 21
    227  31b9		       28		      .byte.b	40	; 18
    228  31ba		       b8		      .byte.b	184	; 15
    229  31bb		       fc		      .byte.b	252	; 12
    230  31bc		       32		      .byte.b	50	; 9
    231  31bd		       60		      .byte.b	96	; 6
    232  31be		       30		      .byte.b	48	; 3
    233  31bf		       34		      .byte.b	52	; 0
    234  31c0
    235  31c0				   COLOURDATA_lookup
    236  31c0		       06		      .byte.b	CL6	; 23
    237  31c1		       05		      .byte.b	CL5	; 20
    238  31c2		       05		      .byte.b	CL5	; 17
    239  31c3		       04		      .byte.b	CL4	; 14
    240  31c4		       04		      .byte.b	CL4	; 11
    241  31c5		       02		      .byte.b	CL2	; 8
    242  31c6		       02		      .byte.b	CL2	; 5
    243  31c7		       01		      .byte.b	CL1	; 2
    244  31c8		       00		      .byte.b	CL0	; 22
    245  31c9		       05		      .byte.b	CL5	; 19
    246  31ca		       02		      .byte.b	CL2	; 16
    247  31cb		       04		      .byte.b	CL4	; 13
    248  31cc		       04		      .byte.b	CL4	; 10
    249  31cd		       02		      .byte.b	CL2	; 7
    250  31ce		       02		      .byte.b	CL2	; 4
    251  31cf		       01		      .byte.b	CL1	; 1
    252  31d0		       05		      .byte.b	CL5	; 21
    253  31d1		       05		      .byte.b	CL5	; 18
    254  31d2		       03		      .byte.b	CL3	; 15
    255  31d3		       04		      .byte.b	CL4	; 12
    256  31d4		       03		      .byte.b	CL3	; 9
    257  31d5		       02		      .byte.b	CL2	; 6
    258  31d6		       02		      .byte.b	CL2	; 3
    259  31d7		       01		      .byte.b	CL1	; 0
    260  31d8
    261  31d8				   FRAMEDATA_walk3
    262  31d8		       44		      .byte.b	68	; 23
    263  31d9		       74		      .byte.b	116	; 20
    264  31da		       28		      .byte.b	40	; 17
    265  31db		       ba		      .byte.b	186	; 14
    266  31dc		       7c		      .byte.b	124	; 11
    267  31dd		       18		      .byte.b	24	; 8
    268  31de		       0c		      .byte.b	12	; 5
    269  31df		       1e		      .byte.b	30	; 2
    270  31e0		       82		      .byte.b	130	; 22
    271  31e1		       34		      .byte.b	52	; 19
    272  31e2		       b2		      .byte.b	178	; 16
    273  31e3		       bc		      .byte.b	188	; 13
    274  31e4		       38		      .byte.b	56	; 10
    275  31e5		       1c		      .byte.b	28	; 7
    276  31e6		       0a		      .byte.b	10	; 4
    277  31e7		       1d		      .byte.b	29	; 1
    278  31e8		       64		      .byte.b	100	; 21
    279  31e9		       38		      .byte.b	56	; 18
    280  31ea		       ba		      .byte.b	186	; 15
    281  31eb		       fc		      .byte.b	252	; 12
    282  31ec		       18		      .byte.b	24	; 9
    283  31ed		       18		      .byte.b	24	; 6
    284  31ee		       04		      .byte.b	4	; 3
    285  31ef		       00		      .byte.b	0	; 0
    286  31f0
    287  31f0				   COLOURDATA_walk3
    288  31f0		       06		      .byte.b	CL6	; 23
    289  31f1		       05		      .byte.b	CL5	; 20
    290  31f2		       05		      .byte.b	CL5	; 17
    291  31f3		       04		      .byte.b	CL4	; 14
    292  31f4		       04		      .byte.b	CL4	; 11
    293  31f5		       02		      .byte.b	CL2	; 8
    294  31f6		       02		      .byte.b	CL2	; 5
    295  31f7		       01		      .byte.b	CL1	; 2
    296  31f8		       06		      .byte.b	CL6	; 22
    297  31f9		       05		      .byte.b	CL5	; 19
    298  31fa		       02		      .byte.b	CL2	; 16
    299  31fb		       04		      .byte.b	CL4	; 13
    300  31fc		       04		      .byte.b	CL4	; 10
    301  31fd		       02		      .byte.b	CL2	; 7
    302  31fe		       02		      .byte.b	CL2	; 4
    303  31ff		       01		      .byte.b	CL1	; 1
    304  3200		       05		      .byte.b	CL5	; 21
    305  3201		       05		      .byte.b	CL5	; 18
    306  3202		       03		      .byte.b	CL3	; 15
    307  3203		       04		      .byte.b	CL4	; 12
    308  3204		       03		      .byte.b	CL3	; 9
    309  3205		       02		      .byte.b	CL2	; 6
    310  3206		       02		      .byte.b	CL2	; 3
    311  3207		       00		      .byte.b	CL0	; 0
    312  3208
    313  3208				   FRAMEDATA_push_up_1
    314  3208		       00		      .byte.b	0	; 23
    315  3209		       08		      .byte.b	8	; 20
    316  320a		       28		      .byte.b	40	; 17
    317  320b		       38		      .byte.b	56	; 14
    318  320c		       38		      .byte.b	56	; 11
    319  320d		       38		      .byte.b	56	; 8
    320  320e		       ee		      .byte.b	238	; 5
    321  320f		       38		      .byte.b	56	; 2
    322  3210		       20		      .byte.b	32	; 22
    323  3211		       20		      .byte.b	32	; 19
    324  3212		       08		      .byte.b	8	; 16
    325  3213		       10		      .byte.b	16	; 13
    326  3214		       38		      .byte.b	56	; 10
    327  3215		       38		      .byte.b	56	; 7
    328  3216		       82		      .byte.b	130	; 4
    329  3217		       38		      .byte.b	56	; 1
    330  3218		       20		      .byte.b	32	; 21
    331  3219		       28		      .byte.b	40	; 18
    332  321a		       20		      .byte.b	32	; 15
    333  321b		       38		      .byte.b	56	; 12
    334  321c		       38		      .byte.b	56	; 9
    335  321d		       7c		      .byte.b	124	; 6
    336  321e		       aa		      .byte.b	170	; 3
    337  321f		       00		      .byte.b	0	; 0
    338  3220
    339  3220				   COLOURDATA_push_up_1
    340  3220		       00		      .byte.b	CL0	; 23
    341  3221		       06		      .byte.b	CL6	; 20
    342  3222		       05		      .byte.b	CL5	; 17
    343  3223		       05		      .byte.b	CL5	; 14
    344  3224		       02		      .byte.b	CL2	; 11
    345  3225		       04		      .byte.b	CL4	; 8
    346  3226		       04		      .byte.b	CL4	; 5
    347  3227		       01		      .byte.b	CL1	; 2
    348  3228		       06		      .byte.b	CL6	; 22
    349  3229		       05		      .byte.b	CL5	; 19
    350  322a		       05		      .byte.b	CL5	; 16
    351  322b		       05		      .byte.b	CL5	; 13
    352  322c		       03		      .byte.b	CL3	; 10
    353  322d		       04		      .byte.b	CL4	; 7
    354  322e		       03		      .byte.b	CL3	; 4
    355  322f		       01		      .byte.b	CL1	; 1
    356  3230		       06		      .byte.b	CL6	; 21
    357  3231		       05		      .byte.b	CL5	; 18
    358  3232		       05		      .byte.b	CL5	; 15
    359  3233		       06		      .byte.b	CL6	; 12
    360  3234		       04		      .byte.b	CL4	; 9
    361  3235		       04		      .byte.b	CL4	; 6
    362  3236		       02		      .byte.b	CL2	; 3
    363  3237		       00		      .byte.b	CL0	; 0
    364  3238
    365  3238				   FRAMEDATA_push_up_3
    366  3238		       00		      .byte.b	0	; 23
    367  3239		       20		      .byte.b	32	; 20
    368  323a		       28		      .byte.b	40	; 17
    369  323b		       38		      .byte.b	56	; 14
    370  323c		       38		      .byte.b	56	; 11
    371  323d		       38		      .byte.b	56	; 8
    372  323e		       ee		      .byte.b	238	; 5
    373  323f		       38		      .byte.b	56	; 2
    374  3240		       08		      .byte.b	8	; 22
    375  3241		       08		      .byte.b	8	; 19
    376  3242		       20		      .byte.b	32	; 16
    377  3243		       10		      .byte.b	16	; 13
    378  3244		       38		      .byte.b	56	; 10
    379  3245		       38		      .byte.b	56	; 7
    380  3246		       82		      .byte.b	130	; 4
    381  3247		       38		      .byte.b	56	; 1
    382  3248		       08		      .byte.b	8	; 21
    383  3249		       28		      .byte.b	40	; 18
    384  324a		       08		      .byte.b	8	; 15
    385  324b		       38		      .byte.b	56	; 12
    386  324c		       38		      .byte.b	56	; 9
    387  324d		       7c		      .byte.b	124	; 6
    388  324e		       aa		      .byte.b	170	; 3
    389  324f		       00		      .byte.b	0	; 0
    390  3250
    391  3250				   COLOURDATA_push_up_3
    392  3250		       00		      .byte.b	CL0	; 23
    393  3251		       06		      .byte.b	CL6	; 20
    394  3252		       05		      .byte.b	CL5	; 17
    395  3253		       05		      .byte.b	CL5	; 14
    396  3254		       02		      .byte.b	CL2	; 11
    397  3255		       04		      .byte.b	CL4	; 8
    398  3256		       04		      .byte.b	CL4	; 5
    399  3257		       01		      .byte.b	CL1	; 2
    400  3258		       06		      .byte.b	CL6	; 22
    401  3259		       05		      .byte.b	CL5	; 19
    402  325a		       05		      .byte.b	CL5	; 16
    403  325b		       05		      .byte.b	CL5	; 13
    404  325c		       03		      .byte.b	CL3	; 10
    405  325d		       04		      .byte.b	CL4	; 7
    406  325e		       03		      .byte.b	CL3	; 4
    407  325f		       01		      .byte.b	CL1	; 1
    408  3260		       06		      .byte.b	CL6	; 21
    409  3261		       05		      .byte.b	CL5	; 18
    410  3262		       05		      .byte.b	CL5	; 15
    411  3263		       06		      .byte.b	CL6	; 12
    412  3264		       04		      .byte.b	CL4	; 9
    413  3265		       04		      .byte.b	CL4	; 6
    414  3266		       02		      .byte.b	CL2	; 3
    415  3267		       00		      .byte.b	CL0	; 0
    416  3268
    417  3268				   FRAMEDATA_push_up_2
    418  3268		       00		      .byte.b	0	; 23
    419  3269		       00		      .byte.b	0	; 20
    420  326a		       28		      .byte.b	40	; 17
    421  326b		       38		      .byte.b	56	; 14
    422  326c		       38		      .byte.b	56	; 11
    423  326d		       38		      .byte.b	56	; 8
    424  326e		       ee		      .byte.b	238	; 5
    425  326f		       38		      .byte.b	56	; 2
    426  3270		       00		      .byte.b	0	; 22
    427  3271		       28		      .byte.b	40	; 19
    428  3272		       00		      .byte.b	0	; 16
    429  3273		       10		      .byte.b	16	; 13
    430  3274		       38		      .byte.b	56	; 10
    431  3275		       38		      .byte.b	56	; 7
    432  3276		       82		      .byte.b	130	; 4
    433  3277		       38		      .byte.b	56	; 1
    434  3278		       28		      .byte.b	40	; 21
    435  3279		       28		      .byte.b	40	; 18
    436  327a		       28		      .byte.b	40	; 15
    437  327b		       38		      .byte.b	56	; 12
    438  327c		       38		      .byte.b	56	; 9
    439  327d		       7c		      .byte.b	124	; 6
    440  327e		       aa		      .byte.b	170	; 3
    441  327f		       00		      .byte.b	0	; 0
    442  3280
    443  3280				   COLOURDATA_push_up_2
    444  3280		       00		      .byte.b	CL0	; 23
    445  3281		       00		      .byte.b	CL0	; 20
    446  3282		       05		      .byte.b	CL5	; 17
    447  3283		       05		      .byte.b	CL5	; 14
    448  3284		       02		      .byte.b	CL2	; 11
    449  3285		       04		      .byte.b	CL4	; 8
    450  3286		       04		      .byte.b	CL4	; 5
    451  3287		       01		      .byte.b	CL1	; 2
    452  3288		       00		      .byte.b	CL0	; 22
    453  3289		       05		      .byte.b	CL5	; 19
    454  328a		       00		      .byte.b	CL0	; 16
    455  328b		       05		      .byte.b	CL5	; 13
    456  328c		       03		      .byte.b	CL3	; 10
    457  328d		       04		      .byte.b	CL4	; 7
    458  328e		       03		      .byte.b	CL3	; 4
    459  328f		       01		      .byte.b	CL1	; 1
    460  3290		       06		      .byte.b	CL6	; 21
    461  3291		       05		      .byte.b	CL5	; 18
    462  3292		       05		      .byte.b	CL5	; 15
    463  3293		       06		      .byte.b	CL6	; 12
    464  3294		       04		      .byte.b	CL4	; 9
    465  3295		       04		      .byte.b	CL4	; 6
    466  3296		       02		      .byte.b	CL2	; 3
    467  3297		       00		      .byte.b	CL0	; 0
    468  3298
    469  3298				   FRAMEDATA_push3
    470  3298		       46		      .byte.b	70	; 23
    471  3299		       72		      .byte.b	114	; 20
    472  329a		       18		      .byte.b	24	; 17
    473  329b		       38		      .byte.b	56	; 14
    474  329c		       3e		      .byte.b	62	; 11
    475  329d		       19		      .byte.b	25	; 8
    476  329e		       0c		      .byte.b	12	; 5
    477  329f		       1e		      .byte.b	30	; 2
    478  32a0		       80		      .byte.b	128	; 22
    479  32a1		       3e		      .byte.b	62	; 19
    480  32a2		       30		      .byte.b	48	; 16
    481  32a3		       38		      .byte.b	56	; 13
    482  32a4		       3f		      .byte.b	63	; 10
    483  32a5		       1d		      .byte.b	29	; 7
    484  32a6		       0a		      .byte.b	10	; 4
    485  32a7		       1d		      .byte.b	29	; 1
    486  32a8		       64		      .byte.b	100	; 21
    487  32a9		       3c		      .byte.b	60	; 18
    488  32aa		       38		      .byte.b	56	; 15
    489  32ab		       3c		      .byte.b	60	; 12
    490  32ac		       19		      .byte.b	25	; 9
    491  32ad		       18		      .byte.b	24	; 6
    492  32ae		       04		      .byte.b	4	; 3
    493  32af		       00		      .byte.b	0	; 0
    494  32b0
    495  32b0				   COLOURDATA_push3
    496  32b0		       06		      .byte.b	CL6	; 23
    497  32b1		       05		      .byte.b	CL5	; 20
    498  32b2		       05		      .byte.b	CL5	; 17
    499  32b3		       04		      .byte.b	CL4	; 14
    500  32b4		       04		      .byte.b	CL4	; 11
    501  32b5		       02		      .byte.b	CL2	; 8
    502  32b6		       02		      .byte.b	CL2	; 5
    503  32b7		       01		      .byte.b	CL1	; 2
    504  32b8		       06		      .byte.b	CL6	; 22
    505  32b9		       05		      .byte.b	CL5	; 19
    506  32ba		       06		      .byte.b	CL6	; 16
    507  32bb		       04		      .byte.b	CL4	; 13
    508  32bc		       04		      .byte.b	CL4	; 10
    509  32bd		       02		      .byte.b	CL2	; 7
    510  32be		       02		      .byte.b	CL2	; 4
    511  32bf		       01		      .byte.b	CL1	; 1
    512  32c0		       05		      .byte.b	CL5	; 21
    513  32c1		       05		      .byte.b	CL5	; 18
    514  32c2		       03		      .byte.b	CL3	; 15
    515  32c3		       04		      .byte.b	CL4	; 12
    516  32c4		       03		      .byte.b	CL3	; 9
    517  32c5		       02		      .byte.b	CL2	; 6
    518  32c6		       02		      .byte.b	CL2	; 3
    519  32c7		       00		      .byte.b	CL0	; 0
    520  32c8
    521  32c8				   FRAMEDATA_idle3
    522  32c8		       2c		      .byte.b	44	; 23
    523  32c9		       28		      .byte.b	40	; 20
    524  32ca		       38		      .byte.b	56	; 17
    525  32cb		       38		      .byte.b	56	; 14
    526  32cc		       38		      .byte.b	56	; 11
    527  32cd		       b2		      .byte.b	178	; 8
    528  32ce		       30		      .byte.b	48	; 5
    529  32cf		       08		      .byte.b	8	; 2
    530  32d0		       00		      .byte.b	0	; 22
    531  32d1		       28		      .byte.b	40	; 19
    532  32d2		       38		      .byte.b	56	; 16
    533  32d3		       38		      .byte.b	56	; 13
    534  32d4		       fe		      .byte.b	254	; 10
    535  32d5		       ba		      .byte.b	186	; 7
    536  32d6		       18		      .byte.b	24	; 4
    537  32d7		       3c		      .byte.b	60	; 1
    538  32d8		       28		      .byte.b	40	; 21
    539  32d9		       28		      .byte.b	40	; 18
    540  32da		       28		      .byte.b	40	; 15
    541  32db		       38		      .byte.b	56	; 12
    542  32dc		       fe		      .byte.b	254	; 9
    543  32dd		       b2		      .byte.b	178	; 6
    544  32de		       14		      .byte.b	20	; 3
    545  32df		       3a		      .byte.b	58	; 0
    546  32e0
    547  32e0				   COLOURDATA_idle3
    548  32e0		       06		      .byte.b	CL6	; 23
    549  32e1		       05		      .byte.b	CL5	; 20
    550  32e2		       05		      .byte.b	CL5	; 17
    551  32e3		       03		      .byte.b	CL3	; 14
    552  32e4		       04		      .byte.b	CL4	; 11
    553  32e5		       03		      .byte.b	CL3	; 8
    554  32e6		       02		      .byte.b	CL2	; 5
    555  32e7		       02		      .byte.b	CL2	; 2
    556  32e8		       00		      .byte.b	CL0	; 22
    557  32e9		       05		      .byte.b	CL5	; 19
    558  32ea		       05		      .byte.b	CL5	; 16
    559  32eb		       04		      .byte.b	CL4	; 13
    560  32ec		       04		      .byte.b	CL4	; 10
    561  32ed		       02		      .byte.b	CL2	; 7
    562  32ee		       02		      .byte.b	CL2	; 4
    563  32ef		       01		      .byte.b	CL1	; 1
    564  32f0		       05		      .byte.b	CL5	; 21
    565  32f1		       05		      .byte.b	CL5	; 18
    566  32f2		       02		      .byte.b	CL2	; 15
    567  32f3		       04		      .byte.b	CL4	; 12
    568  32f4		       04		      .byte.b	CL4	; 9
    569  32f5		       02		      .byte.b	CL2	; 6
    570  32f6		       02		      .byte.b	CL2	; 3
    571  32f7		       01		      .byte.b	CL1	; 0
    572  32f8
    573  32f8				   FRAMEDATA_idle2
    574  32f8		       2c		      .byte.b	44	; 23
    575  32f9		       28		      .byte.b	40	; 20
    576  32fa		       38		      .byte.b	56	; 17
    577  32fb		       38		      .byte.b	56	; 14
    578  32fc		       fe		      .byte.b	254	; 11
    579  32fd		       b2		      .byte.b	178	; 8
    580  32fe		       30		      .byte.b	48	; 5
    581  32ff		       08		      .byte.b	8	; 2
    582  3300		       00		      .byte.b	0	; 22
    583  3301		       28		      .byte.b	40	; 19
    584  3302		       38		      .byte.b	56	; 16
    585  3303		       38		      .byte.b	56	; 13
    586  3304		       fe		      .byte.b	254	; 10
    587  3305		       ba		      .byte.b	186	; 7
    588  3306		       18		      .byte.b	24	; 4
    589  3307		       3c		      .byte.b	60	; 1
    590  3308		       28		      .byte.b	40	; 21
    591  3309		       28		      .byte.b	40	; 18
    592  330a		       28		      .byte.b	40	; 15
    593  330b		       38		      .byte.b	56	; 12
    594  330c		       ba		      .byte.b	186	; 9
    595  330d		       30		      .byte.b	48	; 6
    596  330e		       14		      .byte.b	20	; 3
    597  330f		       3a		      .byte.b	58	; 0
    598  3310
    599  3310				   COLOURDATA_idle2
    600  3310		       06		      .byte.b	CL6	; 23
    601  3311		       05		      .byte.b	CL5	; 20
    602  3312		       05		      .byte.b	CL5	; 17
    603  3313		       03		      .byte.b	CL3	; 14
    604  3314		       04		      .byte.b	CL4	; 11
    605  3315		       03		      .byte.b	CL3	; 8
    606  3316		       02		      .byte.b	CL2	; 5
    607  3317		       02		      .byte.b	CL2	; 2
    608  3318		       00		      .byte.b	CL0	; 22
    609  3319		       05		      .byte.b	CL5	; 19
    610  331a		       05		      .byte.b	CL5	; 16
    611  331b		       04		      .byte.b	CL4	; 13
    612  331c		       04		      .byte.b	CL4	; 10
    613  331d		       02		      .byte.b	CL2	; 7
    614  331e		       02		      .byte.b	CL2	; 4
    615  331f		       01		      .byte.b	CL1	; 1
    616  3320		       05		      .byte.b	CL5	; 21
    617  3321		       05		      .byte.b	CL5	; 18
    618  3322		       02		      .byte.b	CL2	; 15
    619  3323		       04		      .byte.b	CL4	; 12
    620  3324		       04		      .byte.b	CL4	; 9
    621  3325		       02		      .byte.b	CL2	; 6
    622  3326		       02		      .byte.b	CL2	; 3
    623  3327		       01		      .byte.b	CL1	; 0
    624  3328
    625  3328				   FRAMEDATA_push2
    626  3328		       26		      .byte.b	38	; 23
    627  3329		       14		      .byte.b	20	; 20
    628  332a		       3c		      .byte.b	60	; 17
    629  332b		       38		      .byte.b	56	; 14
    630  332c		       3c		      .byte.b	60	; 11
    631  332d		       19		      .byte.b	25	; 8
    632  332e		       18		      .byte.b	24	; 5
    633  332f		       04		      .byte.b	4	; 2
    634  3330		       40		      .byte.b	64	; 22
    635  3331		       14		      .byte.b	20	; 19
    636  3332		       28		      .byte.b	40	; 16
    637  3333		       38		      .byte.b	56	; 13
    638  3334		       3e		      .byte.b	62	; 10
    639  3335		       19		      .byte.b	25	; 7
    640  3336		       0c		      .byte.b	12	; 4
    641  3337		       1e		      .byte.b	30	; 1
    642  3338		       34		      .byte.b	52	; 21
    643  3339		       3c		      .byte.b	60	; 18
    644  333a		       30		      .byte.b	48	; 15
    645  333b		       38		      .byte.b	56	; 12
    646  333c		       3f		      .byte.b	63	; 9
    647  333d		       1d		      .byte.b	29	; 6
    648  333e		       0a		      .byte.b	10	; 3
    649  333f		       1d		      .byte.b	29	; 0
    650  3340
    651  3340				   COLOURDATA_push2
    652  3340		       06		      .byte.b	CL6	; 23
    653  3341		       05		      .byte.b	CL5	; 20
    654  3342		       05		      .byte.b	CL5	; 17
    655  3343		       03		      .byte.b	CL3	; 14
    656  3344		       04		      .byte.b	CL4	; 11
    657  3345		       03		      .byte.b	CL3	; 8
    658  3346		       02		      .byte.b	CL2	; 5
    659  3347		       02		      .byte.b	CL2	; 2
    660  3348		       06		      .byte.b	CL6	; 22
    661  3349		       05		      .byte.b	CL5	; 19
    662  334a		       05		      .byte.b	CL5	; 16
    663  334b		       04		      .byte.b	CL4	; 13
    664  334c		       04		      .byte.b	CL4	; 10
    665  334d		       02		      .byte.b	CL2	; 7
    666  334e		       02		      .byte.b	CL2	; 4
    667  334f		       01		      .byte.b	CL1	; 1
    668  3350		       05		      .byte.b	CL5	; 21
    669  3351		       05		      .byte.b	CL5	; 18
    670  3352		       06		      .byte.b	CL6	; 15
    671  3353		       04		      .byte.b	CL4	; 12
    672  3354		       04		      .byte.b	CL4	; 9
    673  3355		       02		      .byte.b	CL2	; 6
    674  3356		       02		      .byte.b	CL2	; 3
    675  3357		       01		      .byte.b	CL1	; 0
    676  3358
    677  3358				   FRAMEDATA_idle1
    678  3358		       34		      .byte.b	52	; 23
    679  3359		       28		      .byte.b	40	; 20
    680  335a		       38		      .byte.b	56	; 17
    681  335b		       ba		      .byte.b	186	; 14
    682  335c		       fc		      .byte.b	252	; 11
    683  335d		       18		      .byte.b	24	; 8
    684  335e		       18		      .byte.b	24	; 5
    685  335f		       04		      .byte.b	4	; 2
    686  3360		       00		      .byte.b	0	; 22
    687  3361		       28		      .byte.b	40	; 19
    688  3362		       18		      .byte.b	24	; 16
    689  3363		       ba		      .byte.b	186	; 13
    690  3364		       7c		      .byte.b	124	; 10
    691  3365		       18		      .byte.b	24	; 7
    692  3366		       0c		      .byte.b	12	; 4
    693  3367		       1e		      .byte.b	30	; 1
    694  3368		       28		      .byte.b	40	; 21
    695  3369		       28		      .byte.b	40	; 18
    696  336a		       b2		      .byte.b	178	; 15
    697  336b		       bc		      .byte.b	188	; 12
    698  336c		       38		      .byte.b	56	; 9
    699  336d		       1c		      .byte.b	28	; 6
    700  336e		       0a		      .byte.b	10	; 3
    701  336f		       1d		      .byte.b	29	; 0
    702  3370
    703  3370				   COLOURDATA_idle1
    704  3370		       06		      .byte.b	CL6	; 23
    705  3371		       05		      .byte.b	CL5	; 20
    706  3372		       05		      .byte.b	CL5	; 17
    707  3373		       03		      .byte.b	CL3	; 14
    708  3374		       04		      .byte.b	CL4	; 11
    709  3375		       03		      .byte.b	CL3	; 8
    710  3376		       02		      .byte.b	CL2	; 5
    711  3377		       02		      .byte.b	CL2	; 2
    712  3378		       00		      .byte.b	CL0	; 22
    713  3379		       05		      .byte.b	CL5	; 19
    714  337a		       05		      .byte.b	CL5	; 16
    715  337b		       04		      .byte.b	CL4	; 13
    716  337c		       04		      .byte.b	CL4	; 10
    717  337d		       02		      .byte.b	CL2	; 7
    718  337e		       02		      .byte.b	CL2	; 4
    719  337f		       01		      .byte.b	CL1	; 1
    720  3380		       05		      .byte.b	CL5	; 21
    721  3381		       05		      .byte.b	CL5	; 18
    722  3382		       02		      .byte.b	CL2	; 15
    723  3383		       04		      .byte.b	CL4	; 12
    724  3384		       04		      .byte.b	CL4	; 9
    725  3385		       02		      .byte.b	CL2	; 6
    726  3386		       02		      .byte.b	CL2	; 3
    727  3387		       01		      .byte.b	CL1	; 0
    728  3388
    729  3388				   FRAMEDATA_push1
    730  3388		       46		      .byte.b	70	; 23
    731  3389		       62		      .byte.b	98	; 20
    732  338a		       28		      .byte.b	40	; 17
    733  338b		       38		      .byte.b	56	; 14
    734  338c		       3e		      .byte.b	62	; 11
    735  338d		       19		      .byte.b	25	; 8
    736  338e		       0c		      .byte.b	12	; 5
    737  338f		       1e		      .byte.b	30	; 2
    738  3390		       80		      .byte.b	128	; 22
    739  3391		       1e		      .byte.b	30	; 19
    740  3392		       30		      .byte.b	48	; 16
    741  3393		       38		      .byte.b	56	; 13
    742  3394		       3f		      .byte.b	63	; 10
    743  3395		       1d		      .byte.b	29	; 7
    744  3396		       0a		      .byte.b	10	; 4
    745  3397		       1d		      .byte.b	29	; 1
    746  3398		       64		      .byte.b	100	; 21
    747  3399		       3c		      .byte.b	60	; 18
    748  339a		       38		      .byte.b	56	; 15
    749  339b		       3c		      .byte.b	60	; 12
    750  339c		       19		      .byte.b	25	; 9
    751  339d		       18		      .byte.b	24	; 6
    752  339e		       04		      .byte.b	4	; 3
    753  339f		       00		      .byte.b	0	; 0
    754  33a0
    755  33a0				   COLOURDATA_push1
    756  33a0		       06		      .byte.b	CL6	; 23
    757  33a1		       05		      .byte.b	CL5	; 20
    758  33a2		       05		      .byte.b	CL5	; 17
    759  33a3		       04		      .byte.b	CL4	; 14
    760  33a4		       04		      .byte.b	CL4	; 11
    761  33a5		       02		      .byte.b	CL2	; 8
    762  33a6		       02		      .byte.b	CL2	; 5
    763  33a7		       01		      .byte.b	CL1	; 2
    764  33a8		       06		      .byte.b	CL6	; 22
    765  33a9		       05		      .byte.b	CL5	; 19
    766  33aa		       06		      .byte.b	CL6	; 16
    767  33ab		       04		      .byte.b	CL4	; 13
    768  33ac		       04		      .byte.b	CL4	; 10
    769  33ad		       02		      .byte.b	CL2	; 7
    770  33ae		       02		      .byte.b	CL2	; 4
    771  33af		       01		      .byte.b	CL1	; 1
    772  33b0		       05		      .byte.b	CL5	; 21
    773  33b1		       05		      .byte.b	CL5	; 18
    774  33b2		       03		      .byte.b	CL3	; 15
    775  33b3		       04		      .byte.b	CL4	; 12
    776  33b4		       03		      .byte.b	CL3	; 9
    777  33b5		       02		      .byte.b	CL2	; 6
    778  33b6		       02		      .byte.b	CL2	; 3
    779  33b7		       00		      .byte.b	CL0	; 0
    780  33b8
    781  33b8				   FRAMEDATA_blink
    782  33b8		       34		      .byte.b	52	; 23
    783  33b9		       28		      .byte.b	40	; 20
    784  33ba		       38		      .byte.b	56	; 17
    785  33bb		       ba		      .byte.b	186	; 14
    786  33bc		       fc		      .byte.b	252	; 11
    787  33bd		       18		      .byte.b	24	; 8
    788  33be		       18		      .byte.b	24	; 5
    789  33bf		       04		      .byte.b	4	; 2
    790  33c0		       00		      .byte.b	0	; 22
    791  33c1		       28		      .byte.b	40	; 19
    792  33c2		       18		      .byte.b	24	; 16
    793  33c3		       ba		      .byte.b	186	; 13
    794  33c4		       7c		      .byte.b	124	; 10
    795  33c5		       18		      .byte.b	24	; 7
    796  33c6		       0c		      .byte.b	12	; 4
    797  33c7		       1e		      .byte.b	30	; 1
    798  33c8		       28		      .byte.b	40	; 21
    799  33c9		       28		      .byte.b	40	; 18
    800  33ca		       b2		      .byte.b	178	; 15
    801  33cb		       bc		      .byte.b	188	; 12
    802  33cc		       38		      .byte.b	56	; 9
    803  33cd		       1c		      .byte.b	28	; 6
    804  33ce		       0e		      .byte.b	14	; 3
    805  33cf		       1d		      .byte.b	29	; 0
    806  33d0
    807  33d0				   COLOURDATA_blink
    808  33d0		       06		      .byte.b	CL6	; 23
    809  33d1		       05		      .byte.b	CL5	; 20
    810  33d2		       05		      .byte.b	CL5	; 17
    811  33d3		       03		      .byte.b	CL3	; 14
    812  33d4		       04		      .byte.b	CL4	; 11
    813  33d5		       03		      .byte.b	CL3	; 8
    814  33d6		       02		      .byte.b	CL2	; 5
    815  33d7		       02		      .byte.b	CL2	; 2
    816  33d8		       00		      .byte.b	CL0	; 22
    817  33d9		       05		      .byte.b	CL5	; 19
    818  33da		       05		      .byte.b	CL5	; 16
    819  33db		       04		      .byte.b	CL4	; 13
    820  33dc		       04		      .byte.b	CL4	; 10
    821  33dd		       02		      .byte.b	CL2	; 7
    822  33de		       02		      .byte.b	CL2	; 4
    823  33df		       01		      .byte.b	CL1	; 1
    824  33e0		       05		      .byte.b	CL5	; 21
    825  33e1		       05		      .byte.b	CL5	; 18
    826  33e2		       02		      .byte.b	CL2	; 15
    827  33e3		       04		      .byte.b	CL4	; 12
    828  33e4		       04		      .byte.b	CL4	; 9
    829  33e5		       02		      .byte.b	CL2	; 6
    830  33e6		       02		      .byte.b	CL2	; 3
    831  33e7		       01		      .byte.b	CL1	; 0
    832  33e8
    833  33e8				   FRAMEDATA_yell
    834  33e8		       34		      .byte.b	52	; 23
    835  33e9		       28		      .byte.b	40	; 20
    836  33ea		       18		      .byte.b	24	; 17
    837  33eb		       b8		      .byte.b	184	; 14
    838  33ec		       7e		      .byte.b	126	; 11
    839  33ed		       32		      .byte.b	50	; 8
    840  33ee		       72		      .byte.b	114	; 5
    841  33ef		       40		      .byte.b	64	; 2
    842  33f0		       00		      .byte.b	0	; 22
    843  33f1		       28		      .byte.b	40	; 19
    844  33f2		       b0		      .byte.b	176	; 16
    845  33f3		       b8		      .byte.b	184	; 13
    846  33f4		       7a		      .byte.b	122	; 10
    847  33f5		       36		      .byte.b	54	; 7
    848  33f6		       58		      .byte.b	88	; 4
    849  33f7		       78		      .byte.b	120	; 1
    850  33f8		       28		      .byte.b	40	; 21
    851  33f9		       28		      .byte.b	40	; 18
    852  33fa		       b8		      .byte.b	184	; 15
    853  33fb		       fc		      .byte.b	252	; 12
    854  33fc		       32		      .byte.b	50	; 9
    855  33fd		       62		      .byte.b	98	; 6
    856  33fe		       30		      .byte.b	48	; 3
    857  33ff		       34		      .byte.b	52	; 0
    858  3400
    859  3400				   COLOURDATA_yell
    860  3400		       06		      .byte.b	CL6	; 23
    861  3401		       05		      .byte.b	CL5	; 20
    862  3402		       05		      .byte.b	CL5	; 17
    863  3403		       04		      .byte.b	CL4	; 14
    864  3404		       04		      .byte.b	CL4	; 11
    865  3405		       02		      .byte.b	CL2	; 8
    866  3406		       02		      .byte.b	CL2	; 5
    867  3407		       01		      .byte.b	CL1	; 2
    868  3408		       00		      .byte.b	CL0	; 22
    869  3409		       05		      .byte.b	CL5	; 19
    870  340a		       02		      .byte.b	CL2	; 16
    871  340b		       04		      .byte.b	CL4	; 13
    872  340c		       04		      .byte.b	CL4	; 10
    873  340d		       02		      .byte.b	CL2	; 7
    874  340e		       02		      .byte.b	CL2	; 4
    875  340f		       01		      .byte.b	CL1	; 1
    876  3410		       05		      .byte.b	CL5	; 21
    877  3411		       05		      .byte.b	CL5	; 18
    878  3412		       03		      .byte.b	CL3	; 15
    879  3413		       04		      .byte.b	CL4	; 12
    880  3414		       03		      .byte.b	CL3	; 9
    881  3415		       02		      .byte.b	CL2	; 6
    882  3416		       02		      .byte.b	CL2	; 3
    883  3417		       01		      .byte.b	CL1	; 0
    884  3418
    885  3418				   FRAMEDATA_look2
    886  3418		       34		      .byte.b	52	; 23
    887  3419		       28		      .byte.b	40	; 20
    888  341a		       38		      .byte.b	56	; 17
    889  341b		       ba		      .byte.b	186	; 14
    890  341c		       7c		      .byte.b	124	; 11
    891  341d		       30		      .byte.b	48	; 8
    892  341e		       10		      .byte.b	16	; 5
    893  341f		       70		      .byte.b	112	; 2
    894  3420		       00		      .byte.b	0	; 22
    895  3421		       28		      .byte.b	40	; 19
    896  3422		       18		      .byte.b	24	; 16
    897  3423		       be		      .byte.b	190	; 13
    898  3424		       78		      .byte.b	120	; 10
    899  3425		       30		      .byte.b	48	; 7
    900  3426		       78		      .byte.b	120	; 4
    901  3427		       78		      .byte.b	120	; 1
    902  3428		       28		      .byte.b	40	; 21
    903  3429		       28		      .byte.b	40	; 18
    904  342a		       b2		      .byte.b	178	; 15
    905  342b		       fc		      .byte.b	252	; 12
    906  342c		       38		      .byte.b	56	; 9
    907  342d		       30		      .byte.b	48	; 6
    908  342e		       28		      .byte.b	40	; 3
    909  342f		       b8		      .byte.b	184	; 0
    910  3430
    911  3430				   COLOURDATA_look2
    912  3430		       06		      .byte.b	CL6	; 23
    913  3431		       05		      .byte.b	CL5	; 20
    914  3432		       05		      .byte.b	CL5	; 17
    915  3433		       03		      .byte.b	CL3	; 14
    916  3434		       04		      .byte.b	CL4	; 11
    917  3435		       03		      .byte.b	CL3	; 8
    918  3436		       02		      .byte.b	CL2	; 5
    919  3437		       02		      .byte.b	CL2	; 2
    920  3438		       00		      .byte.b	CL0	; 22
    921  3439		       05		      .byte.b	CL5	; 19
    922  343a		       05		      .byte.b	CL5	; 16
    923  343b		       04		      .byte.b	CL4	; 13
    924  343c		       04		      .byte.b	CL4	; 10
    925  343d		       02		      .byte.b	CL2	; 7
    926  343e		       02		      .byte.b	CL2	; 4
    927  343f		       01		      .byte.b	CL1	; 1
    928  3440		       05		      .byte.b	CL5	; 21
    929  3441		       05		      .byte.b	CL5	; 18
    930  3442		       02		      .byte.b	CL2	; 15
    931  3443		       04		      .byte.b	CL4	; 12
    932  3444		       04		      .byte.b	CL4	; 9
    933  3445		       02		      .byte.b	CL2	; 6
    934  3446		       02		      .byte.b	CL2	; 3
    935  3447		       01		      .byte.b	CL1	; 0
    936  3448
    937  3448				   FRAMEDATA_look3
    938  3448		       34		      .byte.b	52	; 23
    939  3449		       28		      .byte.b	40	; 20
    940  344a		       38		      .byte.b	56	; 17
    941  344b		       ba		      .byte.b	186	; 14
    942  344c		       fc		      .byte.b	252	; 11
    943  344d		       18		      .byte.b	24	; 8
    944  344e		       10		      .byte.b	16	; 5
    945  344f		       1c		      .byte.b	28	; 2
    946  3450		       00		      .byte.b	0	; 22
    947  3451		       28		      .byte.b	40	; 19
    948  3452		       18		      .byte.b	24	; 16
    949  3453		       ba		      .byte.b	186	; 13
    950  3454		       7c		      .byte.b	124	; 10
    951  3455		       18		      .byte.b	24	; 7
    952  3456		       3c		      .byte.b	60	; 4
    953  3457		       3c		      .byte.b	60	; 1
    954  3458		       28		      .byte.b	40	; 21
    955  3459		       28		      .byte.b	40	; 18
    956  345a		       b2		      .byte.b	178	; 15
    957  345b		       bc		      .byte.b	188	; 12
    958  345c		       38		      .byte.b	56	; 9
    959  345d		       18		      .byte.b	24	; 6
    960  345e		       28		      .byte.b	40	; 3
    961  345f		       3a		      .byte.b	58	; 0
    962  3460
    963  3460				   COLOURDATA_look3
    964  3460		       06		      .byte.b	CL6	; 23
    965  3461		       05		      .byte.b	CL5	; 20
    966  3462		       05		      .byte.b	CL5	; 17
    967  3463		       03		      .byte.b	CL3	; 14
    968  3464		       04		      .byte.b	CL4	; 11
    969  3465		       03		      .byte.b	CL3	; 8
    970  3466		       02		      .byte.b	CL2	; 5
    971  3467		       02		      .byte.b	CL2	; 2
    972  3468		       00		      .byte.b	CL0	; 22
    973  3469		       05		      .byte.b	CL5	; 19
    974  346a		       05		      .byte.b	CL5	; 16
    975  346b		       04		      .byte.b	CL4	; 13
    976  346c		       04		      .byte.b	CL4	; 10
    977  346d		       02		      .byte.b	CL2	; 7
    978  346e		       02		      .byte.b	CL2	; 4
    979  346f		       01		      .byte.b	CL1	; 1
    980  3470		       05		      .byte.b	CL5	; 21
    981  3471		       05		      .byte.b	CL5	; 18
    982  3472		       02		      .byte.b	CL2	; 15
    983  3473		       04		      .byte.b	CL4	; 12
    984  3474		       04		      .byte.b	CL4	; 9
    985  3475		       02		      .byte.b	CL2	; 6
    986  3476		       02		      .byte.b	CL2	; 3
    987  3477		       01		      .byte.b	CL1	; 0
    988  3478
    989  3478				   FRAMEDATA_look1
    990  3478		       28		      .byte.b	40	; 23
    991  3479		       28		      .byte.b	40	; 20
    992  347a		       38		      .byte.b	56	; 17
    993  347b		       59		      .byte.b	89	; 14
    994  347c		       7c		      .byte.b	124	; 11
    995  347d		       18		      .byte.b	24	; 8
    996  347e		       18		      .byte.b	24	; 5
    997  347f		       20		      .byte.b	32	; 2
    998  3480		       00		      .byte.b	0	; 22
    999  3481		       28		      .byte.b	40	; 19
   1000  3482		       38		      .byte.b	56	; 16
   1001  3483		       5a		      .byte.b	90	; 13
   1002  3484		       3c		      .byte.b	60	; 10
   1003  3485		       18		      .byte.b	24	; 7
   1004  3486		       30		      .byte.b	48	; 4
   1005  3487		       78		      .byte.b	120	; 1
   1006  3488		       28		      .byte.b	40	; 21
   1007  3489		       28		      .byte.b	40	; 18
   1008  348a		       49		      .byte.b	73	; 15
   1009  348b		       7e		      .byte.b	126	; 12
   1010  348c		       18		      .byte.b	24	; 9
   1011  348d		       38		      .byte.b	56	; 6
   1012  348e		       50		      .byte.b	80	; 3
   1013  348f		       b8		      .byte.b	184	; 0
   1014  3490
   1015  3490				   COLOURDATA_look1
   1016  3490		       06		      .byte.b	CL6	; 23
   1017  3491		       05		      .byte.b	CL5	; 20
   1018  3492		       05		      .byte.b	CL5	; 17
   1019  3493		       03		      .byte.b	CL3	; 14
   1020  3494		       04		      .byte.b	CL4	; 11
   1021  3495		       03		      .byte.b	CL3	; 8
   1022  3496		       02		      .byte.b	CL2	; 5
   1023  3497		       02		      .byte.b	CL2	; 2
   1024  3498		       00		      .byte.b	CL0	; 22
   1025  3499		       05		      .byte.b	CL5	; 19
   1026  349a		       05		      .byte.b	CL5	; 16
   1027  349b		       04		      .byte.b	CL4	; 13
   1028  349c		       04		      .byte.b	CL4	; 10
   1029  349d		       02		      .byte.b	CL2	; 7
   1030  349e		       02		      .byte.b	CL2	; 4
   1031  349f		       01		      .byte.b	CL1	; 1
   1032  34a0		       05		      .byte.b	CL5	; 21
   1033  34a1		       05		      .byte.b	CL5	; 18
   1034  34a2		       02		      .byte.b	CL2	; 15
   1035  34a3		       04		      .byte.b	CL4	; 12
   1036  34a4		       04		      .byte.b	CL4	; 9
   1037  34a5		       02		      .byte.b	CL2	; 6
   1038  34a6		       02		      .byte.b	CL2	; 3
   1039  34a7		       01		      .byte.b	CL1	; 0
   1040  34a8
   1041  34a8				   FRAMEDATA_handlip2
   1042  34a8		       28		      .byte.b	40	; 23
   1043  34a9		       28		      .byte.b	40	; 20
   1044  34aa		       38		      .byte.b	56	; 17
   1045  34ab		       58		      .byte.b	88	; 14
   1046  34ac		       fc		      .byte.b	252	; 11
   1047  34ad		       1a		      .byte.b	26	; 8
   1048  34ae		       18		      .byte.b	24	; 5
   1049  34af		       04		      .byte.b	4	; 2
   1050  34b0		       04		      .byte.b	4	; 22
   1051  34b1		       28		      .byte.b	40	; 19
   1052  34b2		       38		      .byte.b	56	; 16
   1053  34b3		       b8		      .byte.b	184	; 13
   1054  34b4		       7e		      .byte.b	126	; 10
   1055  34b5		       1a		      .byte.b	26	; 7
   1056  34b6		       0c		      .byte.b	12	; 4
   1057  34b7		       1e		      .byte.b	30	; 1
   1058  34b8		       28		      .byte.b	40	; 21
   1059  34b9		       28		      .byte.b	40	; 18
   1060  34ba		       28		      .byte.b	40	; 15
   1061  34bb		       b8		      .byte.b	184	; 12
   1062  34bc		       3a		      .byte.b	58	; 9
   1063  34bd		       1e		      .byte.b	30	; 6
   1064  34be		       0a		      .byte.b	10	; 3
   1065  34bf		       1d		      .byte.b	29	; 0
   1066  34c0
   1067  34c0				   COLOURDATA_handlip2
   1068  34c0		       06		      .byte.b	CL6	; 23
   1069  34c1		       05		      .byte.b	CL5	; 20
   1070  34c2		       05		      .byte.b	CL5	; 17
   1071  34c3		       03		      .byte.b	CL3	; 14
   1072  34c4		       04		      .byte.b	CL4	; 11
   1073  34c5		       03		      .byte.b	CL3	; 8
   1074  34c6		       02		      .byte.b	CL2	; 5
   1075  34c7		       02		      .byte.b	CL2	; 2
   1076  34c8		       06		      .byte.b	CL6	; 22
   1077  34c9		       05		      .byte.b	CL5	; 19
   1078  34ca		       05		      .byte.b	CL5	; 16
   1079  34cb		       04		      .byte.b	CL4	; 13
   1080  34cc		       04		      .byte.b	CL4	; 10
   1081  34cd		       02		      .byte.b	CL2	; 7
   1082  34ce		       02		      .byte.b	CL2	; 4
   1083  34cf		       01		      .byte.b	CL1	; 1
   1084  34d0		       05		      .byte.b	CL5	; 21
   1085  34d1		       05		      .byte.b	CL5	; 18
   1086  34d2		       02		      .byte.b	CL2	; 15
   1087  34d3		       04		      .byte.b	CL4	; 12
   1088  34d4		       04		      .byte.b	CL4	; 9
   1089  34d5		       02		      .byte.b	CL2	; 6
   1090  34d6		       02		      .byte.b	CL2	; 3
   1091  34d7		       01		      .byte.b	CL1	; 0
   1092  34d8
   1093  34d8				   FRAMEDATA_tapfoot
   1094  34d8		       24		      .byte.b	36	; 23
   1095  34d9		       28		      .byte.b	40	; 20
   1096  34da		       38		      .byte.b	56	; 17
   1097  34db		       ba		      .byte.b	186	; 14
   1098  34dc		       fc		      .byte.b	252	; 11
   1099  34dd		       18		      .byte.b	24	; 8
   1100  34de		       18		      .byte.b	24	; 5
   1101  34df		       04		      .byte.b	4	; 2
   1102  34e0		       10		      .byte.b	16	; 22
   1103  34e1		       28		      .byte.b	40	; 19
   1104  34e2		       18		      .byte.b	24	; 16
   1105  34e3		       ba		      .byte.b	186	; 13
   1106  34e4		       7c		      .byte.b	124	; 10
   1107  34e5		       18		      .byte.b	24	; 7
   1108  34e6		       0c		      .byte.b	12	; 4
   1109  34e7		       1e		      .byte.b	30	; 1
   1110  34e8		       28		      .byte.b	40	; 21
   1111  34e9		       28		      .byte.b	40	; 18
   1112  34ea		       b2		      .byte.b	178	; 15
   1113  34eb		       bc		      .byte.b	188	; 12
   1114  34ec		       38		      .byte.b	56	; 9
   1115  34ed		       1c		      .byte.b	28	; 6
   1116  34ee		       0a		      .byte.b	10	; 3
   1117  34ef		       1d		      .byte.b	29	; 0
   1118  34f0
   1119  34f0				   COLOURDATA_tapfoot
   1120  34f0		       06		      .byte.b	CL6	; 23
   1121  34f1		       05		      .byte.b	CL5	; 20
   1122  34f2		       05		      .byte.b	CL5	; 17
   1123  34f3		       03		      .byte.b	CL3	; 14
   1124  34f4		       04		      .byte.b	CL4	; 11
   1125  34f5		       03		      .byte.b	CL3	; 8
   1126  34f6		       02		      .byte.b	CL2	; 5
   1127  34f7		       02		      .byte.b	CL2	; 2
   1128  34f8		       06		      .byte.b	CL6	; 22
   1129  34f9		       05		      .byte.b	CL5	; 19
   1130  34fa		       05		      .byte.b	CL5	; 16
   1131  34fb		       04		      .byte.b	CL4	; 13
   1132  34fc		       04		      .byte.b	CL4	; 10
   1133  34fd		       02		      .byte.b	CL2	; 7
   1134  34fe		       02		      .byte.b	CL2	; 4
   1135  34ff		       01		      .byte.b	CL1	; 1
   1136  3500		       05		      .byte.b	CL5	; 21
   1137  3501		       05		      .byte.b	CL5	; 18
   1138  3502		       02		      .byte.b	CL2	; 15
   1139  3503		       04		      .byte.b	CL4	; 12
   1140  3504		       04		      .byte.b	CL4	; 9
   1141  3505		       02		      .byte.b	CL2	; 6
   1142  3506		       02		      .byte.b	CL2	; 3
   1143  3507		       01		      .byte.b	CL1	; 0
   1144  3508
   1145  3508				   FRAMEDATA_handlip1
   1146  3508		       2c		      .byte.b	44	; 23
   1147  3509		       28		      .byte.b	40	; 20
   1148  350a		       38		      .byte.b	56	; 17
   1149  350b		       58		      .byte.b	88	; 14
   1150  350c		       fc		      .byte.b	252	; 11
   1151  350d		       1a		      .byte.b	26	; 8
   1152  350e		       18		      .byte.b	24	; 5
   1153  350f		       04		      .byte.b	4	; 2
   1154  3510		       00		      .byte.b	0	; 22
   1155  3511		       28		      .byte.b	40	; 19
   1156  3512		       38		      .byte.b	56	; 16
   1157  3513		       b8		      .byte.b	184	; 13
   1158  3514		       7e		      .byte.b	126	; 10
   1159  3515		       1a		      .byte.b	26	; 7
   1160  3516		       0c		      .byte.b	12	; 4
   1161  3517		       1e		      .byte.b	30	; 1
   1162  3518		       28		      .byte.b	40	; 21
   1163  3519		       28		      .byte.b	40	; 18
   1164  351a		       28		      .byte.b	40	; 15
   1165  351b		       b8		      .byte.b	184	; 12
   1166  351c		       3a		      .byte.b	58	; 9
   1167  351d		       1e		      .byte.b	30	; 6
   1168  351e		       0a		      .byte.b	10	; 3
   1169  351f		       1d		      .byte.b	29	; 0
   1170  3520
   1171  3520				   COLOURDATA_handlip1
   1172  3520		       06		      .byte.b	CL6	; 23
   1173  3521		       05		      .byte.b	CL5	; 20
   1174  3522		       05		      .byte.b	CL5	; 17
   1175  3523		       03		      .byte.b	CL3	; 14
   1176  3524		       04		      .byte.b	CL4	; 11
   1177  3525		       03		      .byte.b	CL3	; 8
   1178  3526		       02		      .byte.b	CL2	; 5
   1179  3527		       02		      .byte.b	CL2	; 2
   1180  3528		       00		      .byte.b	CL0	; 22
   1181  3529		       05		      .byte.b	CL5	; 19
   1182  352a		       05		      .byte.b	CL5	; 16
   1183  352b		       04		      .byte.b	CL4	; 13
   1184  352c		       04		      .byte.b	CL4	; 10
   1185  352d		       02		      .byte.b	CL2	; 7
   1186  352e		       02		      .byte.b	CL2	; 4
   1187  352f		       01		      .byte.b	CL1	; 1
   1188  3530		       05		      .byte.b	CL5	; 21
   1189  3531		       05		      .byte.b	CL5	; 18
   1190  3532		       02		      .byte.b	CL2	; 15
   1191  3533		       04		      .byte.b	CL4	; 12
   1192  3534		       04		      .byte.b	CL4	; 9
   1193  3535		       02		      .byte.b	CL2	; 6
   1194  3536		       02		      .byte.b	CL2	; 3
   1195  3537		       01		      .byte.b	CL1	; 0
   1196  3538
   1197  3538
   1198  3538				   __FNUM     SET	0
   1199  3538					      MAC	deframe
   1200  3538				   FRAME_{1}  =	__FNUM
   1201  3538				   __FNUM     SET	__FNUM + 1
   1202  3538					      ENDM		;{name}
   1203  3538
      0  3538					      DEFRAME	CROUCH1
      1  3538		       00 00	   FRAME_CROUCH1 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	WALK1
      1  3538		       00 01	   FRAME_WALK1 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	WALK2
      1  3538		       00 02	   FRAME_WALK2 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	HANDLIP
      1  3538		       00 03	   FRAME_HANDLIP =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	LOOKUP
      1  3538		       00 04	   FRAME_LOOKUP =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	WALK3
      1  3538		       00 05	   FRAME_WALK3 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	PUSH_UP_1
      1  3538		       00 06	   FRAME_PUSH_UP_1 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	PUSH_UP_3
      1  3538		       00 07	   FRAME_PUSH_UP_3 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	PUSH_UP_2
      1  3538		       00 08	   FRAME_PUSH_UP_2 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	PUSH3
      1  3538		       00 09	   FRAME_PUSH3 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	IDLE3
      1  3538		       00 0a	   FRAME_IDLE3 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	IDLE2
      1  3538		       00 0b	   FRAME_IDLE2 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	PUSH2
      1  3538		       00 0c	   FRAME_PUSH2 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	IDLE1
      1  3538		       00 0d	   FRAME_IDLE1 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	PUSH1
      1  3538		       00 0e	   FRAME_PUSH1 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	BLINK
      1  3538		       00 0f	   FRAME_BLINK =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	YELL
      1  3538		       00 10	   FRAME_YELL =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	LOOK2
      1  3538		       00 11	   FRAME_LOOK2 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	LOOK3
      1  3538		       00 12	   FRAME_LOOK3 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	LOOK1
      1  3538		       00 13	   FRAME_LOOK1 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	HANDLIP2
      1  3538		       00 14	   FRAME_HANDLIP2 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	TAPFOOT
      1  3538		       00 15	   FRAME_TAPFOOT =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
      0  3538					      DEFRAME	HANDLIP1
      1  3538		       00 16	   FRAME_HANDLIP1 =	__FNUM
      2  3538				   __FNUM     SET	__FNUM + 1
   1227  3538
   1228  3538				   FRAME_PTR_LO
   1229  3538		       e8		      .byte.b	<FRAMEDATA_crouch1
   1230  3539		       18		      .byte.b	<FRAMEDATA_walk1
   1231  353a		       48		      .byte.b	<FRAMEDATA_walk2
   1232  353b		       78		      .byte.b	<FRAMEDATA_handlip
   1233  353c		       a8		      .byte.b	<FRAMEDATA_lookup
   1234  353d		       d8		      .byte.b	<FRAMEDATA_walk3
   1235  353e		       08		      .byte.b	<FRAMEDATA_push_up_1
   1236  353f		       38		      .byte.b	<FRAMEDATA_push_up_3
   1237  3540		       68		      .byte.b	<FRAMEDATA_push_up_2
   1238  3541		       98		      .byte.b	<FRAMEDATA_push3
   1239  3542		       c8		      .byte.b	<FRAMEDATA_idle3
   1240  3543		       f8		      .byte.b	<FRAMEDATA_idle2
   1241  3544		       28		      .byte.b	<FRAMEDATA_push2
   1242  3545		       58		      .byte.b	<FRAMEDATA_idle1
   1243  3546		       88		      .byte.b	<FRAMEDATA_push1
   1244  3547		       b8		      .byte.b	<FRAMEDATA_blink
   1245  3548		       e8		      .byte.b	<FRAMEDATA_yell
   1246  3549		       18		      .byte.b	<FRAMEDATA_look2
   1247  354a		       48		      .byte.b	<FRAMEDATA_look3
   1248  354b		       78		      .byte.b	<FRAMEDATA_look1
   1249  354c		       a8		      .byte.b	<FRAMEDATA_handlip2
   1250  354d		       d8		      .byte.b	<FRAMEDATA_tapfoot
   1251  354e		       08		      .byte.b	<FRAMEDATA_handlip1
   1252  354f
   1253  354f				   FRAME_PTR_HI
   1254  354f		       f0		      .byte.b	>FRAMEDATA_crouch1
   1255  3550		       f1		      .byte.b	>FRAMEDATA_walk1
   1256  3551		       f1		      .byte.b	>FRAMEDATA_walk2
   1257  3552		       f1		      .byte.b	>FRAMEDATA_handlip
   1258  3553		       f1		      .byte.b	>FRAMEDATA_lookup
   1259  3554		       f1		      .byte.b	>FRAMEDATA_walk3
   1260  3555		       f2		      .byte.b	>FRAMEDATA_push_up_1
   1261  3556		       f2		      .byte.b	>FRAMEDATA_push_up_3
   1262  3557		       f2		      .byte.b	>FRAMEDATA_push_up_2
   1263  3558		       f2		      .byte.b	>FRAMEDATA_push3
   1264  3559		       f2		      .byte.b	>FRAMEDATA_idle3
   1265  355a		       f2		      .byte.b	>FRAMEDATA_idle2
   1266  355b		       f3		      .byte.b	>FRAMEDATA_push2
   1267  355c		       f3		      .byte.b	>FRAMEDATA_idle1
   1268  355d		       f3		      .byte.b	>FRAMEDATA_push1
   1269  355e		       f3		      .byte.b	>FRAMEDATA_blink
   1270  355f		       f3		      .byte.b	>FRAMEDATA_yell
   1271  3560		       f4		      .byte.b	>FRAMEDATA_look2
   1272  3561		       f4		      .byte.b	>FRAMEDATA_look3
   1273  3562		       f4		      .byte.b	>FRAMEDATA_look1
   1274  3563		       f4		      .byte.b	>FRAMEDATA_handlip2
   1275  3564		       f4		      .byte.b	>FRAMEDATA_tapfoot
   1276  3565		       f5		      .byte.b	>FRAMEDATA_handlip1
   1277  3566
   1278  3566				   COLOUR_PTR_LO
   1279  3566		       00		      .byte.b	<COLOURDATA_crouch1
   1280  3567		       30		      .byte.b	<COLOURDATA_walk1
   1281  3568		       60		      .byte.b	<COLOURDATA_walk2
   1282  3569		       90		      .byte.b	<COLOURDATA_handlip
   1283  356a		       c0		      .byte.b	<COLOURDATA_lookup
   1284  356b		       f0		      .byte.b	<COLOURDATA_walk3
   1285  356c		       20		      .byte.b	<COLOURDATA_push_up_1
   1286  356d		       50		      .byte.b	<COLOURDATA_push_up_3
   1287  356e		       80		      .byte.b	<COLOURDATA_push_up_2
   1288  356f		       b0		      .byte.b	<COLOURDATA_push3
   1289  3570		       e0		      .byte.b	<COLOURDATA_idle3
   1290  3571		       10		      .byte.b	<COLOURDATA_idle2
   1291  3572		       40		      .byte.b	<COLOURDATA_push2
   1292  3573		       70		      .byte.b	<COLOURDATA_idle1
   1293  3574		       a0		      .byte.b	<COLOURDATA_push1
   1294  3575		       d0		      .byte.b	<COLOURDATA_blink
   1295  3576		       00		      .byte.b	<COLOURDATA_yell
   1296  3577		       30		      .byte.b	<COLOURDATA_look2
   1297  3578		       60		      .byte.b	<COLOURDATA_look3
   1298  3579		       90		      .byte.b	<COLOURDATA_look1
   1299  357a		       c0		      .byte.b	<COLOURDATA_handlip2
   1300  357b		       f0		      .byte.b	<COLOURDATA_tapfoot
   1301  357c		       20		      .byte.b	<COLOURDATA_handlip1
   1302  357d
   1303  357d				   COLOUR_PTR_HI
   1304  357d		       f1		      .byte.b	>COLOURDATA_crouch1
   1305  357e		       f1		      .byte.b	>COLOURDATA_walk1
   1306  357f		       f1		      .byte.b	>COLOURDATA_walk2
   1307  3580		       f1		      .byte.b	>COLOURDATA_handlip
   1308  3581		       f1		      .byte.b	>COLOURDATA_lookup
   1309  3582		       f1		      .byte.b	>COLOURDATA_walk3
   1310  3583		       f2		      .byte.b	>COLOURDATA_push_up_1
   1311  3584		       f2		      .byte.b	>COLOURDATA_push_up_3
   1312  3585		       f2		      .byte.b	>COLOURDATA_push_up_2
   1313  3586		       f2		      .byte.b	>COLOURDATA_push3
   1314  3587		       f2		      .byte.b	>COLOURDATA_idle3
   1315  3588		       f3		      .byte.b	>COLOURDATA_idle2
   1316  3589		       f3		      .byte.b	>COLOURDATA_push2
   1317  358a		       f3		      .byte.b	>COLOURDATA_idle1
   1318  358b		       f3		      .byte.b	>COLOURDATA_push1
   1319  358c		       f3		      .byte.b	>COLOURDATA_blink
   1320  358d		       f4		      .byte.b	>COLOURDATA_yell
   1321  358e		       f4		      .byte.b	>COLOURDATA_look2
   1322  358f		       f4		      .byte.b	>COLOURDATA_look3
   1323  3590		       f4		      .byte.b	>COLOURDATA_look1
   1324  3591		       f4		      .byte.b	>COLOURDATA_handlip2
   1325  3592		       f4		      .byte.b	>COLOURDATA_tapfoot
   1326  3593		       f5		      .byte.b	>COLOURDATA_handlip1
------- FILE BANK_PlayerFrames.asm
    220  3594
    221  3594
      0  3594					      CHECK_BANK_SIZE	"PLAYER_FRAMES"
      1  3594		       05 94	   .TEMP      =	* - BANK_START
 PLAYER_FRAMES (2K) SIZE =  $594 , FREE= $26c
      2  3594					      ECHO	"PLAYER_FRAMES", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3594				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  3594				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3594				  -	      ERR
      6  3594					      endif
------- FILE ./sokoboo.asm
------- FILE titleScreen.asm LEVEL 2 PASS 3
      0  3594					      include	"titleScreen.asm"
      0  3594					      NEWBANK	TITLESCREEN
      1  3fd8 ????				      SEG	TITLESCREEN
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   TITLESCREEN SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	TITLESCREEN
      2  3800
      3  3800				   OverscanTime2
      4  3800		       17 17		      .byte.b	23, 23
      5  3802		       21 21		      .byte.b	33, 33
      6  3804
      7  3804				   colvec
      8  3804		       c8 f0 a0 f1	      .word.w	colr_ntsc, colr_pal
      9  3808
      0  3808					      DEFINE_SUBROUTINE	TitleScreen
      1  3808		       00 07	   BANK_TitleScreen =	_CURRENT_BANK
      2  3808					      SUBROUTINE
      3  3808				   TitleScreen
     11  3808
     12  3808							; Start of new frame
     13  3808
     14  3808							; Start of vertical blank processing
     15  3808
     16  3808				   TitleSequence
     17  3808
     18  3808		       a9 00		      lda	#%00000000
     19  380a		       85 4a		      sta	CTRLPF
     20  380c		       85 49		      sta	COLUBK
     21  380e
     22  380e		       a6 80		      ldx	Platform
     23  3810		       bd 04 f0 	      lda	colvec,x
     24  3813		       85 db		      sta	title_colour_table
     25  3815		       bd 05 f0 	      lda	colvec+1,x
     26  3818		       85 dc		      sta	title_colour_table+1
     27  381a
     28  381a							;		  sta rndHi
     29  381a							;		  sta rnd
     30  381a
     31  381a
     32  381a		       a9 00		      lda	#0
     33  381c		       85 e3		      sta	digit
     34  381e		       a9 10		      lda	#$10
     35  3820		       85 e4		      sta	digit+1
     36  3822		       a9 20		      lda	#$20
     37  3824		       85 e5		      sta	digit+2
     38  3826
     39  3826
     40  3826
     41  3826
      0  3826					      RESYNC
      1  3826
      2  3826		       a9 02		      lda	#%10
      3  3828		       85 41		      sta	VBLANK
      4  382a
      5  382a		       a2 08		      ldx	#8
      6  382c				   .loopResync
      0  382c					      VERTICAL_SYNC
      1  382c		       a9 0e		      lda	#%1110
      2  382e		       85 42	   .VSLP1     sta	WSYNC
      3  3830		       85 40		      sta	VSYNC
      4  3832		       4a		      lsr
      5  3833		       d0 f9		      bne	.VSLP1
      8  3835
      9  3835		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  3837		       a5 80		      lda	Platform
     11  3839		       49 02		      eor	#PAL_50
     12  383b		       d0 02		      bne	.ntsc
     13  383d		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  383f				   .ntsc
     15  383f				   .loopWait
     16  383f		       85 42		      sta	WSYNC
     17  3841		       85 42		      sta	WSYNC
     18  3843		       88		      dey
     19  3844		       d0 f9		      bne	.loopWait
     20  3846		       ca		      dex
     21  3847		       d0 e3		      bne	.loopResync
     43  3849
     44  3849				   RestartFrame0
     45  3849
     46  3849				  -	      if	0
     47  3849				  -	      ldx	#2
     48  3849				  -rollcols   clc
     49  3849				  -	      lda	digit+2
     50  3849				  -	      adc	#$10
     51  3849				  -	      sta	digit+2
     52  3849				  -	      bcc	finxc
     53  3849				  -	      dex
     54  3849				  -	      bpl	rollcols
     55  3849				  -finxc
     56  3849					      endif
     57  3849
      0  3849					      DEFINE_SUBROUTINE	RestartFrame
      1  3849		       00 07	   BANK_RestartFrame =	_CURRENT_BANK
      2  3849					      SUBROUTINE
      3  3849				   RestartFrame
     59  3849		       a9 00		      LDA	#0
     60  384b		       a9 0e		      lda	#%1110	; VSYNC ON
     61  384d		       85 42	   .loopVSync2 sta	WSYNC
     62  384f		       85 40		      sta	VSYNC
     63  3851		       4a		      lsr
     64  3852		       d0 f9		      bne	.loopVSync2	; branch until VYSNC has been reset
     65  3854
     66  3854							;------------------------------------------------------------------
     67  3854
     68  3854
     69  3854
     70  3854		       a6 80		      ldx	Platform
     71  3856		       bc f6 fc 	      ldy	VBlankTime,x
     72  3859		       8c 96 02 	      sty	TIM64T
     73  385c
     74  385c
     75  385c				  -	      if	0
     76  385c				  -	      lda	SWCHB
     77  385c				  -	      rol
     78  385c				  -	      rol
     79  385c				  -	      rol
     80  385c				  -	      and	#%11
     81  385c				  -	      eor	#PAL
     82  385c				  -	      cmp	Platform
     83  385c				  -	      beq	platOK
     84  385c				  -	      sta	Platform
     85  385c				  -	      jmp	TitleSequence
     86  385c				  -platOK
     87  385c					      endif
     88  385c
     89  385c		       e6 c7	   k2	      inc	rnd
     90  385e		       f0 fc		      beq	k2
     91  3860
     92  3860
     93  3860		       85 42	   VerticalBlank sta	WSYNC
     94  3862		       ad 84 02 	      lda	INTIM
     95  3865		       d0 f9		      bne	VerticalBlank
     96  3867		       85 41		      sta	VBLANK
     97  3869
     98  3869							;sta COLUBK
     99  3869
    100  3869							;------------------------------------------------------------------
    101  3869
    102  3869							; Do X scanlines of color-changing (our picture)
    103  3869
    104  3869		       a0 d1		      ldy	#210-1	; this counts our scanline number
    105  386b		       a2 03	   SokoLogo   ldx	#3
    106  386d		       b1 db	   triplet    lda	(colour_table),y
    107  386f							;    eor digit-1,x
    108  386f		       85 42		      sta	WSYNC
    109  3871		       85 48		      sta	COLUPF	; 3
    110  3873
    111  3873		       b9 78 f2 	      lda	COL_0,y	; 5
    112  3876		       85 4d		      sta	PF0	; 3   @11
    113  3878		       b9 50 f3 	      lda	COL_1,y	; 5
    114  387b		       85 4e		      sta	PF1	; 3   @19
    115  387d		       b9 28 f4 	      lda	COL_2,y	; 5
    116  3880		       85 4f		      sta	PF2	; 3   @27
    117  3882
    118  3882		       b9 00 f5 	      lda	COL_3,y	; 5
    119  3885		       85 4d		      sta	PF0	; 3   @35
      0  3887					      SLEEP	2	; @37
      1  3887				   .CYCLES    SET	2
      2  3887
      3  3887				  -	      IF	.CYCLES < 2
      4  3887				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  3887				  -	      ERR
      6  3887					      ENDIF
      7  3887
      8  3887				  -	      IF	.CYCLES & 1
      9  3887				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  3887				  -	      nop	0
     11  3887				  -	      ELSE
     12  3887				  -	      bit	VSYNC
     13  3887				  -	      ENDIF
     14  3887				  -.CYCLES    SET	.CYCLES - 3
     15  3887					      ENDIF
     16  3887
     17  3887					      REPEAT	.CYCLES / 2
     18  3887		       ea		      nop
     19  3888					      REPEND
    121  3888		       b9 00 f6 	      lda	COL_4,y	; 5
    122  388b		       85 4e		      sta	PF1	; 3   @45
      0  388d					      SLEEP	3	; @45
      1  388d				   .CYCLES    SET	3
      2  388d
      3  388d				  -	      IF	.CYCLES < 2
      4  388d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  388d				  -	      ERR
      6  388d					      ENDIF
      7  388d
      8  388d					      IF	.CYCLES & 1
      9  388d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  388d		       04 00		      nop	0
     11  388f				  -	      ELSE
     12  388f				  -	      bit	VSYNC
     13  388f					      ENDIF
     14  388f				   .CYCLES    SET	.CYCLES - 3
     15  388f					      ENDIF
     16  388f
     17  388f				  -	      REPEAT	.CYCLES / 2
     18  388f				  -	      nop
     19  388f					      REPEND
    124  388f		       b9 00 f7 	      lda	COL_5,y	; 5
    125  3892		       85 4f		      sta	PF2	; 3
    126  3894
    127  3894		       88		      dey		; 2
    128  3895		       ca		      dex		; 2
    129  3896		       d0 d5		      bne	triplet	; 2(3)
    130  3898
    131  3898		       c0 ff		      cpy	#-1	; 2
    132  389a		       d0 cf		      bne	SokoLogo	; 2(3)
    133  389c
    134  389c							;lda #0
    135  389c							;sta PF0
    136  389c							;sta PF1
    137  389c							;sta PF2
    138  389c
    139  389c		       a6 80		      ldx	Platform
    140  389e		       bd 00 f0 	      lda	OverscanTime2,x
    141  38a1		       8d 96 02 	      sta	TIM64T
    142  38a4
    143  38a4				  -	      if	0
    144  38a4				  -	      sta	WSYNC
    145  38a4				  -	      sta	WSYNC
    146  38a4				  -	      sta	WSYNC
    147  38a4				  -	      sta	WSYNC
    148  38a4				  -	      sta	WSYNC
    149  38a4				  -	      SLEEP	8
    150  38a4				  -	      jsr	SokoScreen
    151  38a4				  -
    152  38a4				  -	      lda	#0
    153  38a4				  -	      sta	BoardScrollX
    154  38a4				  -	      sta	BoardScrollY
    155  38a4					      endif
    156  38a4
    157  38a4							;		ldy #63
    158  38a4							;bot2		 sta WSYNC
    159  38a4							;		dey
    160  38a4							;		bpl bot2
    161  38a4
    162  38a4							;--------------------------------------------------------------------------
    163  38a4
    164  38a4		       a9 00		      lda	#0
    165  38a6		       85 4d		      sta	PF0
    166  38a8		       85 4e		      sta	PF1
    167  38aa		       85 4f		      sta	PF2
    168  38ac
    169  38ac
      0  38ac					      NEXT_RANDOM
      1  38ac
      2  38ac		       a5 c7		      lda	rnd
      3  38ae		       4a		      lsr
      4  38af					      IFCONST	rndHi
      5  38af		       66 c6		      ror	rndHi
      6  38b1					      ENDIF
      7  38b1		       90 02		      bcc	.skipEOR
      8  38b3		       49 b4		      eor	#RND_EOR_VAL
      9  38b5				   .skipEOR
     10  38b5		       85 c7		      sta	rnd
    171  38b7
    172  38b7							; D1 VBLANK turns off beam
    173  38b7							; It needs to be turned on 37 scanlines later
    174  38b7
    175  38b7				   oscan
    176  38b7		       ad 84 02 	      lda	INTIM
    177  38ba		       d0 fb		      bne	oscan
    178  38bc
    179  38bc		       a9 42		      lda	#%01000010	; bit6 is not required
    180  38be		       85 41		      sta	VBLANK	; end of screen - enter blanking
    181  38c0
    182  38c0				  -	      if	0
    183  38c0				  -	      inc	rnd
    184  38c0				  -	      bne	rdd
    185  38c0				  -	      inc	rndHi
    186  38c0				  -rdd
    187  38c0				  -
    188  38c0				  -	      dec	digitick
    189  38c0				  -	      bpl	ret2
    190  38c0				  -	      lda	#40
    191  38c0				  -	      sta	digitick
    192  38c0				  -
    193  38c0				  -	      jsr	Random
    194  38c0				  -	      and	#3
    195  38c0				  -	      beq	ret2
    196  38c0				  -	      tax
    197  38c0				  -	      jsr	Random
    198  38c0				  -	      and	#$F0
    199  38c0				  -	      sta	digit-1,x
    200  38c0				  -	      jmp	RestartFrame0
    201  38c0				  -
    202  38c0				  -ret2
    203  38c0					      endif
    204  38c0
    205  38c0
    206  38c0		       a5 4c		      lda	INPT4
    207  38c2		       10 03		      bpl	ret
    208  38c4
    209  38c4		       4c 49 f0 	      jmp	RestartFrame
    210  38c7
    211  38c7				   ret
    212  38c7		       60		      rts
    213  38c8
    214  38c8
    215  38c8
    216  38c8					      MAC	lumtable
    217  38c8							; {4} MIN LUM 1
    218  38c8							; {5} MIN LUM 2
    219  38c8							; {6} MIN LUM 3
    220  38c8
    221  38c8				   .LUM1      SET	{4}*256
    222  38c8				   .LUM2      SET	{5}*256
    223  38c8				   .LUM3      SET	{6}*256
    224  38c8
    225  38c8				   .STEP1     =	(256*({7}-{4}))/72
    226  38c8				   .STEP2     =	(256*({8}-{5}))/72
    227  38c8				   .STEP3     =	(256*({9}-{6}))/72
    228  38c8
    229  38c8					      REPEAT	72
    230  38c8					      .byte	{1}+(.LUM1/256)
    231  38c8					      .byte	{2}+(.LUM2/256)
    232  38c8					      .byte	{3}+(.LUM3/256)
    233  38c8
    234  38c8							;    ECHO {1}+(.LUM1/256)
    235  38c8							;    ECHO {2}+(.LUM1/256)
    236  38c8							;    ECHO {3}+(.LUM1/256)
    237  38c8
    238  38c8				   .LUM1      SET	.LUM1 + .STEP1
    239  38c8				   .LUM2      SET	.LUM2 + .STEP2
    240  38c8				   .LUM3      SET	.LUM3 + .STEP3
    241  38c8					      REPEND
    242  38c8					      ENDM		;{1}{2}{3} base colours
    243  38c8
    244  38c8							;colr_pal    LUMTABLE $B0,$30,$A0,0,8,4 ;2,4,6
    245  38c8							;    OPTIONAL_PAGEBREAK "colr_ntsc", 72*3
    246  38c8
    247  38c8							;    ECHO "NTSC LUMS"
    248  38c8				   colr_ntsc
      0  38c8					      LUMTABLE	$A0,$10,$30,$4,$8,$A,$C,$2,$8
      1  38c8
      2  38c8
      3  38c8
      4  38c8
      5  38c8				   .LUM1      SET	$4*256
      6  38c8				   .LUM2      SET	$8*256
      7  38c8				   .LUM3      SET	$A*256
      8  38c8
      9  38c8		       00 1c	   .STEP1     =	(256*($C-$4))/72
     10  38c8		       ff ff ff eb .STEP2     =	(256*($2-$8))/72
     11  38c8		       ff ff ff f9 .STEP3     =	(256*($8-$A))/72
     12  38c8
     13  38c8					      REPEAT	72
     14  38c8		       a4		      .byte.b	$A0+(.LUM1/256)
     15  38c9		       18		      .byte.b	$10+(.LUM2/256)
     16  38ca		       3a		      .byte.b	$30+(.LUM3/256)
     17  38cb
     18  38cb
     19  38cb
     20  38cb
     21  38cb
     22  38cb				   .LUM1      SET	.LUM1 + .STEP1
     23  38cb				   .LUM2      SET	.LUM2 + .STEP2
     24  38cb				   .LUM3      SET	.LUM3 + .STEP3
     13  38cb					      REPEND
     14  38cb		       a4		      .byte.b	$A0+(.LUM1/256)
     15  38cc		       17		      .byte.b	$10+(.LUM2/256)
     16  38cd		       39		      .byte.b	$30+(.LUM3/256)
     17  38ce
     18  38ce
     19  38ce
     20  38ce
     21  38ce
     22  38ce				   .LUM1      SET	.LUM1 + .STEP1
     23  38ce				   .LUM2      SET	.LUM2 + .STEP2
     24  38ce				   .LUM3      SET	.LUM3 + .STEP3
     13  38ce					      REPEND
     14  38ce		       a4		      .byte.b	$A0+(.LUM1/256)
     15  38cf		       17		      .byte.b	$10+(.LUM2/256)
     16  38d0		       39		      .byte.b	$30+(.LUM3/256)
     17  38d1
     18  38d1
     19  38d1
     20  38d1
     21  38d1
     22  38d1				   .LUM1      SET	.LUM1 + .STEP1
     23  38d1				   .LUM2      SET	.LUM2 + .STEP2
     24  38d1				   .LUM3      SET	.LUM3 + .STEP3
     13  38d1					      REPEND
     14  38d1		       a4		      .byte.b	$A0+(.LUM1/256)
     15  38d2		       17		      .byte.b	$10+(.LUM2/256)
     16  38d3		       39		      .byte.b	$30+(.LUM3/256)
     17  38d4
     18  38d4
     19  38d4
     20  38d4
     21  38d4
     22  38d4				   .LUM1      SET	.LUM1 + .STEP1
     23  38d4				   .LUM2      SET	.LUM2 + .STEP2
     24  38d4				   .LUM3      SET	.LUM3 + .STEP3
     13  38d4					      REPEND
     14  38d4		       a4		      .byte.b	$A0+(.LUM1/256)
     15  38d5		       17		      .byte.b	$10+(.LUM2/256)
     16  38d6		       39		      .byte.b	$30+(.LUM3/256)
     17  38d7
     18  38d7
     19  38d7
     20  38d7
     21  38d7
     22  38d7				   .LUM1      SET	.LUM1 + .STEP1
     23  38d7				   .LUM2      SET	.LUM2 + .STEP2
     24  38d7				   .LUM3      SET	.LUM3 + .STEP3
     13  38d7					      REPEND
     14  38d7		       a4		      .byte.b	$A0+(.LUM1/256)
     15  38d8		       17		      .byte.b	$10+(.LUM2/256)
     16  38d9		       39		      .byte.b	$30+(.LUM3/256)
     17  38da
     18  38da
     19  38da
     20  38da
     21  38da
     22  38da				   .LUM1      SET	.LUM1 + .STEP1
     23  38da				   .LUM2      SET	.LUM2 + .STEP2
     24  38da				   .LUM3      SET	.LUM3 + .STEP3
     13  38da					      REPEND
     14  38da		       a4		      .byte.b	$A0+(.LUM1/256)
     15  38db		       17		      .byte.b	$10+(.LUM2/256)
     16  38dc		       39		      .byte.b	$30+(.LUM3/256)
     17  38dd
     18  38dd
     19  38dd
     20  38dd
     21  38dd
     22  38dd				   .LUM1      SET	.LUM1 + .STEP1
     23  38dd				   .LUM2      SET	.LUM2 + .STEP2
     24  38dd				   .LUM3      SET	.LUM3 + .STEP3
     13  38dd					      REPEND
     14  38dd		       a4		      .byte.b	$A0+(.LUM1/256)
     15  38de		       17		      .byte.b	$10+(.LUM2/256)
     16  38df		       39		      .byte.b	$30+(.LUM3/256)
     17  38e0
     18  38e0
     19  38e0
     20  38e0
     21  38e0
     22  38e0				   .LUM1      SET	.LUM1 + .STEP1
     23  38e0				   .LUM2      SET	.LUM2 + .STEP2
     24  38e0				   .LUM3      SET	.LUM3 + .STEP3
     13  38e0					      REPEND
     14  38e0		       a4		      .byte.b	$A0+(.LUM1/256)
     15  38e1		       17		      .byte.b	$10+(.LUM2/256)
     16  38e2		       39		      .byte.b	$30+(.LUM3/256)
     17  38e3
     18  38e3
     19  38e3
     20  38e3
     21  38e3
     22  38e3				   .LUM1      SET	.LUM1 + .STEP1
     23  38e3				   .LUM2      SET	.LUM2 + .STEP2
     24  38e3				   .LUM3      SET	.LUM3 + .STEP3
     13  38e3					      REPEND
     14  38e3		       a4		      .byte.b	$A0+(.LUM1/256)
     15  38e4		       17		      .byte.b	$10+(.LUM2/256)
     16  38e5		       39		      .byte.b	$30+(.LUM3/256)
     17  38e6
     18  38e6
     19  38e6
     20  38e6
     21  38e6
     22  38e6				   .LUM1      SET	.LUM1 + .STEP1
     23  38e6				   .LUM2      SET	.LUM2 + .STEP2
     24  38e6				   .LUM3      SET	.LUM3 + .STEP3
     13  38e6					      REPEND
     14  38e6		       a5		      .byte.b	$A0+(.LUM1/256)
     15  38e7		       17		      .byte.b	$10+(.LUM2/256)
     16  38e8		       39		      .byte.b	$30+(.LUM3/256)
     17  38e9
     18  38e9
     19  38e9
     20  38e9
     21  38e9
     22  38e9				   .LUM1      SET	.LUM1 + .STEP1
     23  38e9				   .LUM2      SET	.LUM2 + .STEP2
     24  38e9				   .LUM3      SET	.LUM3 + .STEP3
     13  38e9					      REPEND
     14  38e9		       a5		      .byte.b	$A0+(.LUM1/256)
     15  38ea		       17		      .byte.b	$10+(.LUM2/256)
     16  38eb		       39		      .byte.b	$30+(.LUM3/256)
     17  38ec
     18  38ec
     19  38ec
     20  38ec
     21  38ec
     22  38ec				   .LUM1      SET	.LUM1 + .STEP1
     23  38ec				   .LUM2      SET	.LUM2 + .STEP2
     24  38ec				   .LUM3      SET	.LUM3 + .STEP3
     13  38ec					      REPEND
     14  38ec		       a5		      .byte.b	$A0+(.LUM1/256)
     15  38ed		       17		      .byte.b	$10+(.LUM2/256)
     16  38ee		       39		      .byte.b	$30+(.LUM3/256)
     17  38ef
     18  38ef
     19  38ef
     20  38ef
     21  38ef
     22  38ef				   .LUM1      SET	.LUM1 + .STEP1
     23  38ef				   .LUM2      SET	.LUM2 + .STEP2
     24  38ef				   .LUM3      SET	.LUM3 + .STEP3
     13  38ef					      REPEND
     14  38ef		       a5		      .byte.b	$A0+(.LUM1/256)
     15  38f0		       16		      .byte.b	$10+(.LUM2/256)
     16  38f1		       39		      .byte.b	$30+(.LUM3/256)
     17  38f2
     18  38f2
     19  38f2
     20  38f2
     21  38f2
     22  38f2				   .LUM1      SET	.LUM1 + .STEP1
     23  38f2				   .LUM2      SET	.LUM2 + .STEP2
     24  38f2				   .LUM3      SET	.LUM3 + .STEP3
     13  38f2					      REPEND
     14  38f2		       a5		      .byte.b	$A0+(.LUM1/256)
     15  38f3		       16		      .byte.b	$10+(.LUM2/256)
     16  38f4		       39		      .byte.b	$30+(.LUM3/256)
     17  38f5
     18  38f5
     19  38f5
     20  38f5
     21  38f5
     22  38f5				   .LUM1      SET	.LUM1 + .STEP1
     23  38f5				   .LUM2      SET	.LUM2 + .STEP2
     24  38f5				   .LUM3      SET	.LUM3 + .STEP3
     13  38f5					      REPEND
     14  38f5		       a5		      .byte.b	$A0+(.LUM1/256)
     15  38f6		       16		      .byte.b	$10+(.LUM2/256)
     16  38f7		       39		      .byte.b	$30+(.LUM3/256)
     17  38f8
     18  38f8
     19  38f8
     20  38f8
     21  38f8
     22  38f8				   .LUM1      SET	.LUM1 + .STEP1
     23  38f8				   .LUM2      SET	.LUM2 + .STEP2
     24  38f8				   .LUM3      SET	.LUM3 + .STEP3
     13  38f8					      REPEND
     14  38f8		       a5		      .byte.b	$A0+(.LUM1/256)
     15  38f9		       16		      .byte.b	$10+(.LUM2/256)
     16  38fa		       39		      .byte.b	$30+(.LUM3/256)
     17  38fb
     18  38fb
     19  38fb
     20  38fb
     21  38fb
     22  38fb				   .LUM1      SET	.LUM1 + .STEP1
     23  38fb				   .LUM2      SET	.LUM2 + .STEP2
     24  38fb				   .LUM3      SET	.LUM3 + .STEP3
     13  38fb					      REPEND
     14  38fb		       a5		      .byte.b	$A0+(.LUM1/256)
     15  38fc		       16		      .byte.b	$10+(.LUM2/256)
     16  38fd		       39		      .byte.b	$30+(.LUM3/256)
     17  38fe
     18  38fe
     19  38fe
     20  38fe
     21  38fe
     22  38fe				   .LUM1      SET	.LUM1 + .STEP1
     23  38fe				   .LUM2      SET	.LUM2 + .STEP2
     24  38fe				   .LUM3      SET	.LUM3 + .STEP3
     13  38fe					      REPEND
     14  38fe		       a5		      .byte.b	$A0+(.LUM1/256)
     15  38ff		       16		      .byte.b	$10+(.LUM2/256)
     16  3900		       39		      .byte.b	$30+(.LUM3/256)
     17  3901
     18  3901
     19  3901
     20  3901
     21  3901
     22  3901				   .LUM1      SET	.LUM1 + .STEP1
     23  3901				   .LUM2      SET	.LUM2 + .STEP2
     24  3901				   .LUM3      SET	.LUM3 + .STEP3
     13  3901					      REPEND
     14  3901		       a6		      .byte.b	$A0+(.LUM1/256)
     15  3902		       16		      .byte.b	$10+(.LUM2/256)
     16  3903		       39		      .byte.b	$30+(.LUM3/256)
     17  3904
     18  3904
     19  3904
     20  3904
     21  3904
     22  3904				   .LUM1      SET	.LUM1 + .STEP1
     23  3904				   .LUM2      SET	.LUM2 + .STEP2
     24  3904				   .LUM3      SET	.LUM3 + .STEP3
     13  3904					      REPEND
     14  3904		       a6		      .byte.b	$A0+(.LUM1/256)
     15  3905		       16		      .byte.b	$10+(.LUM2/256)
     16  3906		       39		      .byte.b	$30+(.LUM3/256)
     17  3907
     18  3907
     19  3907
     20  3907
     21  3907
     22  3907				   .LUM1      SET	.LUM1 + .STEP1
     23  3907				   .LUM2      SET	.LUM2 + .STEP2
     24  3907				   .LUM3      SET	.LUM3 + .STEP3
     13  3907					      REPEND
     14  3907		       a6		      .byte.b	$A0+(.LUM1/256)
     15  3908		       16		      .byte.b	$10+(.LUM2/256)
     16  3909		       39		      .byte.b	$30+(.LUM3/256)
     17  390a
     18  390a
     19  390a
     20  390a
     21  390a
     22  390a				   .LUM1      SET	.LUM1 + .STEP1
     23  390a				   .LUM2      SET	.LUM2 + .STEP2
     24  390a				   .LUM3      SET	.LUM3 + .STEP3
     13  390a					      REPEND
     14  390a		       a6		      .byte.b	$A0+(.LUM1/256)
     15  390b		       16		      .byte.b	$10+(.LUM2/256)
     16  390c		       39		      .byte.b	$30+(.LUM3/256)
     17  390d
     18  390d
     19  390d
     20  390d
     21  390d
     22  390d				   .LUM1      SET	.LUM1 + .STEP1
     23  390d				   .LUM2      SET	.LUM2 + .STEP2
     24  390d				   .LUM3      SET	.LUM3 + .STEP3
     13  390d					      REPEND
     14  390d		       a6		      .byte.b	$A0+(.LUM1/256)
     15  390e		       16		      .byte.b	$10+(.LUM2/256)
     16  390f		       39		      .byte.b	$30+(.LUM3/256)
     17  3910
     18  3910
     19  3910
     20  3910
     21  3910
     22  3910				   .LUM1      SET	.LUM1 + .STEP1
     23  3910				   .LUM2      SET	.LUM2 + .STEP2
     24  3910				   .LUM3      SET	.LUM3 + .STEP3
     13  3910					      REPEND
     14  3910		       a6		      .byte.b	$A0+(.LUM1/256)
     15  3911		       16		      .byte.b	$10+(.LUM2/256)
     16  3912		       39		      .byte.b	$30+(.LUM3/256)
     17  3913
     18  3913
     19  3913
     20  3913
     21  3913
     22  3913				   .LUM1      SET	.LUM1 + .STEP1
     23  3913				   .LUM2      SET	.LUM2 + .STEP2
     24  3913				   .LUM3      SET	.LUM3 + .STEP3
     13  3913					      REPEND
     14  3913		       a6		      .byte.b	$A0+(.LUM1/256)
     15  3914		       15		      .byte.b	$10+(.LUM2/256)
     16  3915		       39		      .byte.b	$30+(.LUM3/256)
     17  3916
     18  3916
     19  3916
     20  3916
     21  3916
     22  3916				   .LUM1      SET	.LUM1 + .STEP1
     23  3916				   .LUM2      SET	.LUM2 + .STEP2
     24  3916				   .LUM3      SET	.LUM3 + .STEP3
     13  3916					      REPEND
     14  3916		       a6		      .byte.b	$A0+(.LUM1/256)
     15  3917		       15		      .byte.b	$10+(.LUM2/256)
     16  3918		       39		      .byte.b	$30+(.LUM3/256)
     17  3919
     18  3919
     19  3919
     20  3919
     21  3919
     22  3919				   .LUM1      SET	.LUM1 + .STEP1
     23  3919				   .LUM2      SET	.LUM2 + .STEP2
     24  3919				   .LUM3      SET	.LUM3 + .STEP3
     13  3919					      REPEND
     14  3919		       a6		      .byte.b	$A0+(.LUM1/256)
     15  391a		       15		      .byte.b	$10+(.LUM2/256)
     16  391b		       39		      .byte.b	$30+(.LUM3/256)
     17  391c
     18  391c
     19  391c
     20  391c
     21  391c
     22  391c				   .LUM1      SET	.LUM1 + .STEP1
     23  391c				   .LUM2      SET	.LUM2 + .STEP2
     24  391c				   .LUM3      SET	.LUM3 + .STEP3
     13  391c					      REPEND
     14  391c		       a7		      .byte.b	$A0+(.LUM1/256)
     15  391d		       15		      .byte.b	$10+(.LUM2/256)
     16  391e		       39		      .byte.b	$30+(.LUM3/256)
     17  391f
     18  391f
     19  391f
     20  391f
     21  391f
     22  391f				   .LUM1      SET	.LUM1 + .STEP1
     23  391f				   .LUM2      SET	.LUM2 + .STEP2
     24  391f				   .LUM3      SET	.LUM3 + .STEP3
     13  391f					      REPEND
     14  391f		       a7		      .byte.b	$A0+(.LUM1/256)
     15  3920		       15		      .byte.b	$10+(.LUM2/256)
     16  3921		       39		      .byte.b	$30+(.LUM3/256)
     17  3922
     18  3922
     19  3922
     20  3922
     21  3922
     22  3922				   .LUM1      SET	.LUM1 + .STEP1
     23  3922				   .LUM2      SET	.LUM2 + .STEP2
     24  3922				   .LUM3      SET	.LUM3 + .STEP3
     13  3922					      REPEND
     14  3922		       a7		      .byte.b	$A0+(.LUM1/256)
     15  3923		       15		      .byte.b	$10+(.LUM2/256)
     16  3924		       39		      .byte.b	$30+(.LUM3/256)
     17  3925
     18  3925
     19  3925
     20  3925
     21  3925
     22  3925				   .LUM1      SET	.LUM1 + .STEP1
     23  3925				   .LUM2      SET	.LUM2 + .STEP2
     24  3925				   .LUM3      SET	.LUM3 + .STEP3
     13  3925					      REPEND
     14  3925		       a7		      .byte.b	$A0+(.LUM1/256)
     15  3926		       15		      .byte.b	$10+(.LUM2/256)
     16  3927		       39		      .byte.b	$30+(.LUM3/256)
     17  3928
     18  3928
     19  3928
     20  3928
     21  3928
     22  3928				   .LUM1      SET	.LUM1 + .STEP1
     23  3928				   .LUM2      SET	.LUM2 + .STEP2
     24  3928				   .LUM3      SET	.LUM3 + .STEP3
     13  3928					      REPEND
     14  3928		       a7		      .byte.b	$A0+(.LUM1/256)
     15  3929		       15		      .byte.b	$10+(.LUM2/256)
     16  392a		       39		      .byte.b	$30+(.LUM3/256)
     17  392b
     18  392b
     19  392b
     20  392b
     21  392b
     22  392b				   .LUM1      SET	.LUM1 + .STEP1
     23  392b				   .LUM2      SET	.LUM2 + .STEP2
     24  392b				   .LUM3      SET	.LUM3 + .STEP3
     13  392b					      REPEND
     14  392b		       a7		      .byte.b	$A0+(.LUM1/256)
     15  392c		       15		      .byte.b	$10+(.LUM2/256)
     16  392d		       39		      .byte.b	$30+(.LUM3/256)
     17  392e
     18  392e
     19  392e
     20  392e
     21  392e
     22  392e				   .LUM1      SET	.LUM1 + .STEP1
     23  392e				   .LUM2      SET	.LUM2 + .STEP2
     24  392e				   .LUM3      SET	.LUM3 + .STEP3
     13  392e					      REPEND
     14  392e		       a7		      .byte.b	$A0+(.LUM1/256)
     15  392f		       15		      .byte.b	$10+(.LUM2/256)
     16  3930		       39		      .byte.b	$30+(.LUM3/256)
     17  3931
     18  3931
     19  3931
     20  3931
     21  3931
     22  3931				   .LUM1      SET	.LUM1 + .STEP1
     23  3931				   .LUM2      SET	.LUM2 + .STEP2
     24  3931				   .LUM3      SET	.LUM3 + .STEP3
     13  3931					      REPEND
     14  3931		       a7		      .byte.b	$A0+(.LUM1/256)
     15  3932		       15		      .byte.b	$10+(.LUM2/256)
     16  3933		       39		      .byte.b	$30+(.LUM3/256)
     17  3934
     18  3934
     19  3934
     20  3934
     21  3934
     22  3934				   .LUM1      SET	.LUM1 + .STEP1
     23  3934				   .LUM2      SET	.LUM2 + .STEP2
     24  3934				   .LUM3      SET	.LUM3 + .STEP3
     13  3934					      REPEND
     14  3934		       a7		      .byte.b	$A0+(.LUM1/256)
     15  3935		       15		      .byte.b	$10+(.LUM2/256)
     16  3936		       39		      .byte.b	$30+(.LUM3/256)
     17  3937
     18  3937
     19  3937
     20  3937
     21  3937
     22  3937				   .LUM1      SET	.LUM1 + .STEP1
     23  3937				   .LUM2      SET	.LUM2 + .STEP2
     24  3937				   .LUM3      SET	.LUM3 + .STEP3
     13  3937					      REPEND
     14  3937		       a8		      .byte.b	$A0+(.LUM1/256)
     15  3938		       14		      .byte.b	$10+(.LUM2/256)
     16  3939		       38		      .byte.b	$30+(.LUM3/256)
     17  393a
     18  393a
     19  393a
     20  393a
     21  393a
     22  393a				   .LUM1      SET	.LUM1 + .STEP1
     23  393a				   .LUM2      SET	.LUM2 + .STEP2
     24  393a				   .LUM3      SET	.LUM3 + .STEP3
     13  393a					      REPEND
     14  393a		       a8		      .byte.b	$A0+(.LUM1/256)
     15  393b		       14		      .byte.b	$10+(.LUM2/256)
     16  393c		       38		      .byte.b	$30+(.LUM3/256)
     17  393d
     18  393d
     19  393d
     20  393d
     21  393d
     22  393d				   .LUM1      SET	.LUM1 + .STEP1
     23  393d				   .LUM2      SET	.LUM2 + .STEP2
     24  393d				   .LUM3      SET	.LUM3 + .STEP3
     13  393d					      REPEND
     14  393d		       a8		      .byte.b	$A0+(.LUM1/256)
     15  393e		       14		      .byte.b	$10+(.LUM2/256)
     16  393f		       38		      .byte.b	$30+(.LUM3/256)
     17  3940
     18  3940
     19  3940
     20  3940
     21  3940
     22  3940				   .LUM1      SET	.LUM1 + .STEP1
     23  3940				   .LUM2      SET	.LUM2 + .STEP2
     24  3940				   .LUM3      SET	.LUM3 + .STEP3
     13  3940					      REPEND
     14  3940		       a8		      .byte.b	$A0+(.LUM1/256)
     15  3941		       14		      .byte.b	$10+(.LUM2/256)
     16  3942		       38		      .byte.b	$30+(.LUM3/256)
     17  3943
     18  3943
     19  3943
     20  3943
     21  3943
     22  3943				   .LUM1      SET	.LUM1 + .STEP1
     23  3943				   .LUM2      SET	.LUM2 + .STEP2
     24  3943				   .LUM3      SET	.LUM3 + .STEP3
     13  3943					      REPEND
     14  3943		       a8		      .byte.b	$A0+(.LUM1/256)
     15  3944		       14		      .byte.b	$10+(.LUM2/256)
     16  3945		       38		      .byte.b	$30+(.LUM3/256)
     17  3946
     18  3946
     19  3946
     20  3946
     21  3946
     22  3946				   .LUM1      SET	.LUM1 + .STEP1
     23  3946				   .LUM2      SET	.LUM2 + .STEP2
     24  3946				   .LUM3      SET	.LUM3 + .STEP3
     13  3946					      REPEND
     14  3946		       a8		      .byte.b	$A0+(.LUM1/256)
     15  3947		       14		      .byte.b	$10+(.LUM2/256)
     16  3948		       38		      .byte.b	$30+(.LUM3/256)
     17  3949
     18  3949
     19  3949
     20  3949
     21  3949
     22  3949				   .LUM1      SET	.LUM1 + .STEP1
     23  3949				   .LUM2      SET	.LUM2 + .STEP2
     24  3949				   .LUM3      SET	.LUM3 + .STEP3
     13  3949					      REPEND
     14  3949		       a8		      .byte.b	$A0+(.LUM1/256)
     15  394a		       14		      .byte.b	$10+(.LUM2/256)
     16  394b		       38		      .byte.b	$30+(.LUM3/256)
     17  394c
     18  394c
     19  394c
     20  394c
     21  394c
     22  394c				   .LUM1      SET	.LUM1 + .STEP1
     23  394c				   .LUM2      SET	.LUM2 + .STEP2
     24  394c				   .LUM3      SET	.LUM3 + .STEP3
     13  394c					      REPEND
     14  394c		       a8		      .byte.b	$A0+(.LUM1/256)
     15  394d		       14		      .byte.b	$10+(.LUM2/256)
     16  394e		       38		      .byte.b	$30+(.LUM3/256)
     17  394f
     18  394f
     19  394f
     20  394f
     21  394f
     22  394f				   .LUM1      SET	.LUM1 + .STEP1
     23  394f				   .LUM2      SET	.LUM2 + .STEP2
     24  394f				   .LUM3      SET	.LUM3 + .STEP3
     13  394f					      REPEND
     14  394f		       a8		      .byte.b	$A0+(.LUM1/256)
     15  3950		       14		      .byte.b	$10+(.LUM2/256)
     16  3951		       38		      .byte.b	$30+(.LUM3/256)
     17  3952
     18  3952
     19  3952
     20  3952
     21  3952
     22  3952				   .LUM1      SET	.LUM1 + .STEP1
     23  3952				   .LUM2      SET	.LUM2 + .STEP2
     24  3952				   .LUM3      SET	.LUM3 + .STEP3
     13  3952					      REPEND
     14  3952		       a9		      .byte.b	$A0+(.LUM1/256)
     15  3953		       14		      .byte.b	$10+(.LUM2/256)
     16  3954		       38		      .byte.b	$30+(.LUM3/256)
     17  3955
     18  3955
     19  3955
     20  3955
     21  3955
     22  3955				   .LUM1      SET	.LUM1 + .STEP1
     23  3955				   .LUM2      SET	.LUM2 + .STEP2
     24  3955				   .LUM3      SET	.LUM3 + .STEP3
     13  3955					      REPEND
     14  3955		       a9		      .byte.b	$A0+(.LUM1/256)
     15  3956		       14		      .byte.b	$10+(.LUM2/256)
     16  3957		       38		      .byte.b	$30+(.LUM3/256)
     17  3958
     18  3958
     19  3958
     20  3958
     21  3958
     22  3958				   .LUM1      SET	.LUM1 + .STEP1
     23  3958				   .LUM2      SET	.LUM2 + .STEP2
     24  3958				   .LUM3      SET	.LUM3 + .STEP3
     13  3958					      REPEND
     14  3958		       a9		      .byte.b	$A0+(.LUM1/256)
     15  3959		       14		      .byte.b	$10+(.LUM2/256)
     16  395a		       38		      .byte.b	$30+(.LUM3/256)
     17  395b
     18  395b
     19  395b
     20  395b
     21  395b
     22  395b				   .LUM1      SET	.LUM1 + .STEP1
     23  395b				   .LUM2      SET	.LUM2 + .STEP2
     24  395b				   .LUM3      SET	.LUM3 + .STEP3
     13  395b					      REPEND
     14  395b		       a9		      .byte.b	$A0+(.LUM1/256)
     15  395c		       13		      .byte.b	$10+(.LUM2/256)
     16  395d		       38		      .byte.b	$30+(.LUM3/256)
     17  395e
     18  395e
     19  395e
     20  395e
     21  395e
     22  395e				   .LUM1      SET	.LUM1 + .STEP1
     23  395e				   .LUM2      SET	.LUM2 + .STEP2
     24  395e				   .LUM3      SET	.LUM3 + .STEP3
     13  395e					      REPEND
     14  395e		       a9		      .byte.b	$A0+(.LUM1/256)
     15  395f		       13		      .byte.b	$10+(.LUM2/256)
     16  3960		       38		      .byte.b	$30+(.LUM3/256)
     17  3961
     18  3961
     19  3961
     20  3961
     21  3961
     22  3961				   .LUM1      SET	.LUM1 + .STEP1
     23  3961				   .LUM2      SET	.LUM2 + .STEP2
     24  3961				   .LUM3      SET	.LUM3 + .STEP3
     13  3961					      REPEND
     14  3961		       a9		      .byte.b	$A0+(.LUM1/256)
     15  3962		       13		      .byte.b	$10+(.LUM2/256)
     16  3963		       38		      .byte.b	$30+(.LUM3/256)
     17  3964
     18  3964
     19  3964
     20  3964
     21  3964
     22  3964				   .LUM1      SET	.LUM1 + .STEP1
     23  3964				   .LUM2      SET	.LUM2 + .STEP2
     24  3964				   .LUM3      SET	.LUM3 + .STEP3
     13  3964					      REPEND
     14  3964		       a9		      .byte.b	$A0+(.LUM1/256)
     15  3965		       13		      .byte.b	$10+(.LUM2/256)
     16  3966		       38		      .byte.b	$30+(.LUM3/256)
     17  3967
     18  3967
     19  3967
     20  3967
     21  3967
     22  3967				   .LUM1      SET	.LUM1 + .STEP1
     23  3967				   .LUM2      SET	.LUM2 + .STEP2
     24  3967				   .LUM3      SET	.LUM3 + .STEP3
     13  3967					      REPEND
     14  3967		       a9		      .byte.b	$A0+(.LUM1/256)
     15  3968		       13		      .byte.b	$10+(.LUM2/256)
     16  3969		       38		      .byte.b	$30+(.LUM3/256)
     17  396a
     18  396a
     19  396a
     20  396a
     21  396a
     22  396a				   .LUM1      SET	.LUM1 + .STEP1
     23  396a				   .LUM2      SET	.LUM2 + .STEP2
     24  396a				   .LUM3      SET	.LUM3 + .STEP3
     13  396a					      REPEND
     14  396a		       a9		      .byte.b	$A0+(.LUM1/256)
     15  396b		       13		      .byte.b	$10+(.LUM2/256)
     16  396c		       38		      .byte.b	$30+(.LUM3/256)
     17  396d
     18  396d
     19  396d
     20  396d
     21  396d
     22  396d				   .LUM1      SET	.LUM1 + .STEP1
     23  396d				   .LUM2      SET	.LUM2 + .STEP2
     24  396d				   .LUM3      SET	.LUM3 + .STEP3
     13  396d					      REPEND
     14  396d		       aa		      .byte.b	$A0+(.LUM1/256)
     15  396e		       13		      .byte.b	$10+(.LUM2/256)
     16  396f		       38		      .byte.b	$30+(.LUM3/256)
     17  3970
     18  3970
     19  3970
     20  3970
     21  3970
     22  3970				   .LUM1      SET	.LUM1 + .STEP1
     23  3970				   .LUM2      SET	.LUM2 + .STEP2
     24  3970				   .LUM3      SET	.LUM3 + .STEP3
     13  3970					      REPEND
     14  3970		       aa		      .byte.b	$A0+(.LUM1/256)
     15  3971		       13		      .byte.b	$10+(.LUM2/256)
     16  3972		       38		      .byte.b	$30+(.LUM3/256)
     17  3973
     18  3973
     19  3973
     20  3973
     21  3973
     22  3973				   .LUM1      SET	.LUM1 + .STEP1
     23  3973				   .LUM2      SET	.LUM2 + .STEP2
     24  3973				   .LUM3      SET	.LUM3 + .STEP3
     13  3973					      REPEND
     14  3973		       aa		      .byte.b	$A0+(.LUM1/256)
     15  3974		       13		      .byte.b	$10+(.LUM2/256)
     16  3975		       38		      .byte.b	$30+(.LUM3/256)
     17  3976
     18  3976
     19  3976
     20  3976
     21  3976
     22  3976				   .LUM1      SET	.LUM1 + .STEP1
     23  3976				   .LUM2      SET	.LUM2 + .STEP2
     24  3976				   .LUM3      SET	.LUM3 + .STEP3
     13  3976					      REPEND
     14  3976		       aa		      .byte.b	$A0+(.LUM1/256)
     15  3977		       13		      .byte.b	$10+(.LUM2/256)
     16  3978		       38		      .byte.b	$30+(.LUM3/256)
     17  3979
     18  3979
     19  3979
     20  3979
     21  3979
     22  3979				   .LUM1      SET	.LUM1 + .STEP1
     23  3979				   .LUM2      SET	.LUM2 + .STEP2
     24  3979				   .LUM3      SET	.LUM3 + .STEP3
     13  3979					      REPEND
     14  3979		       aa		      .byte.b	$A0+(.LUM1/256)
     15  397a		       13		      .byte.b	$10+(.LUM2/256)
     16  397b		       38		      .byte.b	$30+(.LUM3/256)
     17  397c
     18  397c
     19  397c
     20  397c
     21  397c
     22  397c				   .LUM1      SET	.LUM1 + .STEP1
     23  397c				   .LUM2      SET	.LUM2 + .STEP2
     24  397c				   .LUM3      SET	.LUM3 + .STEP3
     13  397c					      REPEND
     14  397c		       aa		      .byte.b	$A0+(.LUM1/256)
     15  397d		       13		      .byte.b	$10+(.LUM2/256)
     16  397e		       38		      .byte.b	$30+(.LUM3/256)
     17  397f
     18  397f
     19  397f
     20  397f
     21  397f
     22  397f				   .LUM1      SET	.LUM1 + .STEP1
     23  397f				   .LUM2      SET	.LUM2 + .STEP2
     24  397f				   .LUM3      SET	.LUM3 + .STEP3
     13  397f					      REPEND
     14  397f		       aa		      .byte.b	$A0+(.LUM1/256)
     15  3980		       12		      .byte.b	$10+(.LUM2/256)
     16  3981		       38		      .byte.b	$30+(.LUM3/256)
     17  3982
     18  3982
     19  3982
     20  3982
     21  3982
     22  3982				   .LUM1      SET	.LUM1 + .STEP1
     23  3982				   .LUM2      SET	.LUM2 + .STEP2
     24  3982				   .LUM3      SET	.LUM3 + .STEP3
     13  3982					      REPEND
     14  3982		       aa		      .byte.b	$A0+(.LUM1/256)
     15  3983		       12		      .byte.b	$10+(.LUM2/256)
     16  3984		       38		      .byte.b	$30+(.LUM3/256)
     17  3985
     18  3985
     19  3985
     20  3985
     21  3985
     22  3985				   .LUM1      SET	.LUM1 + .STEP1
     23  3985				   .LUM2      SET	.LUM2 + .STEP2
     24  3985				   .LUM3      SET	.LUM3 + .STEP3
     13  3985					      REPEND
     14  3985		       aa		      .byte.b	$A0+(.LUM1/256)
     15  3986		       12		      .byte.b	$10+(.LUM2/256)
     16  3987		       38		      .byte.b	$30+(.LUM3/256)
     17  3988
     18  3988
     19  3988
     20  3988
     21  3988
     22  3988				   .LUM1      SET	.LUM1 + .STEP1
     23  3988				   .LUM2      SET	.LUM2 + .STEP2
     24  3988				   .LUM3      SET	.LUM3 + .STEP3
     13  3988					      REPEND
     14  3988		       ab		      .byte.b	$A0+(.LUM1/256)
     15  3989		       12		      .byte.b	$10+(.LUM2/256)
     16  398a		       38		      .byte.b	$30+(.LUM3/256)
     17  398b
     18  398b
     19  398b
     20  398b
     21  398b
     22  398b				   .LUM1      SET	.LUM1 + .STEP1
     23  398b				   .LUM2      SET	.LUM2 + .STEP2
     24  398b				   .LUM3      SET	.LUM3 + .STEP3
     13  398b					      REPEND
     14  398b		       ab		      .byte.b	$A0+(.LUM1/256)
     15  398c		       12		      .byte.b	$10+(.LUM2/256)
     16  398d		       38		      .byte.b	$30+(.LUM3/256)
     17  398e
     18  398e
     19  398e
     20  398e
     21  398e
     22  398e				   .LUM1      SET	.LUM1 + .STEP1
     23  398e				   .LUM2      SET	.LUM2 + .STEP2
     24  398e				   .LUM3      SET	.LUM3 + .STEP3
     13  398e					      REPEND
     14  398e		       ab		      .byte.b	$A0+(.LUM1/256)
     15  398f		       12		      .byte.b	$10+(.LUM2/256)
     16  3990		       38		      .byte.b	$30+(.LUM3/256)
     17  3991
     18  3991
     19  3991
     20  3991
     21  3991
     22  3991				   .LUM1      SET	.LUM1 + .STEP1
     23  3991				   .LUM2      SET	.LUM2 + .STEP2
     24  3991				   .LUM3      SET	.LUM3 + .STEP3
     13  3991					      REPEND
     14  3991		       ab		      .byte.b	$A0+(.LUM1/256)
     15  3992		       12		      .byte.b	$10+(.LUM2/256)
     16  3993		       38		      .byte.b	$30+(.LUM3/256)
     17  3994
     18  3994
     19  3994
     20  3994
     21  3994
     22  3994				   .LUM1      SET	.LUM1 + .STEP1
     23  3994				   .LUM2      SET	.LUM2 + .STEP2
     24  3994				   .LUM3      SET	.LUM3 + .STEP3
     13  3994					      REPEND
     14  3994		       ab		      .byte.b	$A0+(.LUM1/256)
     15  3995		       12		      .byte.b	$10+(.LUM2/256)
     16  3996		       38		      .byte.b	$30+(.LUM3/256)
     17  3997
     18  3997
     19  3997
     20  3997
     21  3997
     22  3997				   .LUM1      SET	.LUM1 + .STEP1
     23  3997				   .LUM2      SET	.LUM2 + .STEP2
     24  3997				   .LUM3      SET	.LUM3 + .STEP3
     13  3997					      REPEND
     14  3997		       ab		      .byte.b	$A0+(.LUM1/256)
     15  3998		       12		      .byte.b	$10+(.LUM2/256)
     16  3999		       38		      .byte.b	$30+(.LUM3/256)
     17  399a
     18  399a
     19  399a
     20  399a
     21  399a
     22  399a				   .LUM1      SET	.LUM1 + .STEP1
     23  399a				   .LUM2      SET	.LUM2 + .STEP2
     24  399a				   .LUM3      SET	.LUM3 + .STEP3
     13  399a					      REPEND
     14  399a		       ab		      .byte.b	$A0+(.LUM1/256)
     15  399b		       12		      .byte.b	$10+(.LUM2/256)
     16  399c		       38		      .byte.b	$30+(.LUM3/256)
     17  399d
     18  399d
     19  399d
     20  399d
     21  399d
     22  399d				   .LUM1      SET	.LUM1 + .STEP1
     23  399d				   .LUM2      SET	.LUM2 + .STEP2
     24  399d				   .LUM3      SET	.LUM3 + .STEP3
     13  399d					      REPEND
     14  399d		       ab		      .byte.b	$A0+(.LUM1/256)
     15  399e		       12		      .byte.b	$10+(.LUM2/256)
     16  399f		       38		      .byte.b	$30+(.LUM3/256)
     17  39a0
     18  39a0
     19  39a0
     20  39a0
     21  39a0
     22  39a0				   .LUM1      SET	.LUM1 + .STEP1
     23  39a0				   .LUM2      SET	.LUM2 + .STEP2
     24  39a0				   .LUM3      SET	.LUM3 + .STEP3
     25  39a0					      REPEND
    250  39a0							;colr_ntsc   LUMTABLE $70,$40,$a0,$A,$2,$E,$8,$E,$8
    251  39a0
    252  39a0							;    ECHO "PAL LUMS"
    253  39a0							;    OPTIONAL_PAGEBREAK "colr_pal", 72*3
    254  39a0							;colr_pal	  LUMTABLE $b0, $60, $20, $A,$6,$C,$8,$C,$8
      0  39a0				   colr_pal   LUMTABLE	$90, $20, $60, $6,$A,$a,$C,$6,$8
      1  39a0
      2  39a0
      3  39a0
      4  39a0
      5  39a0				   .LUM1      SET	$6*256
      6  39a0				   .LUM2      SET	$A*256
      7  39a0				   .LUM3      SET	$a*256
      8  39a0
      9  39a0		       00 15	   .STEP1     =	(256*($C-$6))/72
     10  39a0		       ff ff ff f2 .STEP2     =	(256*($6-$A))/72
     11  39a0		       ff ff ff f9 .STEP3     =	(256*($8-$a))/72
     12  39a0
     13  39a0					      REPEAT	72
     14  39a0		       96		      .byte.b	$90+(.LUM1/256)
     15  39a1		       2a		      .byte.b	$20+(.LUM2/256)
     16  39a2		       6a		      .byte.b	$60+(.LUM3/256)
     17  39a3
     18  39a3
     19  39a3
     20  39a3
     21  39a3
     22  39a3				   .LUM1      SET	.LUM1 + .STEP1
     23  39a3				   .LUM2      SET	.LUM2 + .STEP2
     24  39a3				   .LUM3      SET	.LUM3 + .STEP3
     13  39a3					      REPEND
     14  39a3		       96		      .byte.b	$90+(.LUM1/256)
     15  39a4		       29		      .byte.b	$20+(.LUM2/256)
     16  39a5		       69		      .byte.b	$60+(.LUM3/256)
     17  39a6
     18  39a6
     19  39a6
     20  39a6
     21  39a6
     22  39a6				   .LUM1      SET	.LUM1 + .STEP1
     23  39a6				   .LUM2      SET	.LUM2 + .STEP2
     24  39a6				   .LUM3      SET	.LUM3 + .STEP3
     13  39a6					      REPEND
     14  39a6		       96		      .byte.b	$90+(.LUM1/256)
     15  39a7		       29		      .byte.b	$20+(.LUM2/256)
     16  39a8		       69		      .byte.b	$60+(.LUM3/256)
     17  39a9
     18  39a9
     19  39a9
     20  39a9
     21  39a9
     22  39a9				   .LUM1      SET	.LUM1 + .STEP1
     23  39a9				   .LUM2      SET	.LUM2 + .STEP2
     24  39a9				   .LUM3      SET	.LUM3 + .STEP3
     13  39a9					      REPEND
     14  39a9		       96		      .byte.b	$90+(.LUM1/256)
     15  39aa		       29		      .byte.b	$20+(.LUM2/256)
     16  39ab		       69		      .byte.b	$60+(.LUM3/256)
     17  39ac
     18  39ac
     19  39ac
     20  39ac
     21  39ac
     22  39ac				   .LUM1      SET	.LUM1 + .STEP1
     23  39ac				   .LUM2      SET	.LUM2 + .STEP2
     24  39ac				   .LUM3      SET	.LUM3 + .STEP3
     13  39ac					      REPEND
     14  39ac		       96		      .byte.b	$90+(.LUM1/256)
     15  39ad		       29		      .byte.b	$20+(.LUM2/256)
     16  39ae		       69		      .byte.b	$60+(.LUM3/256)
     17  39af
     18  39af
     19  39af
     20  39af
     21  39af
     22  39af				   .LUM1      SET	.LUM1 + .STEP1
     23  39af				   .LUM2      SET	.LUM2 + .STEP2
     24  39af				   .LUM3      SET	.LUM3 + .STEP3
     13  39af					      REPEND
     14  39af		       96		      .byte.b	$90+(.LUM1/256)
     15  39b0		       29		      .byte.b	$20+(.LUM2/256)
     16  39b1		       69		      .byte.b	$60+(.LUM3/256)
     17  39b2
     18  39b2
     19  39b2
     20  39b2
     21  39b2
     22  39b2				   .LUM1      SET	.LUM1 + .STEP1
     23  39b2				   .LUM2      SET	.LUM2 + .STEP2
     24  39b2				   .LUM3      SET	.LUM3 + .STEP3
     13  39b2					      REPEND
     14  39b2		       96		      .byte.b	$90+(.LUM1/256)
     15  39b3		       29		      .byte.b	$20+(.LUM2/256)
     16  39b4		       69		      .byte.b	$60+(.LUM3/256)
     17  39b5
     18  39b5
     19  39b5
     20  39b5
     21  39b5
     22  39b5				   .LUM1      SET	.LUM1 + .STEP1
     23  39b5				   .LUM2      SET	.LUM2 + .STEP2
     24  39b5				   .LUM3      SET	.LUM3 + .STEP3
     13  39b5					      REPEND
     14  39b5		       96		      .byte.b	$90+(.LUM1/256)
     15  39b6		       29		      .byte.b	$20+(.LUM2/256)
     16  39b7		       69		      .byte.b	$60+(.LUM3/256)
     17  39b8
     18  39b8
     19  39b8
     20  39b8
     21  39b8
     22  39b8				   .LUM1      SET	.LUM1 + .STEP1
     23  39b8				   .LUM2      SET	.LUM2 + .STEP2
     24  39b8				   .LUM3      SET	.LUM3 + .STEP3
     13  39b8					      REPEND
     14  39b8		       96		      .byte.b	$90+(.LUM1/256)
     15  39b9		       29		      .byte.b	$20+(.LUM2/256)
     16  39ba		       69		      .byte.b	$60+(.LUM3/256)
     17  39bb
     18  39bb
     19  39bb
     20  39bb
     21  39bb
     22  39bb				   .LUM1      SET	.LUM1 + .STEP1
     23  39bb				   .LUM2      SET	.LUM2 + .STEP2
     24  39bb				   .LUM3      SET	.LUM3 + .STEP3
     13  39bb					      REPEND
     14  39bb		       96		      .byte.b	$90+(.LUM1/256)
     15  39bc		       29		      .byte.b	$20+(.LUM2/256)
     16  39bd		       69		      .byte.b	$60+(.LUM3/256)
     17  39be
     18  39be
     19  39be
     20  39be
     21  39be
     22  39be				   .LUM1      SET	.LUM1 + .STEP1
     23  39be				   .LUM2      SET	.LUM2 + .STEP2
     24  39be				   .LUM3      SET	.LUM3 + .STEP3
     13  39be					      REPEND
     14  39be		       96		      .byte.b	$90+(.LUM1/256)
     15  39bf		       29		      .byte.b	$20+(.LUM2/256)
     16  39c0		       69		      .byte.b	$60+(.LUM3/256)
     17  39c1
     18  39c1
     19  39c1
     20  39c1
     21  39c1
     22  39c1				   .LUM1      SET	.LUM1 + .STEP1
     23  39c1				   .LUM2      SET	.LUM2 + .STEP2
     24  39c1				   .LUM3      SET	.LUM3 + .STEP3
     13  39c1					      REPEND
     14  39c1		       96		      .byte.b	$90+(.LUM1/256)
     15  39c2		       29		      .byte.b	$20+(.LUM2/256)
     16  39c3		       69		      .byte.b	$60+(.LUM3/256)
     17  39c4
     18  39c4
     19  39c4
     20  39c4
     21  39c4
     22  39c4				   .LUM1      SET	.LUM1 + .STEP1
     23  39c4				   .LUM2      SET	.LUM2 + .STEP2
     24  39c4				   .LUM3      SET	.LUM3 + .STEP3
     13  39c4					      REPEND
     14  39c4		       96		      .byte.b	$90+(.LUM1/256)
     15  39c5		       29		      .byte.b	$20+(.LUM2/256)
     16  39c6		       69		      .byte.b	$60+(.LUM3/256)
     17  39c7
     18  39c7
     19  39c7
     20  39c7
     21  39c7
     22  39c7				   .LUM1      SET	.LUM1 + .STEP1
     23  39c7				   .LUM2      SET	.LUM2 + .STEP2
     24  39c7				   .LUM3      SET	.LUM3 + .STEP3
     13  39c7					      REPEND
     14  39c7		       97		      .byte.b	$90+(.LUM1/256)
     15  39c8		       29		      .byte.b	$20+(.LUM2/256)
     16  39c9		       69		      .byte.b	$60+(.LUM3/256)
     17  39ca
     18  39ca
     19  39ca
     20  39ca
     21  39ca
     22  39ca				   .LUM1      SET	.LUM1 + .STEP1
     23  39ca				   .LUM2      SET	.LUM2 + .STEP2
     24  39ca				   .LUM3      SET	.LUM3 + .STEP3
     13  39ca					      REPEND
     14  39ca		       97		      .byte.b	$90+(.LUM1/256)
     15  39cb		       29		      .byte.b	$20+(.LUM2/256)
     16  39cc		       69		      .byte.b	$60+(.LUM3/256)
     17  39cd
     18  39cd
     19  39cd
     20  39cd
     21  39cd
     22  39cd				   .LUM1      SET	.LUM1 + .STEP1
     23  39cd				   .LUM2      SET	.LUM2 + .STEP2
     24  39cd				   .LUM3      SET	.LUM3 + .STEP3
     13  39cd					      REPEND
     14  39cd		       97		      .byte.b	$90+(.LUM1/256)
     15  39ce		       29		      .byte.b	$20+(.LUM2/256)
     16  39cf		       69		      .byte.b	$60+(.LUM3/256)
     17  39d0
     18  39d0
     19  39d0
     20  39d0
     21  39d0
     22  39d0				   .LUM1      SET	.LUM1 + .STEP1
     23  39d0				   .LUM2      SET	.LUM2 + .STEP2
     24  39d0				   .LUM3      SET	.LUM3 + .STEP3
     13  39d0					      REPEND
     14  39d0		       97		      .byte.b	$90+(.LUM1/256)
     15  39d1		       29		      .byte.b	$20+(.LUM2/256)
     16  39d2		       69		      .byte.b	$60+(.LUM3/256)
     17  39d3
     18  39d3
     19  39d3
     20  39d3
     21  39d3
     22  39d3				   .LUM1      SET	.LUM1 + .STEP1
     23  39d3				   .LUM2      SET	.LUM2 + .STEP2
     24  39d3				   .LUM3      SET	.LUM3 + .STEP3
     13  39d3					      REPEND
     14  39d3		       97		      .byte.b	$90+(.LUM1/256)
     15  39d4		       29		      .byte.b	$20+(.LUM2/256)
     16  39d5		       69		      .byte.b	$60+(.LUM3/256)
     17  39d6
     18  39d6
     19  39d6
     20  39d6
     21  39d6
     22  39d6				   .LUM1      SET	.LUM1 + .STEP1
     23  39d6				   .LUM2      SET	.LUM2 + .STEP2
     24  39d6				   .LUM3      SET	.LUM3 + .STEP3
     13  39d6					      REPEND
     14  39d6		       97		      .byte.b	$90+(.LUM1/256)
     15  39d7		       29		      .byte.b	$20+(.LUM2/256)
     16  39d8		       69		      .byte.b	$60+(.LUM3/256)
     17  39d9
     18  39d9
     19  39d9
     20  39d9
     21  39d9
     22  39d9				   .LUM1      SET	.LUM1 + .STEP1
     23  39d9				   .LUM2      SET	.LUM2 + .STEP2
     24  39d9				   .LUM3      SET	.LUM3 + .STEP3
     13  39d9					      REPEND
     14  39d9		       97		      .byte.b	$90+(.LUM1/256)
     15  39da		       28		      .byte.b	$20+(.LUM2/256)
     16  39db		       69		      .byte.b	$60+(.LUM3/256)
     17  39dc
     18  39dc
     19  39dc
     20  39dc
     21  39dc
     22  39dc				   .LUM1      SET	.LUM1 + .STEP1
     23  39dc				   .LUM2      SET	.LUM2 + .STEP2
     24  39dc				   .LUM3      SET	.LUM3 + .STEP3
     13  39dc					      REPEND
     14  39dc		       97		      .byte.b	$90+(.LUM1/256)
     15  39dd		       28		      .byte.b	$20+(.LUM2/256)
     16  39de		       69		      .byte.b	$60+(.LUM3/256)
     17  39df
     18  39df
     19  39df
     20  39df
     21  39df
     22  39df				   .LUM1      SET	.LUM1 + .STEP1
     23  39df				   .LUM2      SET	.LUM2 + .STEP2
     24  39df				   .LUM3      SET	.LUM3 + .STEP3
     13  39df					      REPEND
     14  39df		       97		      .byte.b	$90+(.LUM1/256)
     15  39e0		       28		      .byte.b	$20+(.LUM2/256)
     16  39e1		       69		      .byte.b	$60+(.LUM3/256)
     17  39e2
     18  39e2
     19  39e2
     20  39e2
     21  39e2
     22  39e2				   .LUM1      SET	.LUM1 + .STEP1
     23  39e2				   .LUM2      SET	.LUM2 + .STEP2
     24  39e2				   .LUM3      SET	.LUM3 + .STEP3
     13  39e2					      REPEND
     14  39e2		       97		      .byte.b	$90+(.LUM1/256)
     15  39e3		       28		      .byte.b	$20+(.LUM2/256)
     16  39e4		       69		      .byte.b	$60+(.LUM3/256)
     17  39e5
     18  39e5
     19  39e5
     20  39e5
     21  39e5
     22  39e5				   .LUM1      SET	.LUM1 + .STEP1
     23  39e5				   .LUM2      SET	.LUM2 + .STEP2
     24  39e5				   .LUM3      SET	.LUM3 + .STEP3
     13  39e5					      REPEND
     14  39e5		       97		      .byte.b	$90+(.LUM1/256)
     15  39e6		       28		      .byte.b	$20+(.LUM2/256)
     16  39e7		       69		      .byte.b	$60+(.LUM3/256)
     17  39e8
     18  39e8
     19  39e8
     20  39e8
     21  39e8
     22  39e8				   .LUM1      SET	.LUM1 + .STEP1
     23  39e8				   .LUM2      SET	.LUM2 + .STEP2
     24  39e8				   .LUM3      SET	.LUM3 + .STEP3
     13  39e8					      REPEND
     14  39e8		       97		      .byte.b	$90+(.LUM1/256)
     15  39e9		       28		      .byte.b	$20+(.LUM2/256)
     16  39ea		       69		      .byte.b	$60+(.LUM3/256)
     17  39eb
     18  39eb
     19  39eb
     20  39eb
     21  39eb
     22  39eb				   .LUM1      SET	.LUM1 + .STEP1
     23  39eb				   .LUM2      SET	.LUM2 + .STEP2
     24  39eb				   .LUM3      SET	.LUM3 + .STEP3
     13  39eb					      REPEND
     14  39eb		       98		      .byte.b	$90+(.LUM1/256)
     15  39ec		       28		      .byte.b	$20+(.LUM2/256)
     16  39ed		       69		      .byte.b	$60+(.LUM3/256)
     17  39ee
     18  39ee
     19  39ee
     20  39ee
     21  39ee
     22  39ee				   .LUM1      SET	.LUM1 + .STEP1
     23  39ee				   .LUM2      SET	.LUM2 + .STEP2
     24  39ee				   .LUM3      SET	.LUM3 + .STEP3
     13  39ee					      REPEND
     14  39ee		       98		      .byte.b	$90+(.LUM1/256)
     15  39ef		       28		      .byte.b	$20+(.LUM2/256)
     16  39f0		       69		      .byte.b	$60+(.LUM3/256)
     17  39f1
     18  39f1
     19  39f1
     20  39f1
     21  39f1
     22  39f1				   .LUM1      SET	.LUM1 + .STEP1
     23  39f1				   .LUM2      SET	.LUM2 + .STEP2
     24  39f1				   .LUM3      SET	.LUM3 + .STEP3
     13  39f1					      REPEND
     14  39f1		       98		      .byte.b	$90+(.LUM1/256)
     15  39f2		       28		      .byte.b	$20+(.LUM2/256)
     16  39f3		       69		      .byte.b	$60+(.LUM3/256)
     17  39f4
     18  39f4
     19  39f4
     20  39f4
     21  39f4
     22  39f4				   .LUM1      SET	.LUM1 + .STEP1
     23  39f4				   .LUM2      SET	.LUM2 + .STEP2
     24  39f4				   .LUM3      SET	.LUM3 + .STEP3
     13  39f4					      REPEND
     14  39f4		       98		      .byte.b	$90+(.LUM1/256)
     15  39f5		       28		      .byte.b	$20+(.LUM2/256)
     16  39f6		       69		      .byte.b	$60+(.LUM3/256)
     17  39f7
     18  39f7
     19  39f7
     20  39f7
     21  39f7
     22  39f7				   .LUM1      SET	.LUM1 + .STEP1
     23  39f7				   .LUM2      SET	.LUM2 + .STEP2
     24  39f7				   .LUM3      SET	.LUM3 + .STEP3
     13  39f7					      REPEND
     14  39f7		       98		      .byte.b	$90+(.LUM1/256)
     15  39f8		       28		      .byte.b	$20+(.LUM2/256)
     16  39f9		       69		      .byte.b	$60+(.LUM3/256)
     17  39fa
     18  39fa
     19  39fa
     20  39fa
     21  39fa
     22  39fa				   .LUM1      SET	.LUM1 + .STEP1
     23  39fa				   .LUM2      SET	.LUM2 + .STEP2
     24  39fa				   .LUM3      SET	.LUM3 + .STEP3
     13  39fa					      REPEND
     14  39fa		       98		      .byte.b	$90+(.LUM1/256)
     15  39fb		       28		      .byte.b	$20+(.LUM2/256)
     16  39fc		       69		      .byte.b	$60+(.LUM3/256)
     17  39fd
     18  39fd
     19  39fd
     20  39fd
     21  39fd
     22  39fd				   .LUM1      SET	.LUM1 + .STEP1
     23  39fd				   .LUM2      SET	.LUM2 + .STEP2
     24  39fd				   .LUM3      SET	.LUM3 + .STEP3
     13  39fd					      REPEND
     14  39fd		       98		      .byte.b	$90+(.LUM1/256)
     15  39fe		       28		      .byte.b	$20+(.LUM2/256)
     16  39ff		       69		      .byte.b	$60+(.LUM3/256)
     17  3a00
     18  3a00
     19  3a00
     20  3a00
     21  3a00
     22  3a00				   .LUM1      SET	.LUM1 + .STEP1
     23  3a00				   .LUM2      SET	.LUM2 + .STEP2
     24  3a00				   .LUM3      SET	.LUM3 + .STEP3
     13  3a00					      REPEND
     14  3a00		       98		      .byte.b	$90+(.LUM1/256)
     15  3a01		       28		      .byte.b	$20+(.LUM2/256)
     16  3a02		       69		      .byte.b	$60+(.LUM3/256)
     17  3a03
     18  3a03
     19  3a03
     20  3a03
     21  3a03
     22  3a03				   .LUM1      SET	.LUM1 + .STEP1
     23  3a03				   .LUM2      SET	.LUM2 + .STEP2
     24  3a03				   .LUM3      SET	.LUM3 + .STEP3
     13  3a03					      REPEND
     14  3a03		       98		      .byte.b	$90+(.LUM1/256)
     15  3a04		       28		      .byte.b	$20+(.LUM2/256)
     16  3a05		       69		      .byte.b	$60+(.LUM3/256)
     17  3a06
     18  3a06
     19  3a06
     20  3a06
     21  3a06
     22  3a06				   .LUM1      SET	.LUM1 + .STEP1
     23  3a06				   .LUM2      SET	.LUM2 + .STEP2
     24  3a06				   .LUM3      SET	.LUM3 + .STEP3
     13  3a06					      REPEND
     14  3a06		       98		      .byte.b	$90+(.LUM1/256)
     15  3a07		       28		      .byte.b	$20+(.LUM2/256)
     16  3a08		       69		      .byte.b	$60+(.LUM3/256)
     17  3a09
     18  3a09
     19  3a09
     20  3a09
     21  3a09
     22  3a09				   .LUM1      SET	.LUM1 + .STEP1
     23  3a09				   .LUM2      SET	.LUM2 + .STEP2
     24  3a09				   .LUM3      SET	.LUM3 + .STEP3
     13  3a09					      REPEND
     14  3a09		       98		      .byte.b	$90+(.LUM1/256)
     15  3a0a		       28		      .byte.b	$20+(.LUM2/256)
     16  3a0b		       69		      .byte.b	$60+(.LUM3/256)
     17  3a0c
     18  3a0c
     19  3a0c
     20  3a0c
     21  3a0c
     22  3a0c				   .LUM1      SET	.LUM1 + .STEP1
     23  3a0c				   .LUM2      SET	.LUM2 + .STEP2
     24  3a0c				   .LUM3      SET	.LUM3 + .STEP3
     13  3a0c					      REPEND
     14  3a0c		       98		      .byte.b	$90+(.LUM1/256)
     15  3a0d		       28		      .byte.b	$20+(.LUM2/256)
     16  3a0e		       69		      .byte.b	$60+(.LUM3/256)
     17  3a0f
     18  3a0f
     19  3a0f
     20  3a0f
     21  3a0f
     22  3a0f				   .LUM1      SET	.LUM1 + .STEP1
     23  3a0f				   .LUM2      SET	.LUM2 + .STEP2
     24  3a0f				   .LUM3      SET	.LUM3 + .STEP3
     13  3a0f					      REPEND
     14  3a0f		       99		      .byte.b	$90+(.LUM1/256)
     15  3a10		       27		      .byte.b	$20+(.LUM2/256)
     16  3a11		       68		      .byte.b	$60+(.LUM3/256)
     17  3a12
     18  3a12
     19  3a12
     20  3a12
     21  3a12
     22  3a12				   .LUM1      SET	.LUM1 + .STEP1
     23  3a12				   .LUM2      SET	.LUM2 + .STEP2
     24  3a12				   .LUM3      SET	.LUM3 + .STEP3
     13  3a12					      REPEND
     14  3a12		       99		      .byte.b	$90+(.LUM1/256)
     15  3a13		       27		      .byte.b	$20+(.LUM2/256)
     16  3a14		       68		      .byte.b	$60+(.LUM3/256)
     17  3a15
     18  3a15
     19  3a15
     20  3a15
     21  3a15
     22  3a15				   .LUM1      SET	.LUM1 + .STEP1
     23  3a15				   .LUM2      SET	.LUM2 + .STEP2
     24  3a15				   .LUM3      SET	.LUM3 + .STEP3
     13  3a15					      REPEND
     14  3a15		       99		      .byte.b	$90+(.LUM1/256)
     15  3a16		       27		      .byte.b	$20+(.LUM2/256)
     16  3a17		       68		      .byte.b	$60+(.LUM3/256)
     17  3a18
     18  3a18
     19  3a18
     20  3a18
     21  3a18
     22  3a18				   .LUM1      SET	.LUM1 + .STEP1
     23  3a18				   .LUM2      SET	.LUM2 + .STEP2
     24  3a18				   .LUM3      SET	.LUM3 + .STEP3
     13  3a18					      REPEND
     14  3a18		       99		      .byte.b	$90+(.LUM1/256)
     15  3a19		       27		      .byte.b	$20+(.LUM2/256)
     16  3a1a		       68		      .byte.b	$60+(.LUM3/256)
     17  3a1b
     18  3a1b
     19  3a1b
     20  3a1b
     21  3a1b
     22  3a1b				   .LUM1      SET	.LUM1 + .STEP1
     23  3a1b				   .LUM2      SET	.LUM2 + .STEP2
     24  3a1b				   .LUM3      SET	.LUM3 + .STEP3
     13  3a1b					      REPEND
     14  3a1b		       99		      .byte.b	$90+(.LUM1/256)
     15  3a1c		       27		      .byte.b	$20+(.LUM2/256)
     16  3a1d		       68		      .byte.b	$60+(.LUM3/256)
     17  3a1e
     18  3a1e
     19  3a1e
     20  3a1e
     21  3a1e
     22  3a1e				   .LUM1      SET	.LUM1 + .STEP1
     23  3a1e				   .LUM2      SET	.LUM2 + .STEP2
     24  3a1e				   .LUM3      SET	.LUM3 + .STEP3
     13  3a1e					      REPEND
     14  3a1e		       99		      .byte.b	$90+(.LUM1/256)
     15  3a1f		       27		      .byte.b	$20+(.LUM2/256)
     16  3a20		       68		      .byte.b	$60+(.LUM3/256)
     17  3a21
     18  3a21
     19  3a21
     20  3a21
     21  3a21
     22  3a21				   .LUM1      SET	.LUM1 + .STEP1
     23  3a21				   .LUM2      SET	.LUM2 + .STEP2
     24  3a21				   .LUM3      SET	.LUM3 + .STEP3
     13  3a21					      REPEND
     14  3a21		       99		      .byte.b	$90+(.LUM1/256)
     15  3a22		       27		      .byte.b	$20+(.LUM2/256)
     16  3a23		       68		      .byte.b	$60+(.LUM3/256)
     17  3a24
     18  3a24
     19  3a24
     20  3a24
     21  3a24
     22  3a24				   .LUM1      SET	.LUM1 + .STEP1
     23  3a24				   .LUM2      SET	.LUM2 + .STEP2
     24  3a24				   .LUM3      SET	.LUM3 + .STEP3
     13  3a24					      REPEND
     14  3a24		       99		      .byte.b	$90+(.LUM1/256)
     15  3a25		       27		      .byte.b	$20+(.LUM2/256)
     16  3a26		       68		      .byte.b	$60+(.LUM3/256)
     17  3a27
     18  3a27
     19  3a27
     20  3a27
     21  3a27
     22  3a27				   .LUM1      SET	.LUM1 + .STEP1
     23  3a27				   .LUM2      SET	.LUM2 + .STEP2
     24  3a27				   .LUM3      SET	.LUM3 + .STEP3
     13  3a27					      REPEND
     14  3a27		       99		      .byte.b	$90+(.LUM1/256)
     15  3a28		       27		      .byte.b	$20+(.LUM2/256)
     16  3a29		       68		      .byte.b	$60+(.LUM3/256)
     17  3a2a
     18  3a2a
     19  3a2a
     20  3a2a
     21  3a2a
     22  3a2a				   .LUM1      SET	.LUM1 + .STEP1
     23  3a2a				   .LUM2      SET	.LUM2 + .STEP2
     24  3a2a				   .LUM3      SET	.LUM3 + .STEP3
     13  3a2a					      REPEND
     14  3a2a		       99		      .byte.b	$90+(.LUM1/256)
     15  3a2b		       27		      .byte.b	$20+(.LUM2/256)
     16  3a2c		       68		      .byte.b	$60+(.LUM3/256)
     17  3a2d
     18  3a2d
     19  3a2d
     20  3a2d
     21  3a2d
     22  3a2d				   .LUM1      SET	.LUM1 + .STEP1
     23  3a2d				   .LUM2      SET	.LUM2 + .STEP2
     24  3a2d				   .LUM3      SET	.LUM3 + .STEP3
     13  3a2d					      REPEND
     14  3a2d		       99		      .byte.b	$90+(.LUM1/256)
     15  3a2e		       27		      .byte.b	$20+(.LUM2/256)
     16  3a2f		       68		      .byte.b	$60+(.LUM3/256)
     17  3a30
     18  3a30
     19  3a30
     20  3a30
     21  3a30
     22  3a30				   .LUM1      SET	.LUM1 + .STEP1
     23  3a30				   .LUM2      SET	.LUM2 + .STEP2
     24  3a30				   .LUM3      SET	.LUM3 + .STEP3
     13  3a30					      REPEND
     14  3a30		       99		      .byte.b	$90+(.LUM1/256)
     15  3a31		       27		      .byte.b	$20+(.LUM2/256)
     16  3a32		       68		      .byte.b	$60+(.LUM3/256)
     17  3a33
     18  3a33
     19  3a33
     20  3a33
     21  3a33
     22  3a33				   .LUM1      SET	.LUM1 + .STEP1
     23  3a33				   .LUM2      SET	.LUM2 + .STEP2
     24  3a33				   .LUM3      SET	.LUM3 + .STEP3
     13  3a33					      REPEND
     14  3a33		       9a		      .byte.b	$90+(.LUM1/256)
     15  3a34		       27		      .byte.b	$20+(.LUM2/256)
     16  3a35		       68		      .byte.b	$60+(.LUM3/256)
     17  3a36
     18  3a36
     19  3a36
     20  3a36
     21  3a36
     22  3a36				   .LUM1      SET	.LUM1 + .STEP1
     23  3a36				   .LUM2      SET	.LUM2 + .STEP2
     24  3a36				   .LUM3      SET	.LUM3 + .STEP3
     13  3a36					      REPEND
     14  3a36		       9a		      .byte.b	$90+(.LUM1/256)
     15  3a37		       27		      .byte.b	$20+(.LUM2/256)
     16  3a38		       68		      .byte.b	$60+(.LUM3/256)
     17  3a39
     18  3a39
     19  3a39
     20  3a39
     21  3a39
     22  3a39				   .LUM1      SET	.LUM1 + .STEP1
     23  3a39				   .LUM2      SET	.LUM2 + .STEP2
     24  3a39				   .LUM3      SET	.LUM3 + .STEP3
     13  3a39					      REPEND
     14  3a39		       9a		      .byte.b	$90+(.LUM1/256)
     15  3a3a		       27		      .byte.b	$20+(.LUM2/256)
     16  3a3b		       68		      .byte.b	$60+(.LUM3/256)
     17  3a3c
     18  3a3c
     19  3a3c
     20  3a3c
     21  3a3c
     22  3a3c				   .LUM1      SET	.LUM1 + .STEP1
     23  3a3c				   .LUM2      SET	.LUM2 + .STEP2
     24  3a3c				   .LUM3      SET	.LUM3 + .STEP3
     13  3a3c					      REPEND
     14  3a3c		       9a		      .byte.b	$90+(.LUM1/256)
     15  3a3d		       27		      .byte.b	$20+(.LUM2/256)
     16  3a3e		       68		      .byte.b	$60+(.LUM3/256)
     17  3a3f
     18  3a3f
     19  3a3f
     20  3a3f
     21  3a3f
     22  3a3f				   .LUM1      SET	.LUM1 + .STEP1
     23  3a3f				   .LUM2      SET	.LUM2 + .STEP2
     24  3a3f				   .LUM3      SET	.LUM3 + .STEP3
     13  3a3f					      REPEND
     14  3a3f		       9a		      .byte.b	$90+(.LUM1/256)
     15  3a40		       27		      .byte.b	$20+(.LUM2/256)
     16  3a41		       68		      .byte.b	$60+(.LUM3/256)
     17  3a42
     18  3a42
     19  3a42
     20  3a42
     21  3a42
     22  3a42				   .LUM1      SET	.LUM1 + .STEP1
     23  3a42				   .LUM2      SET	.LUM2 + .STEP2
     24  3a42				   .LUM3      SET	.LUM3 + .STEP3
     13  3a42					      REPEND
     14  3a42		       9a		      .byte.b	$90+(.LUM1/256)
     15  3a43		       27		      .byte.b	$20+(.LUM2/256)
     16  3a44		       68		      .byte.b	$60+(.LUM3/256)
     17  3a45
     18  3a45
     19  3a45
     20  3a45
     21  3a45
     22  3a45				   .LUM1      SET	.LUM1 + .STEP1
     23  3a45				   .LUM2      SET	.LUM2 + .STEP2
     24  3a45				   .LUM3      SET	.LUM3 + .STEP3
     13  3a45					      REPEND
     14  3a45		       9a		      .byte.b	$90+(.LUM1/256)
     15  3a46		       26		      .byte.b	$20+(.LUM2/256)
     16  3a47		       68		      .byte.b	$60+(.LUM3/256)
     17  3a48
     18  3a48
     19  3a48
     20  3a48
     21  3a48
     22  3a48				   .LUM1      SET	.LUM1 + .STEP1
     23  3a48				   .LUM2      SET	.LUM2 + .STEP2
     24  3a48				   .LUM3      SET	.LUM3 + .STEP3
     13  3a48					      REPEND
     14  3a48		       9a		      .byte.b	$90+(.LUM1/256)
     15  3a49		       26		      .byte.b	$20+(.LUM2/256)
     16  3a4a		       68		      .byte.b	$60+(.LUM3/256)
     17  3a4b
     18  3a4b
     19  3a4b
     20  3a4b
     21  3a4b
     22  3a4b				   .LUM1      SET	.LUM1 + .STEP1
     23  3a4b				   .LUM2      SET	.LUM2 + .STEP2
     24  3a4b				   .LUM3      SET	.LUM3 + .STEP3
     13  3a4b					      REPEND
     14  3a4b		       9a		      .byte.b	$90+(.LUM1/256)
     15  3a4c		       26		      .byte.b	$20+(.LUM2/256)
     16  3a4d		       68		      .byte.b	$60+(.LUM3/256)
     17  3a4e
     18  3a4e
     19  3a4e
     20  3a4e
     21  3a4e
     22  3a4e				   .LUM1      SET	.LUM1 + .STEP1
     23  3a4e				   .LUM2      SET	.LUM2 + .STEP2
     24  3a4e				   .LUM3      SET	.LUM3 + .STEP3
     13  3a4e					      REPEND
     14  3a4e		       9a		      .byte.b	$90+(.LUM1/256)
     15  3a4f		       26		      .byte.b	$20+(.LUM2/256)
     16  3a50		       68		      .byte.b	$60+(.LUM3/256)
     17  3a51
     18  3a51
     19  3a51
     20  3a51
     21  3a51
     22  3a51				   .LUM1      SET	.LUM1 + .STEP1
     23  3a51				   .LUM2      SET	.LUM2 + .STEP2
     24  3a51				   .LUM3      SET	.LUM3 + .STEP3
     13  3a51					      REPEND
     14  3a51		       9a		      .byte.b	$90+(.LUM1/256)
     15  3a52		       26		      .byte.b	$20+(.LUM2/256)
     16  3a53		       68		      .byte.b	$60+(.LUM3/256)
     17  3a54
     18  3a54
     19  3a54
     20  3a54
     21  3a54
     22  3a54				   .LUM1      SET	.LUM1 + .STEP1
     23  3a54				   .LUM2      SET	.LUM2 + .STEP2
     24  3a54				   .LUM3      SET	.LUM3 + .STEP3
     13  3a54					      REPEND
     14  3a54		       9a		      .byte.b	$90+(.LUM1/256)
     15  3a55		       26		      .byte.b	$20+(.LUM2/256)
     16  3a56		       68		      .byte.b	$60+(.LUM3/256)
     17  3a57
     18  3a57
     19  3a57
     20  3a57
     21  3a57
     22  3a57				   .LUM1      SET	.LUM1 + .STEP1
     23  3a57				   .LUM2      SET	.LUM2 + .STEP2
     24  3a57				   .LUM3      SET	.LUM3 + .STEP3
     13  3a57					      REPEND
     14  3a57		       9b		      .byte.b	$90+(.LUM1/256)
     15  3a58		       26		      .byte.b	$20+(.LUM2/256)
     16  3a59		       68		      .byte.b	$60+(.LUM3/256)
     17  3a5a
     18  3a5a
     19  3a5a
     20  3a5a
     21  3a5a
     22  3a5a				   .LUM1      SET	.LUM1 + .STEP1
     23  3a5a				   .LUM2      SET	.LUM2 + .STEP2
     24  3a5a				   .LUM3      SET	.LUM3 + .STEP3
     13  3a5a					      REPEND
     14  3a5a		       9b		      .byte.b	$90+(.LUM1/256)
     15  3a5b		       26		      .byte.b	$20+(.LUM2/256)
     16  3a5c		       68		      .byte.b	$60+(.LUM3/256)
     17  3a5d
     18  3a5d
     19  3a5d
     20  3a5d
     21  3a5d
     22  3a5d				   .LUM1      SET	.LUM1 + .STEP1
     23  3a5d				   .LUM2      SET	.LUM2 + .STEP2
     24  3a5d				   .LUM3      SET	.LUM3 + .STEP3
     13  3a5d					      REPEND
     14  3a5d		       9b		      .byte.b	$90+(.LUM1/256)
     15  3a5e		       26		      .byte.b	$20+(.LUM2/256)
     16  3a5f		       68		      .byte.b	$60+(.LUM3/256)
     17  3a60
     18  3a60
     19  3a60
     20  3a60
     21  3a60
     22  3a60				   .LUM1      SET	.LUM1 + .STEP1
     23  3a60				   .LUM2      SET	.LUM2 + .STEP2
     24  3a60				   .LUM3      SET	.LUM3 + .STEP3
     13  3a60					      REPEND
     14  3a60		       9b		      .byte.b	$90+(.LUM1/256)
     15  3a61		       26		      .byte.b	$20+(.LUM2/256)
     16  3a62		       68		      .byte.b	$60+(.LUM3/256)
     17  3a63
     18  3a63
     19  3a63
     20  3a63
     21  3a63
     22  3a63				   .LUM1      SET	.LUM1 + .STEP1
     23  3a63				   .LUM2      SET	.LUM2 + .STEP2
     24  3a63				   .LUM3      SET	.LUM3 + .STEP3
     13  3a63					      REPEND
     14  3a63		       9b		      .byte.b	$90+(.LUM1/256)
     15  3a64		       26		      .byte.b	$20+(.LUM2/256)
     16  3a65		       68		      .byte.b	$60+(.LUM3/256)
     17  3a66
     18  3a66
     19  3a66
     20  3a66
     21  3a66
     22  3a66				   .LUM1      SET	.LUM1 + .STEP1
     23  3a66				   .LUM2      SET	.LUM2 + .STEP2
     24  3a66				   .LUM3      SET	.LUM3 + .STEP3
     13  3a66					      REPEND
     14  3a66		       9b		      .byte.b	$90+(.LUM1/256)
     15  3a67		       26		      .byte.b	$20+(.LUM2/256)
     16  3a68		       68		      .byte.b	$60+(.LUM3/256)
     17  3a69
     18  3a69
     19  3a69
     20  3a69
     21  3a69
     22  3a69				   .LUM1      SET	.LUM1 + .STEP1
     23  3a69				   .LUM2      SET	.LUM2 + .STEP2
     24  3a69				   .LUM3      SET	.LUM3 + .STEP3
     13  3a69					      REPEND
     14  3a69		       9b		      .byte.b	$90+(.LUM1/256)
     15  3a6a		       26		      .byte.b	$20+(.LUM2/256)
     16  3a6b		       68		      .byte.b	$60+(.LUM3/256)
     17  3a6c
     18  3a6c
     19  3a6c
     20  3a6c
     21  3a6c
     22  3a6c				   .LUM1      SET	.LUM1 + .STEP1
     23  3a6c				   .LUM2      SET	.LUM2 + .STEP2
     24  3a6c				   .LUM3      SET	.LUM3 + .STEP3
     13  3a6c					      REPEND
     14  3a6c		       9b		      .byte.b	$90+(.LUM1/256)
     15  3a6d		       26		      .byte.b	$20+(.LUM2/256)
     16  3a6e		       68		      .byte.b	$60+(.LUM3/256)
     17  3a6f
     18  3a6f
     19  3a6f
     20  3a6f
     21  3a6f
     22  3a6f				   .LUM1      SET	.LUM1 + .STEP1
     23  3a6f				   .LUM2      SET	.LUM2 + .STEP2
     24  3a6f				   .LUM3      SET	.LUM3 + .STEP3
     13  3a6f					      REPEND
     14  3a6f		       9b		      .byte.b	$90+(.LUM1/256)
     15  3a70		       26		      .byte.b	$20+(.LUM2/256)
     16  3a71		       68		      .byte.b	$60+(.LUM3/256)
     17  3a72
     18  3a72
     19  3a72
     20  3a72
     21  3a72
     22  3a72				   .LUM1      SET	.LUM1 + .STEP1
     23  3a72				   .LUM2      SET	.LUM2 + .STEP2
     24  3a72				   .LUM3      SET	.LUM3 + .STEP3
     13  3a72					      REPEND
     14  3a72		       9b		      .byte.b	$90+(.LUM1/256)
     15  3a73		       26		      .byte.b	$20+(.LUM2/256)
     16  3a74		       68		      .byte.b	$60+(.LUM3/256)
     17  3a75
     18  3a75
     19  3a75
     20  3a75
     21  3a75
     22  3a75				   .LUM1      SET	.LUM1 + .STEP1
     23  3a75				   .LUM2      SET	.LUM2 + .STEP2
     24  3a75				   .LUM3      SET	.LUM3 + .STEP3
     13  3a75					      REPEND
     14  3a75		       9b		      .byte.b	$90+(.LUM1/256)
     15  3a76		       26		      .byte.b	$20+(.LUM2/256)
     16  3a77		       68		      .byte.b	$60+(.LUM3/256)
     17  3a78
     18  3a78
     19  3a78
     20  3a78
     21  3a78
     22  3a78				   .LUM1      SET	.LUM1 + .STEP1
     23  3a78				   .LUM2      SET	.LUM2 + .STEP2
     24  3a78				   .LUM3      SET	.LUM3 + .STEP3
     25  3a78					      REPEND
    256  3a78
------- FILE titleData.asm LEVEL 3 PASS 3
      0  3a78					      include	"titleData.asm"
      0  3a78					      OPTIONAL_PAGEBREAK	"0", 72
     10  3a78					      LIST	ON
      2  3a78				   COL_0
      3  3a78		       f0		      .byte.b	240	;R (71)
      4  3a79		       00		      .byte.b	0	;G
      5  3a7a		       00		      .byte.b	0	;B
      6  3a7b		       00		      .byte.b	0	;R (70)
      7  3a7c		       f0		      .byte.b	240	;G
      8  3a7d		       00		      .byte.b	0	;B
      9  3a7e		       00		      .byte.b	0	;R (69)
     10  3a7f		       f0		      .byte.b	240	;G
     11  3a80		       00		      .byte.b	0	;B
     12  3a81		       10		      .byte.b	16	;R (68)
     13  3a82		       f0		      .byte.b	240	;G
     14  3a83		       10		      .byte.b	16	;B
     15  3a84		       30		      .byte.b	48	;R (67)
     16  3a85		       d0		      .byte.b	208	;G
     17  3a86		       10		      .byte.b	16	;B
     18  3a87		       70		      .byte.b	112	;R (66)
     19  3a88		       90		      .byte.b	144	;G
     20  3a89		       10		      .byte.b	16	;B
     21  3a8a		       90		      .byte.b	144	;R (65)
     22  3a8b		       70		      .byte.b	112	;G
     23  3a8c		       10		      .byte.b	16	;B
     24  3a8d		       10		      .byte.b	16	;R (64)
     25  3a8e		       f0		      .byte.b	240	;G
     26  3a8f		       10		      .byte.b	16	;B
     27  3a90		       10		      .byte.b	16	;R (63)
     28  3a91		       f0		      .byte.b	240	;G
     29  3a92		       10		      .byte.b	16	;B
     30  3a93		       10		      .byte.b	16	;R (62)
     31  3a94		       f0		      .byte.b	240	;G
     32  3a95		       10		      .byte.b	16	;B
     33  3a96		       10		      .byte.b	16	;R (61)
     34  3a97		       f0		      .byte.b	240	;G
     35  3a98		       10		      .byte.b	16	;B
     36  3a99		       f0		      .byte.b	240	;R (60)
     37  3a9a		       10		      .byte.b	16	;G
     38  3a9b		       10		      .byte.b	16	;B
     39  3a9c		       f0		      .byte.b	240	;R (59)
     40  3a9d		       10		      .byte.b	16	;G
     41  3a9e		       10		      .byte.b	16	;B
     42  3a9f		       f0		      .byte.b	240	;R (58)
     43  3aa0		       10		      .byte.b	16	;G
     44  3aa1		       10		      .byte.b	16	;B
     45  3aa2		       90		      .byte.b	144	;R (57)
     46  3aa3		       70		      .byte.b	112	;G
     47  3aa4		       30		      .byte.b	48	;B
     48  3aa5		       50		      .byte.b	80	;R (56)
     49  3aa6		       f0		      .byte.b	240	;G
     50  3aa7		       30		      .byte.b	48	;B
     51  3aa8		       f0		      .byte.b	240	;R (55)
     52  3aa9		       90		      .byte.b	144	;G
     53  3aaa		       10		      .byte.b	16	;B
     54  3aab		       f0		      .byte.b	240	;R (54)
     55  3aac		       d0		      .byte.b	208	;G
     56  3aad		       10		      .byte.b	16	;B
     57  3aae		       d0		      .byte.b	208	;R (53)
     58  3aaf		       70		      .byte.b	112	;G
     59  3ab0		       30		      .byte.b	48	;B
     60  3ab1		       d0		      .byte.b	208	;R (52)
     61  3ab2		       30		      .byte.b	48	;G
     62  3ab3		       30		      .byte.b	48	;B
     63  3ab4		       50		      .byte.b	80	;R (51)
     64  3ab5		       b0		      .byte.b	176	;G
     65  3ab6		       b0		      .byte.b	176	;B
     66  3ab7		       70		      .byte.b	112	;R (50)
     67  3ab8		       10		      .byte.b	16	;G
     68  3ab9		       10		      .byte.b	16	;B
     69  3aba		       70		      .byte.b	112	;R (49)
     70  3abb		       90		      .byte.b	144	;G
     71  3abc		       90		      .byte.b	144	;B
     72  3abd		       30		      .byte.b	48	;R (48)
     73  3abe		       50		      .byte.b	80	;G
     74  3abf		       50		      .byte.b	80	;B
     75  3ac0		       70		      .byte.b	112	;R (47)
     76  3ac1		       90		      .byte.b	144	;G
     77  3ac2		       90		      .byte.b	144	;B
     78  3ac3		       f0		      .byte.b	240	;R (46)
     79  3ac4		       d0		      .byte.b	208	;G
     80  3ac5		       d0		      .byte.b	208	;B
     81  3ac6		       b0		      .byte.b	176	;R (45)
     82  3ac7		       b0		      .byte.b	176	;G
     83  3ac8		       f0		      .byte.b	240	;B
     84  3ac9		       30		      .byte.b	48	;R (44)
     85  3aca		       10		      .byte.b	16	;G
     86  3acb		       f0		      .byte.b	240	;B
     87  3acc		       30		      .byte.b	48	;R (43)
     88  3acd		       10		      .byte.b	16	;G
     89  3ace		       f0		      .byte.b	240	;B
     90  3acf		       30		      .byte.b	48	;R (42)
     91  3ad0		       10		      .byte.b	16	;G
     92  3ad1		       f0		      .byte.b	240	;B
     93  3ad2		       f0		      .byte.b	240	;R (41)
     94  3ad3		       10		      .byte.b	16	;G
     95  3ad4		       f0		      .byte.b	240	;B
     96  3ad5		       10		      .byte.b	16	;R (40)
     97  3ad6		       10		      .byte.b	16	;G
     98  3ad7		       f0		      .byte.b	240	;B
     99  3ad8		       10		      .byte.b	16	;R (39)
    100  3ad9		       10		      .byte.b	16	;G
    101  3ada		       f0		      .byte.b	240	;B
    102  3adb		       00		      .byte.b	0	;R (38)
    103  3adc		       00		      .byte.b	0	;G
    104  3add		       f0		      .byte.b	240	;B
    105  3ade		       00		      .byte.b	0	;R (37)
    106  3adf		       00		      .byte.b	0	;G
    107  3ae0		       f0		      .byte.b	240	;B
    108  3ae1		       f0		      .byte.b	240	;R (36)
    109  3ae2		       00		      .byte.b	0	;G
    110  3ae3		       f0		      .byte.b	240	;B
    111  3ae4		       20		      .byte.b	32	;R (35)
    112  3ae5		       00		      .byte.b	0	;G
    113  3ae6		       f0		      .byte.b	240	;B
    114  3ae7		       20		      .byte.b	32	;R (34)
    115  3ae8		       00		      .byte.b	0	;G
    116  3ae9		       f0		      .byte.b	240	;B
    117  3aea		       20		      .byte.b	32	;R (33)
    118  3aeb		       00		      .byte.b	0	;G
    119  3aec		       f0		      .byte.b	240	;B
    120  3aed		       20		      .byte.b	32	;R (32)
    121  3aee		       00		      .byte.b	0	;G
    122  3aef		       f0		      .byte.b	240	;B
    123  3af0		       f0		      .byte.b	240	;R (31)
    124  3af1		       00		      .byte.b	0	;G
    125  3af2		       f0		      .byte.b	240	;B
    126  3af3		       00		      .byte.b	0	;R (30)
    127  3af4		       00		      .byte.b	0	;G
    128  3af5		       f0		      .byte.b	240	;B
    129  3af6		       00		      .byte.b	0	;R (29)
    130  3af7		       00		      .byte.b	0	;G
    131  3af8		       f0		      .byte.b	240	;B
    132  3af9		       00		      .byte.b	0	;R (28)
    133  3afa		       00		      .byte.b	0	;G
    134  3afb		       f0		      .byte.b	240	;B
    135  3afc		       00		      .byte.b	0	;R (27)
    136  3afd		       00		      .byte.b	0	;G
    137  3afe		       f0		      .byte.b	240	;B
    138  3aff		       f0		      .byte.b	240	;R (26)
    139  3b00		       00		      .byte.b	0	;G
    140  3b01		       f0		      .byte.b	240	;B
    141  3b02		       20		      .byte.b	32	;R (25)
    142  3b03		       00		      .byte.b	0	;G
    143  3b04		       f0		      .byte.b	240	;B
    144  3b05		       20		      .byte.b	32	;R (24)
    145  3b06		       00		      .byte.b	0	;G
    146  3b07		       f0		      .byte.b	240	;B
    147  3b08		       20		      .byte.b	32	;R (23)
    148  3b09		       00		      .byte.b	0	;G
    149  3b0a		       f0		      .byte.b	240	;B
    150  3b0b		       20		      .byte.b	32	;R (22)
    151  3b0c		       00		      .byte.b	0	;G
    152  3b0d		       f0		      .byte.b	240	;B
    153  3b0e		       f0		      .byte.b	240	;R (21)
    154  3b0f		       00		      .byte.b	0	;G
    155  3b10		       f0		      .byte.b	240	;B
    156  3b11		       00		      .byte.b	0	;R (20)
    157  3b12		       00		      .byte.b	0	;G
    158  3b13		       f0		      .byte.b	240	;B
    159  3b14		       00		      .byte.b	0	;R (19)
    160  3b15		       00		      .byte.b	0	;G
    161  3b16		       f0		      .byte.b	240	;B
    162  3b17		       00		      .byte.b	0	;R (18)
    163  3b18		       00		      .byte.b	0	;G
    164  3b19		       f0		      .byte.b	240	;B
    165  3b1a		       00		      .byte.b	0	;R (17)
    166  3b1b		       00		      .byte.b	0	;G
    167  3b1c		       f0		      .byte.b	240	;B
    168  3b1d		       f0		      .byte.b	240	;R (16)
    169  3b1e		       00		      .byte.b	0	;G
    170  3b1f		       f0		      .byte.b	240	;B
    171  3b20		       f0		      .byte.b	240	;R (15)
    172  3b21		       00		      .byte.b	0	;G
    173  3b22		       00		      .byte.b	0	;B
    174  3b23		       00		      .byte.b	0	;R (14)
    175  3b24		       00		      .byte.b	0	;G
    176  3b25		       00		      .byte.b	0	;B
    177  3b26		       00		      .byte.b	0	;R (13)
    178  3b27		       00		      .byte.b	0	;G
    179  3b28		       00		      .byte.b	0	;B
    180  3b29		       00		      .byte.b	0	;R (12)
    181  3b2a		       00		      .byte.b	0	;G
    182  3b2b		       00		      .byte.b	0	;B
    183  3b2c		       00		      .byte.b	0	;R (11)
    184  3b2d		       00		      .byte.b	0	;G
    185  3b2e		       00		      .byte.b	0	;B
    186  3b2f		       00		      .byte.b	0	;R (10)
    187  3b30		       00		      .byte.b	0	;G
    188  3b31		       00		      .byte.b	0	;B
    189  3b32		       00		      .byte.b	0	;R (9)
    190  3b33		       00		      .byte.b	0	;G
    191  3b34		       00		      .byte.b	0	;B
    192  3b35		       00		      .byte.b	0	;R (8)
    193  3b36		       00		      .byte.b	0	;G
    194  3b37		       00		      .byte.b	0	;B
    195  3b38		       00		      .byte.b	0	;R (7)
    196  3b39		       00		      .byte.b	0	;G
    197  3b3a		       00		      .byte.b	0	;B
    198  3b3b		       00		      .byte.b	0	;R (6)
    199  3b3c		       00		      .byte.b	0	;G
    200  3b3d		       00		      .byte.b	0	;B
    201  3b3e		       00		      .byte.b	0	;R (5)
    202  3b3f		       00		      .byte.b	0	;G
    203  3b40		       00		      .byte.b	0	;B
    204  3b41		       00		      .byte.b	0	;R (4)
    205  3b42		       00		      .byte.b	0	;G
    206  3b43		       00		      .byte.b	0	;B
    207  3b44		       00		      .byte.b	0	;R (3)
    208  3b45		       00		      .byte.b	0	;G
    209  3b46		       00		      .byte.b	0	;B
    210  3b47		       00		      .byte.b	0	;R (2)
    211  3b48		       00		      .byte.b	0	;G
    212  3b49		       00		      .byte.b	0	;B
    213  3b4a		       00		      .byte.b	0	;R (1)
    214  3b4b		       00		      .byte.b	0	;G
    215  3b4c		       00		      .byte.b	0	;B
    216  3b4d		       00		      .byte.b	0	;R (0)
    217  3b4e		       00		      .byte.b	0	;G
    218  3b4f		       00		      .byte.b	0	;B
      0  3b50					      OPTIONAL_PAGEBREAK	"1", 72
     10  3b50					      LIST	ON
    220  3b50				   COL_1
    221  3b50		       e0		      .byte.b	224	;R (71)
    222  3b51		       1f		      .byte.b	31	;G
    223  3b52		       00		      .byte.b	0	;B
    224  3b53		       1f		      .byte.b	31	;R (70)
    225  3b54		       e0		      .byte.b	224	;G
    226  3b55		       00		      .byte.b	0	;B
    227  3b56		       0f		      .byte.b	15	;R (69)
    228  3b57		       f0		      .byte.b	240	;G
    229  3b58		       00		      .byte.b	0	;B
    230  3b59		       07		      .byte.b	7	;R (68)
    231  3b5a		       20		      .byte.b	32	;G
    232  3b5b		       00		      .byte.b	0	;B
    233  3b5c		       03		      .byte.b	3	;R (67)
    234  3b5d		       b4		      .byte.b	180	;G
    235  3b5e		       00		      .byte.b	0	;B
    236  3b5f		       49		      .byte.b	73	;R (66)
    237  3b60		       fe		      .byte.b	254	;G
    238  3b61		       48		      .byte.b	72	;B
    239  3b62		       fe		      .byte.b	254	;R (65)
    240  3b63		       d9		      .byte.b	217	;G
    241  3b64		       d8		      .byte.b	216	;B
    242  3b65		       ff		      .byte.b	255	;R (64)
    243  3b66		       f0		      .byte.b	240	;G
    244  3b67		       b0		      .byte.b	176	;B
    245  3b68		       ef		      .byte.b	239	;R (63)
    246  3b69		       f0		      .byte.b	240	;G
    247  3b6a		       e0		      .byte.b	224	;B
    248  3b6b		       ff		      .byte.b	255	;R (62)
    249  3b6c		       e0		      .byte.b	224	;G
    250  3b6d		       e0		      .byte.b	224	;B
    251  3b6e		       ff		      .byte.b	255	;R (61)
    252  3b6f		       e0		      .byte.b	224	;G
    253  3b70		       e0		      .byte.b	224	;B
    254  3b71		       20		      .byte.b	32	;R (60)
    255  3b72		       3f		      .byte.b	63	;G
    256  3b73		       60		      .byte.b	96	;B
    257  3b74		       f0		      .byte.b	240	;R (59)
    258  3b75		       ef		      .byte.b	239	;G
    259  3b76		       00		      .byte.b	0	;B
    260  3b77		       f8		      .byte.b	248	;R (58)
    261  3b78		       e7		      .byte.b	231	;G
    262  3b79		       00		      .byte.b	0	;B
    263  3b7a		       fc		      .byte.b	252	;R (57)
    264  3b7b		       e3		      .byte.b	227	;G
    265  3b7c		       00		      .byte.b	0	;B
    266  3b7d		       7e		      .byte.b	126	;R (56)
    267  3b7e		       e1		      .byte.b	225	;G
    268  3b7f		       00		      .byte.b	0	;B
    269  3b80		       e1		      .byte.b	225	;R (55)
    270  3b81		       fe		      .byte.b	254	;G
    271  3b82		       00		      .byte.b	0	;B
    272  3b83		       e0		      .byte.b	224	;R (54)
    273  3b84		       ff		      .byte.b	255	;G
    274  3b85		       00		      .byte.b	0	;B
    275  3b86		       c0		      .byte.b	192	;R (53)
    276  3b87		       ff		      .byte.b	255	;G
    277  3b88		       00		      .byte.b	0	;B
    278  3b89		       00		      .byte.b	0	;R (52)
    279  3b8a		       ff		      .byte.b	255	;G
    280  3b8b		       c0		      .byte.b	192	;B
    281  3b8c		       20		      .byte.b	32	;R (51)
    282  3b8d		       c4		      .byte.b	196	;G
    283  3b8e		       c0		      .byte.b	192	;B
    284  3b8f		       2d		      .byte.b	45	;R (50)
    285  3b90		       c0		      .byte.b	192	;G
    286  3b91		       c0		      .byte.b	192	;B
    287  3b92		       12		      .byte.b	18	;R (49)
    288  3b93		       80		      .byte.b	128	;G
    289  3b94		       c0		      .byte.b	192	;B
    290  3b95		       3f		      .byte.b	63	;R (48)
    291  3b96		       ad		      .byte.b	173	;G
    292  3b97		       c0		      .byte.b	192	;B
    293  3b98		       3f		      .byte.b	63	;R (47)
    294  3b99		       29		      .byte.b	41	;G
    295  3b9a		       c0		      .byte.b	192	;B
    296  3b9b		       ff		      .byte.b	255	;R (46)
    297  3b9c		       e1		      .byte.b	225	;G
    298  3b9d		       c0		      .byte.b	192	;B
    299  3b9e		       ff		      .byte.b	255	;R (45)
    300  3b9f		       e1		      .byte.b	225	;G
    301  3ba0		       80		      .byte.b	128	;B
    302  3ba1		       77		      .byte.b	119	;R (44)
    303  3ba2		       63		      .byte.b	99	;G
    304  3ba3		       88		      .byte.b	136	;B
    305  3ba4		       7b		      .byte.b	123	;R (43)
    306  3ba5		       63		      .byte.b	99	;G
    307  3ba6		       80		      .byte.b	128	;B
    308  3ba7		       67		      .byte.b	103	;R (42)
    309  3ba8		       67		      .byte.b	103	;G
    310  3ba9		       9c		      .byte.b	156	;B
    311  3baa		       ff		      .byte.b	255	;R (41)
    312  3bab		       7f		      .byte.b	127	;G
    313  3bac		       9c		      .byte.b	156	;B
    314  3bad		       7f		      .byte.b	127	;R (40)
    315  3bae		       7f		      .byte.b	127	;G
    316  3baf		       9c		      .byte.b	156	;B
    317  3bb0		       7f		      .byte.b	127	;R (39)
    318  3bb1		       7b		      .byte.b	123	;G
    319  3bb2		       9f		      .byte.b	159	;B
    320  3bb3		       7f		      .byte.b	127	;R (38)
    321  3bb4		       7f		      .byte.b	127	;G
    322  3bb5		       9f		      .byte.b	159	;B
    323  3bb6		       7f		      .byte.b	127	;R (37)
    324  3bb7		       7f		      .byte.b	127	;G
    325  3bb8		       bf		      .byte.b	191	;B
    326  3bb9		       ff		      .byte.b	255	;R (36)
    327  3bba		       7f		      .byte.b	127	;G
    328  3bbb		       bc		      .byte.b	188	;B
    329  3bbc		       7b		      .byte.b	123	;R (35)
    330  3bbd		       7f		      .byte.b	127	;G
    331  3bbe		       bc		      .byte.b	188	;B
    332  3bbf		       71		      .byte.b	113	;R (34)
    333  3bc0		       7f		      .byte.b	127	;G
    334  3bc1		       ae		      .byte.b	174	;B
    335  3bc2		       73		      .byte.b	115	;R (33)
    336  3bc3		       7f		      .byte.b	127	;G
    337  3bc4		       ac		      .byte.b	172	;B
    338  3bc5		       51		      .byte.b	81	;R (32)
    339  3bc6		       77		      .byte.b	119	;G
    340  3bc7		       a6		      .byte.b	166	;B
    341  3bc8		       d0		      .byte.b	208	;R (31)
    342  3bc9		       75		      .byte.b	117	;G
    343  3bca		       a5		      .byte.b	165	;B
    344  3bcb		       71		      .byte.b	113	;R (30)
    345  3bcc		       73		      .byte.b	115	;G
    346  3bcd		       82		      .byte.b	130	;B
    347  3bce		       7f		      .byte.b	127	;R (29)
    348  3bcf		       7f		      .byte.b	127	;G
    349  3bd0		       8f		      .byte.b	143	;B
    350  3bd1		       7f		      .byte.b	127	;R (28)
    351  3bd2		       7f		      .byte.b	127	;G
    352  3bd3		       8e		      .byte.b	142	;B
    353  3bd4		       7f		      .byte.b	127	;R (27)
    354  3bd5		       7f		      .byte.b	127	;G
    355  3bd6		       80		      .byte.b	128	;B
    356  3bd7		       ff		      .byte.b	255	;R (26)
    357  3bd8		       7f		      .byte.b	127	;G
    358  3bd9		       80		      .byte.b	128	;B
    359  3bda		       7f		      .byte.b	127	;R (25)
    360  3bdb		       7f		      .byte.b	127	;G
    361  3bdc		       80		      .byte.b	128	;B
    362  3bdd		       7f		      .byte.b	127	;R (24)
    363  3bde		       7f		      .byte.b	127	;G
    364  3bdf		       80		      .byte.b	128	;B
    365  3be0		       7f		      .byte.b	127	;R (23)
    366  3be1		       00		      .byte.b	0	;G
    367  3be2		       ff		      .byte.b	255	;B
    368  3be3		       7f		      .byte.b	127	;R (22)
    369  3be4		       2a		      .byte.b	42	;G
    370  3be5		       d5		      .byte.b	213	;B
    371  3be6		       ff		      .byte.b	255	;R (21)
    372  3be7		       55		      .byte.b	85	;G
    373  3be8		       aa		      .byte.b	170	;B
    374  3be9		       3f		      .byte.b	63	;R (20)
    375  3bea		       2a		      .byte.b	42	;G
    376  3beb		       d5		      .byte.b	213	;B
    377  3bec		       1f		      .byte.b	31	;R (19)
    378  3bed		       1f		      .byte.b	31	;G
    379  3bee		       e0		      .byte.b	224	;B
    380  3bef		       2f		      .byte.b	47	;R (18)
    381  3bf0		       0f		      .byte.b	15	;G
    382  3bf1		       f0		      .byte.b	240	;B
    383  3bf2		       27		      .byte.b	39	;R (17)
    384  3bf3		       07		      .byte.b	7	;G
    385  3bf4		       f8		      .byte.b	248	;B
    386  3bf5		       fb		      .byte.b	251	;R (16)
    387  3bf6		       03		      .byte.b	3	;G
    388  3bf7		       fc		      .byte.b	252	;B
    389  3bf8		       ff		      .byte.b	255	;R (15)
    390  3bf9		       01		      .byte.b	1	;G
    391  3bfa		       00		      .byte.b	0	;B
    392  3bfb		       01		      .byte.b	1	;R (14)
    393  3bfc		       01		      .byte.b	1	;G
    394  3bfd		       00		      .byte.b	0	;B
    395  3bfe		       00		      .byte.b	0	;R (13)
    396  3bff		       00		      .byte.b	0	;G
    397  3c00		       00		      .byte.b	0	;B
    398  3c01		       00		      .byte.b	0	;R (12)
    399  3c02		       00		      .byte.b	0	;G
    400  3c03		       00		      .byte.b	0	;B
    401  3c04		       00		      .byte.b	0	;R (11)
    402  3c05		       00		      .byte.b	0	;G
    403  3c06		       00		      .byte.b	0	;B
    404  3c07		       00		      .byte.b	0	;R (10)
    405  3c08		       00		      .byte.b	0	;G
    406  3c09		       00		      .byte.b	0	;B
    407  3c0a		       00		      .byte.b	0	;R (9)
    408  3c0b		       00		      .byte.b	0	;G
    409  3c0c		       00		      .byte.b	0	;B
    410  3c0d		       00		      .byte.b	0	;R (8)
    411  3c0e		       00		      .byte.b	0	;G
    412  3c0f		       00		      .byte.b	0	;B
    413  3c10		       00		      .byte.b	0	;R (7)
    414  3c11		       00		      .byte.b	0	;G
    415  3c12		       00		      .byte.b	0	;B
    416  3c13		       00		      .byte.b	0	;R (6)
    417  3c14		       00		      .byte.b	0	;G
    418  3c15		       00		      .byte.b	0	;B
    419  3c16		       00		      .byte.b	0	;R (5)
    420  3c17		       00		      .byte.b	0	;G
    421  3c18		       00		      .byte.b	0	;B
    422  3c19		       00		      .byte.b	0	;R (4)
    423  3c1a		       00		      .byte.b	0	;G
    424  3c1b		       00		      .byte.b	0	;B
    425  3c1c		       00		      .byte.b	0	;R (3)
    426  3c1d		       00		      .byte.b	0	;G
    427  3c1e		       00		      .byte.b	0	;B
    428  3c1f		       00		      .byte.b	0	;R (2)
    429  3c20		       00		      .byte.b	0	;G
    430  3c21		       00		      .byte.b	0	;B
    431  3c22		       00		      .byte.b	0	;R (1)
    432  3c23		       00		      .byte.b	0	;G
    433  3c24		       00		      .byte.b	0	;B
    434  3c25		       00		      .byte.b	0	;R (0)
    435  3c26		       00		      .byte.b	0	;G
    436  3c27		       00		      .byte.b	0	;B
      0  3c28					      OPTIONAL_PAGEBREAK	"2", 72
     10  3c28					      LIST	ON
    438  3c28				   COL_2
    439  3c28		       f8		      .byte.b	248	;R (71)
    440  3c29		       07		      .byte.b	7	;G
    441  3c2a		       00		      .byte.b	0	;B
    442  3c2b		       07		      .byte.b	7	;R (70)
    443  3c2c		       f8		      .byte.b	248	;G
    444  3c2d		       00		      .byte.b	0	;B
    445  3c2e		       0f		      .byte.b	15	;R (69)
    446  3c2f		       f0		      .byte.b	240	;G
    447  3c30		       00		      .byte.b	0	;B
    448  3c31		       1f		      .byte.b	31	;R (68)
    449  3c32		       e0		      .byte.b	224	;G
    450  3c33		       00		      .byte.b	0	;B
    451  3c34		       3f		      .byte.b	63	;R (67)
    452  3c35		       c0		      .byte.b	192	;G
    453  3c36		       00		      .byte.b	0	;B
    454  3c37		       7f		      .byte.b	127	;R (66)
    455  3c38		       80		      .byte.b	128	;G
    456  3c39		       00		      .byte.b	0	;B
    457  3c3a		       80		      .byte.b	128	;R (65)
    458  3c3b		       7f		      .byte.b	127	;G
    459  3c3c		       00		      .byte.b	0	;B
    460  3c3d		       00		      .byte.b	0	;R (64)
    461  3c3e		       ff		      .byte.b	255	;G
    462  3c3f		       00		      .byte.b	0	;B
    463  3c40		       01		      .byte.b	1	;R (63)
    464  3c41		       fe		      .byte.b	254	;G
    465  3c42		       00		      .byte.b	0	;B
    466  3c43		       03		      .byte.b	3	;R (62)
    467  3c44		       fc		      .byte.b	252	;G
    468  3c45		       00		      .byte.b	0	;B
    469  3c46		       07		      .byte.b	7	;R (61)
    470  3c47		       f8		      .byte.b	248	;G
    471  3c48		       00		      .byte.b	0	;B
    472  3c49		       f8		      .byte.b	248	;R (60)
    473  3c4a		       07		      .byte.b	7	;G
    474  3c4b		       00		      .byte.b	0	;B
    475  3c4c		       f0		      .byte.b	240	;R (59)
    476  3c4d		       0f		      .byte.b	15	;G
    477  3c4e		       00		      .byte.b	0	;B
    478  3c4f		       e0		      .byte.b	224	;R (58)
    479  3c50		       1f		      .byte.b	31	;G
    480  3c51		       00		      .byte.b	0	;B
    481  3c52		       c0		      .byte.b	192	;R (57)
    482  3c53		       3f		      .byte.b	63	;G
    483  3c54		       00		      .byte.b	0	;B
    484  3c55		       80		      .byte.b	128	;R (56)
    485  3c56		       7f		      .byte.b	127	;G
    486  3c57		       00		      .byte.b	0	;B
    487  3c58		       7f		      .byte.b	127	;R (55)
    488  3c59		       80		      .byte.b	128	;G
    489  3c5a		       00		      .byte.b	0	;B
    490  3c5b		       ff		      .byte.b	255	;R (54)
    491  3c5c		       00		      .byte.b	0	;G
    492  3c5d		       00		      .byte.b	0	;B
    493  3c5e		       ee		      .byte.b	238	;R (53)
    494  3c5f		       11		      .byte.b	17	;G
    495  3c60		       10		      .byte.b	16	;B
    496  3c61		       b4		      .byte.b	180	;R (52)
    497  3c62		       0b		      .byte.b	11	;G
    498  3c63		       48		      .byte.b	72	;B
    499  3c64		       b0		      .byte.b	176	;R (51)
    500  3c65		       0f		      .byte.b	15	;G
    501  3c66		       48		      .byte.b	72	;B
    502  3c67		       76		      .byte.b	118	;R (50)
    503  3c68		       08		      .byte.b	8	;G
    504  3c69		       89		      .byte.b	137	;B
    505  3c6a		       00		      .byte.b	0	;R (49)
    506  3c6b		       b8		      .byte.b	184	;G
    507  3c6c		       ff		      .byte.b	255	;B
    508  3c6d		       03		      .byte.b	3	;R (48)
    509  3c6e		       fb		      .byte.b	251	;G
    510  3c6f		       fc		      .byte.b	252	;B
    511  3c70		       03		      .byte.b	3	;R (47)
    512  3c71		       cf		      .byte.b	207	;G
    513  3c72		       fc		      .byte.b	252	;B
    514  3c73		       03		      .byte.b	3	;R (46)
    515  3c74		       c7		      .byte.b	199	;G
    516  3c75		       fc		      .byte.b	252	;B
    517  3c76		       03		      .byte.b	3	;R (45)
    518  3c77		       ef		      .byte.b	239	;G
    519  3c78		       fc		      .byte.b	252	;B
    520  3c79		       63		      .byte.b	99	;R (44)
    521  3c7a		       1b		      .byte.b	27	;G
    522  3c7b		       18		      .byte.b	24	;B
    523  3c7c		       f1		      .byte.b	241	;R (43)
    524  3c7d		       0f		      .byte.b	15	;G
    525  3c7e		       0e		      .byte.b	14	;B
    526  3c7f		       f0		      .byte.b	240	;R (42)
    527  3c80		       0a		      .byte.b	10	;G
    528  3c81		       0a		      .byte.b	10	;B
    529  3c82		       f1		      .byte.b	241	;R (41)
    530  3c83		       0f		      .byte.b	15	;G
    531  3c84		       0e		      .byte.b	14	;B
    532  3c85		       eb		      .byte.b	235	;R (40)
    533  3c86		       17		      .byte.b	23	;G
    534  3c87		       14		      .byte.b	20	;B
    535  3c88		       eb		      .byte.b	235	;R (39)
    536  3c89		       17		      .byte.b	23	;G
    537  3c8a		       14		      .byte.b	20	;B
    538  3c8b		       ff		      .byte.b	255	;R (38)
    539  3c8c		       06		      .byte.b	6	;G
    540  3c8d		       01		      .byte.b	1	;B
    541  3c8e		       ff		      .byte.b	255	;R (37)
    542  3c8f		       07		      .byte.b	7	;G
    543  3c90		       01		      .byte.b	1	;B
    544  3c91		       ff		      .byte.b	255	;R (36)
    545  3c92		       07		      .byte.b	7	;G
    546  3c93		       01		      .byte.b	1	;B
    547  3c94		       fe		      .byte.b	254	;R (35)
    548  3c95		       07		      .byte.b	7	;G
    549  3c96		       01		      .byte.b	1	;B
    550  3c97		       fe		      .byte.b	254	;R (34)
    551  3c98		       07		      .byte.b	7	;G
    552  3c99		       01		      .byte.b	1	;B
    553  3c9a		       ff		      .byte.b	255	;R (33)
    554  3c9b		       07		      .byte.b	7	;G
    555  3c9c		       00		      .byte.b	0	;B
    556  3c9d		       ff		      .byte.b	255	;R (32)
    557  3c9e		       07		      .byte.b	7	;G
    558  3c9f		       00		      .byte.b	0	;B
    559  3ca0		       ff		      .byte.b	255	;R (31)
    560  3ca1		       07		      .byte.b	7	;G
    561  3ca2		       00		      .byte.b	0	;B
    562  3ca3		       ff		      .byte.b	255	;R (30)
    563  3ca4		       07		      .byte.b	7	;G
    564  3ca5		       00		      .byte.b	0	;B
    565  3ca6		       ff		      .byte.b	255	;R (29)
    566  3ca7		       07		      .byte.b	7	;G
    567  3ca8		       00		      .byte.b	0	;B
    568  3ca9		       ff		      .byte.b	255	;R (28)
    569  3caa		       07		      .byte.b	7	;G
    570  3cab		       01		      .byte.b	1	;B
    571  3cac		       ff		      .byte.b	255	;R (27)
    572  3cad		       07		      .byte.b	7	;G
    573  3cae		       00		      .byte.b	0	;B
    574  3caf		       ff		      .byte.b	255	;R (26)
    575  3cb0		       07		      .byte.b	7	;G
    576  3cb1		       00		      .byte.b	0	;B
    577  3cb2		       ff		      .byte.b	255	;R (25)
    578  3cb3		       07		      .byte.b	7	;G
    579  3cb4		       00		      .byte.b	0	;B
    580  3cb5		       ff		      .byte.b	255	;R (24)
    581  3cb6		       07		      .byte.b	7	;G
    582  3cb7		       00		      .byte.b	0	;B
    583  3cb8		       ff		      .byte.b	255	;R (23)
    584  3cb9		       00		      .byte.b	0	;G
    585  3cba		       07		      .byte.b	7	;B
    586  3cbb		       9f		      .byte.b	159	;R (22)
    587  3cbc		       05		      .byte.b	5	;G
    588  3cbd		       02		      .byte.b	2	;B
    589  3cbe		       5f		      .byte.b	95	;R (21)
    590  3cbf		       02		      .byte.b	2	;G
    591  3cc0		       0d		      .byte.b	13	;B
    592  3cc1		       5f		      .byte.b	95	;R (20)
    593  3cc2		       21		      .byte.b	33	;G
    594  3cc3		       16		      .byte.b	22	;B
    595  3cc4		       5f		      .byte.b	95	;R (19)
    596  3cc5		       af		      .byte.b	175	;G
    597  3cc6		       00		      .byte.b	0	;B
    598  3cc7		       43		      .byte.b	67	;R (18)
    599  3cc8		       bb		      .byte.b	187	;G
    600  3cc9		       04		      .byte.b	4	;B
    601  3cca		       03		      .byte.b	3	;R (17)
    602  3ccb		       fb		      .byte.b	251	;G
    603  3ccc		       04		      .byte.b	4	;B
    604  3ccd		       97		      .byte.b	151	;R (16)
    605  3cce		       7b		      .byte.b	123	;G
    606  3ccf		       10		      .byte.b	16	;B
    607  3cd0		       fb		      .byte.b	251	;R (15)
    608  3cd1		       ff		      .byte.b	255	;G
    609  3cd2		       1e		      .byte.b	30	;B
    610  3cd3		       ff		      .byte.b	255	;R (14)
    611  3cd4		       fb		      .byte.b	251	;G
    612  3cd5		       1e		      .byte.b	30	;B
    613  3cd6		       ff		      .byte.b	255	;R (13)
    614  3cd7		       db		      .byte.b	219	;G
    615  3cd8		       3e		      .byte.b	62	;B
    616  3cd9		       7e		      .byte.b	126	;R (12)
    617  3cda		       5e		      .byte.b	94	;G
    618  3cdb		       7e		      .byte.b	126	;B
    619  3cdc		       5c		      .byte.b	92	;R (11)
    620  3cdd		       5c		      .byte.b	92	;G
    621  3cde		       5c		      .byte.b	92	;B
    622  3cdf		       0c		      .byte.b	12	;R (10)
    623  3ce0		       5c		      .byte.b	92	;G
    624  3ce1		       5c		      .byte.b	92	;B
    625  3ce2		       00		      .byte.b	0	;R (9)
    626  3ce3		       38		      .byte.b	56	;G
    627  3ce4		       38		      .byte.b	56	;B
    628  3ce5		       00		      .byte.b	0	;R (8)
    629  3ce6		       78		      .byte.b	120	;G
    630  3ce7		       18		      .byte.b	24	;B
    631  3ce8		       00		      .byte.b	0	;R (7)
    632  3ce9		       30		      .byte.b	48	;G
    633  3cea		       38		      .byte.b	56	;B
    634  3ceb		       00		      .byte.b	0	;R (6)
    635  3cec		       50		      .byte.b	80	;G
    636  3ced		       58		      .byte.b	88	;B
    637  3cee		       00		      .byte.b	0	;R (5)
    638  3cef		       20		      .byte.b	32	;G
    639  3cf0		       38		      .byte.b	56	;B
    640  3cf1		       78		      .byte.b	120	;R (4)
    641  3cf2		       78		      .byte.b	120	;G
    642  3cf3		       78		      .byte.b	120	;B
    643  3cf4		       b0		      .byte.b	176	;R (3)
    644  3cf5		       b0		      .byte.b	176	;G
    645  3cf6		       b0		      .byte.b	176	;B
    646  3cf7		       00		      .byte.b	0	;R (2)
    647  3cf8		       00		      .byte.b	0	;G
    648  3cf9		       00		      .byte.b	0	;B
    649  3cfa		       00		      .byte.b	0	;R (1)
    650  3cfb		       00		      .byte.b	0	;G
    651  3cfc		       00		      .byte.b	0	;B
    652  3cfd		       00		      .byte.b	0	;R (0)
    653  3cfe		       00		      .byte.b	0	;G
    654  3cff		       00		      .byte.b	0	;B
      0  3d00					      OPTIONAL_PAGEBREAK	"3", 72
     10  3d00					      LIST	ON
    656  3d00				   COL_3
    657  3d00		       70		      .byte.b	112	;R (71)
    658  3d01		       80		      .byte.b	128	;G
    659  3d02		       00		      .byte.b	0	;B
    660  3d03		       80		      .byte.b	128	;R (70)
    661  3d04		       70		      .byte.b	112	;G
    662  3d05		       00		      .byte.b	0	;B
    663  3d06		       00		      .byte.b	0	;R (69)
    664  3d07		       f0		      .byte.b	240	;G
    665  3d08		       00		      .byte.b	0	;B
    666  3d09		       00		      .byte.b	0	;R (68)
    667  3d0a		       f0		      .byte.b	240	;G
    668  3d0b		       00		      .byte.b	0	;B
    669  3d0c		       00		      .byte.b	0	;R (67)
    670  3d0d		       f0		      .byte.b	240	;G
    671  3d0e		       00		      .byte.b	0	;B
    672  3d0f		       00		      .byte.b	0	;R (66)
    673  3d10		       30		      .byte.b	48	;G
    674  3d11		       00		      .byte.b	0	;B
    675  3d12		       f0		      .byte.b	240	;R (65)
    676  3d13		       00		      .byte.b	0	;G
    677  3d14		       c0		      .byte.b	192	;B
    678  3d15		       f0		      .byte.b	240	;R (64)
    679  3d16		       00		      .byte.b	0	;G
    680  3d17		       c0		      .byte.b	192	;B
    681  3d18		       e0		      .byte.b	224	;R (63)
    682  3d19		       10		      .byte.b	16	;G
    683  3d1a		       c0		      .byte.b	192	;B
    684  3d1b		       c0		      .byte.b	192	;R (62)
    685  3d1c		       30		      .byte.b	48	;G
    686  3d1d		       c0		      .byte.b	192	;B
    687  3d1e		       c0		      .byte.b	192	;R (61)
    688  3d1f		       30		      .byte.b	48	;G
    689  3d20		       c0		      .byte.b	192	;B
    690  3d21		       f0		      .byte.b	240	;R (60)
    691  3d22		       00		      .byte.b	0	;G
    692  3d23		       c0		      .byte.b	192	;B
    693  3d24		       f0		      .byte.b	240	;R (59)
    694  3d25		       00		      .byte.b	0	;G
    695  3d26		       c0		      .byte.b	192	;B
    696  3d27		       f0		      .byte.b	240	;R (58)
    697  3d28		       00		      .byte.b	0	;G
    698  3d29		       c0		      .byte.b	192	;B
    699  3d2a		       f0		      .byte.b	240	;R (57)
    700  3d2b		       00		      .byte.b	0	;G
    701  3d2c		       c0		      .byte.b	192	;B
    702  3d2d		       f0		      .byte.b	240	;R (56)
    703  3d2e		       00		      .byte.b	0	;G
    704  3d2f		       c0		      .byte.b	192	;B
    705  3d30		       c0		      .byte.b	192	;R (55)
    706  3d31		       30		      .byte.b	48	;G
    707  3d32		       c0		      .byte.b	192	;B
    708  3d33		       c0		      .byte.b	192	;R (54)
    709  3d34		       30		      .byte.b	48	;G
    710  3d35		       c0		      .byte.b	192	;B
    711  3d36		       d0		      .byte.b	208	;R (53)
    712  3d37		       20		      .byte.b	32	;G
    713  3d38		       c0		      .byte.b	192	;B
    714  3d39		       d0		      .byte.b	208	;R (52)
    715  3d3a		       20		      .byte.b	32	;G
    716  3d3b		       e0		      .byte.b	224	;B
    717  3d3c		       d0		      .byte.b	208	;R (51)
    718  3d3d		       20		      .byte.b	32	;G
    719  3d3e		       e0		      .byte.b	224	;B
    720  3d3f		       e0		      .byte.b	224	;R (50)
    721  3d40		       10		      .byte.b	16	;G
    722  3d41		       d0		      .byte.b	208	;B
    723  3d42		       e0		      .byte.b	224	;R (49)
    724  3d43		       10		      .byte.b	16	;G
    725  3d44		       d0		      .byte.b	208	;B
    726  3d45		       e0		      .byte.b	224	;R (48)
    727  3d46		       10		      .byte.b	16	;G
    728  3d47		       d0		      .byte.b	208	;B
    729  3d48		       f0		      .byte.b	240	;R (47)
    730  3d49		       00		      .byte.b	0	;G
    731  3d4a		       c0		      .byte.b	192	;B
    732  3d4b		       f0		      .byte.b	240	;R (46)
    733  3d4c		       00		      .byte.b	0	;G
    734  3d4d		       c0		      .byte.b	192	;B
    735  3d4e		       e0		      .byte.b	224	;R (45)
    736  3d4f		       10		      .byte.b	16	;G
    737  3d50		       d0		      .byte.b	208	;B
    738  3d51		       e0		      .byte.b	224	;R (44)
    739  3d52		       10		      .byte.b	16	;G
    740  3d53		       d0		      .byte.b	208	;B
    741  3d54		       c0		      .byte.b	192	;R (43)
    742  3d55		       20		      .byte.b	32	;G
    743  3d56		       e0		      .byte.b	224	;B
    744  3d57		       d0		      .byte.b	208	;R (42)
    745  3d58		       20		      .byte.b	32	;G
    746  3d59		       e0		      .byte.b	224	;B
    747  3d5a		       d0		      .byte.b	208	;R (41)
    748  3d5b		       20		      .byte.b	32	;G
    749  3d5c		       e0		      .byte.b	224	;B
    750  3d5d		       f0		      .byte.b	240	;R (40)
    751  3d5e		       00		      .byte.b	0	;G
    752  3d5f		       c0		      .byte.b	192	;B
    753  3d60		       f0		      .byte.b	240	;R (39)
    754  3d61		       00		      .byte.b	0	;G
    755  3d62		       c0		      .byte.b	192	;B
    756  3d63		       f0		      .byte.b	240	;R (38)
    757  3d64		       00		      .byte.b	0	;G
    758  3d65		       c0		      .byte.b	192	;B
    759  3d66		       30		      .byte.b	48	;R (37)
    760  3d67		       00		      .byte.b	0	;G
    761  3d68		       c0		      .byte.b	192	;B
    762  3d69		       70		      .byte.b	112	;R (36)
    763  3d6a		       00		      .byte.b	0	;G
    764  3d6b		       c0		      .byte.b	192	;B
    765  3d6c		       b0		      .byte.b	176	;R (35)
    766  3d6d		       00		      .byte.b	0	;G
    767  3d6e		       c0		      .byte.b	192	;B
    768  3d6f		       f0		      .byte.b	240	;R (34)
    769  3d70		       80		      .byte.b	128	;G
    770  3d71		       40		      .byte.b	64	;B
    771  3d72		       f0		      .byte.b	240	;R (33)
    772  3d73		       80		      .byte.b	128	;G
    773  3d74		       00		      .byte.b	0	;B
    774  3d75		       70		      .byte.b	112	;R (32)
    775  3d76		       00		      .byte.b	0	;G
    776  3d77		       80		      .byte.b	128	;B
    777  3d78		       70		      .byte.b	112	;R (31)
    778  3d79		       00		      .byte.b	0	;G
    779  3d7a		       80		      .byte.b	128	;B
    780  3d7b		       70		      .byte.b	112	;R (30)
    781  3d7c		       00		      .byte.b	0	;G
    782  3d7d		       80		      .byte.b	128	;B
    783  3d7e		       70		      .byte.b	112	;R (29)
    784  3d7f		       00		      .byte.b	0	;G
    785  3d80		       80		      .byte.b	128	;B
    786  3d81		       70		      .byte.b	112	;R (28)
    787  3d82		       00		      .byte.b	0	;G
    788  3d83		       80		      .byte.b	128	;B
    789  3d84		       70		      .byte.b	112	;R (27)
    790  3d85		       00		      .byte.b	0	;G
    791  3d86		       80		      .byte.b	128	;B
    792  3d87		       f0		      .byte.b	240	;R (26)
    793  3d88		       00		      .byte.b	0	;G
    794  3d89		       80		      .byte.b	128	;B
    795  3d8a		       70		      .byte.b	112	;R (25)
    796  3d8b		       00		      .byte.b	0	;G
    797  3d8c		       80		      .byte.b	128	;B
    798  3d8d		       70		      .byte.b	112	;R (24)
    799  3d8e		       00		      .byte.b	0	;G
    800  3d8f		       80		      .byte.b	128	;B
    801  3d90		       70		      .byte.b	112	;R (23)
    802  3d91		       00		      .byte.b	0	;G
    803  3d92		       80		      .byte.b	128	;B
    804  3d93		       70		      .byte.b	112	;R (22)
    805  3d94		       00		      .byte.b	0	;G
    806  3d95		       80		      .byte.b	128	;B
    807  3d96		       e0		      .byte.b	224	;R (21)
    808  3d97		       00		      .byte.b	0	;G
    809  3d98		       80		      .byte.b	128	;B
    810  3d99		       70		      .byte.b	112	;R (20)
    811  3d9a		       00		      .byte.b	0	;G
    812  3d9b		       80		      .byte.b	128	;B
    813  3d9c		       70		      .byte.b	112	;R (19)
    814  3d9d		       00		      .byte.b	0	;G
    815  3d9e		       80		      .byte.b	128	;B
    816  3d9f		       70		      .byte.b	112	;R (18)
    817  3da0		       00		      .byte.b	0	;G
    818  3da1		       80		      .byte.b	128	;B
    819  3da2		       70		      .byte.b	112	;R (17)
    820  3da3		       00		      .byte.b	0	;G
    821  3da4		       80		      .byte.b	128	;B
    822  3da5		       f0		      .byte.b	240	;R (16)
    823  3da6		       00		      .byte.b	0	;G
    824  3da7		       90		      .byte.b	144	;B
    825  3da8		       f0		      .byte.b	240	;R (15)
    826  3da9		       00		      .byte.b	0	;G
    827  3daa		       20		      .byte.b	32	;B
    828  3dab		       70		      .byte.b	112	;R (14)
    829  3dac		       10		      .byte.b	16	;G
    830  3dad		       40		      .byte.b	64	;B
    831  3dae		       70		      .byte.b	112	;R (13)
    832  3daf		       30		      .byte.b	48	;G
    833  3db0		       00		      .byte.b	0	;B
    834  3db1		       00		      .byte.b	0	;R (12)
    835  3db2		       00		      .byte.b	0	;G
    836  3db3		       00		      .byte.b	0	;B
    837  3db4		       00		      .byte.b	0	;R (11)
    838  3db5		       00		      .byte.b	0	;G
    839  3db6		       00		      .byte.b	0	;B
    840  3db7		       00		      .byte.b	0	;R (10)
    841  3db8		       00		      .byte.b	0	;G
    842  3db9		       00		      .byte.b	0	;B
    843  3dba		       00		      .byte.b	0	;R (9)
    844  3dbb		       00		      .byte.b	0	;G
    845  3dbc		       00		      .byte.b	0	;B
    846  3dbd		       00		      .byte.b	0	;R (8)
    847  3dbe		       20		      .byte.b	32	;G
    848  3dbf		       00		      .byte.b	0	;B
    849  3dc0		       00		      .byte.b	0	;R (7)
    850  3dc1		       00		      .byte.b	0	;G
    851  3dc2		       00		      .byte.b	0	;B
    852  3dc3		       00		      .byte.b	0	;R (6)
    853  3dc4		       50		      .byte.b	80	;G
    854  3dc5		       00		      .byte.b	0	;B
    855  3dc6		       00		      .byte.b	0	;R (5)
    856  3dc7		       20		      .byte.b	32	;G
    857  3dc8		       00		      .byte.b	0	;B
    858  3dc9		       00		      .byte.b	0	;R (4)
    859  3dca		       c0		      .byte.b	192	;G
    860  3dcb		       00		      .byte.b	0	;B
    861  3dcc		       00		      .byte.b	0	;R (3)
    862  3dcd		       40		      .byte.b	64	;G
    863  3dce		       00		      .byte.b	0	;B
    864  3dcf		       00		      .byte.b	0	;R (2)
    865  3dd0		       20		      .byte.b	32	;G
    866  3dd1		       00		      .byte.b	0	;B
    867  3dd2		       00		      .byte.b	0	;R (1)
    868  3dd3		       90		      .byte.b	144	;G
    869  3dd4		       00		      .byte.b	0	;B
    870  3dd5		       00		      .byte.b	0	;R (0)
    871  3dd6		       00		      .byte.b	0	;G
    872  3dd7		       00		      .byte.b	0	;B
      0  3dd8					      OPTIONAL_PAGEBREAK	"4", 72
 PAGE BREAK INSERTED FOR  4
 REQUESTED SIZE =  $48
 WASTED SPACE =  $28
 PAGEBREAK LOCATION =  $f600
     10  3e00					      LIST	ON
    874  3e00				   COL_4
    875  3e00		       01		      .byte.b	1	;R (71)
    876  3e01		       fe		      .byte.b	254	;G
    877  3e02		       00		      .byte.b	0	;B
    878  3e03		       fe		      .byte.b	254	;R (70)
    879  3e04		       01		      .byte.b	1	;G
    880  3e05		       00		      .byte.b	0	;B
    881  3e06		       ff		      .byte.b	255	;R (69)
    882  3e07		       00		      .byte.b	0	;G
    883  3e08		       00		      .byte.b	0	;B
    884  3e09		       7f		      .byte.b	127	;R (68)
    885  3e0a		       80		      .byte.b	128	;G
    886  3e0b		       00		      .byte.b	0	;B
    887  3e0c		       3f		      .byte.b	63	;R (67)
    888  3e0d		       c0		      .byte.b	192	;G
    889  3e0e		       00		      .byte.b	0	;B
    890  3e0f		       00		      .byte.b	0	;R (66)
    891  3e10		       00		      .byte.b	0	;G
    892  3e11		       00		      .byte.b	0	;B
    893  3e12		       ff		      .byte.b	255	;R (65)
    894  3e13		       00		      .byte.b	0	;G
    895  3e14		       ff		      .byte.b	255	;B
    896  3e15		       9f		      .byte.b	159	;R (64)
    897  3e16		       00		      .byte.b	0	;G
    898  3e17		       9f		      .byte.b	159	;B
    899  3e18		       df		      .byte.b	223	;R (63)
    900  3e19		       00		      .byte.b	0	;G
    901  3e1a		       df		      .byte.b	223	;B
    902  3e1b		       01		      .byte.b	1	;R (62)
    903  3e1c		       00		      .byte.b	0	;G
    904  3e1d		       21		      .byte.b	33	;B
    905  3e1e		       7f		      .byte.b	127	;R (61)
    906  3e1f		       2c		      .byte.b	44	;G
    907  3e20		       2d		      .byte.b	45	;B
    908  3e21		       7f		      .byte.b	127	;R (60)
    909  3e22		       28		      .byte.b	40	;G
    910  3e23		       29		      .byte.b	41	;B
    911  3e24		       77		      .byte.b	119	;R (59)
    912  3e25		       38		      .byte.b	56	;G
    913  3e26		       31		      .byte.b	49	;B
    914  3e27		       7f		      .byte.b	127	;R (58)
    915  3e28		       38		      .byte.b	56	;G
    916  3e29		       39		      .byte.b	57	;B
    917  3e2a		       7f		      .byte.b	127	;R (57)
    918  3e2b		       18		      .byte.b	24	;G
    919  3e2c		       19		      .byte.b	25	;B
    920  3e2d		       7f		      .byte.b	127	;R (56)
    921  3e2e		       1c		      .byte.b	28	;G
    922  3e2f		       1d		      .byte.b	29	;B
    923  3e30		       6f		      .byte.b	111	;R (55)
    924  3e31		       00		      .byte.b	0	;G
    925  3e32		       0d		      .byte.b	13	;B
    926  3e33		       63		      .byte.b	99	;R (54)
    927  3e34		       1c		      .byte.b	28	;G
    928  3e35		       01		      .byte.b	1	;B
    929  3e36		       63		      .byte.b	99	;R (53)
    930  3e37		       1c		      .byte.b	28	;G
    931  3e38		       01		      .byte.b	1	;B
    932  3e39		       63		      .byte.b	99	;R (52)
    933  3e3a		       14		      .byte.b	20	;G
    934  3e3b		       09		      .byte.b	9	;B
    935  3e3c		       43		      .byte.b	67	;R (51)
    936  3e3d		       34		      .byte.b	52	;G
    937  3e3e		       09		      .byte.b	9	;B
    938  3e3f		       01		      .byte.b	1	;R (50)
    939  3e40		       7e		      .byte.b	126	;G
    940  3e41		       01		      .byte.b	1	;B
    941  3e42		       00		      .byte.b	0	;R (49)
    942  3e43		       ff		      .byte.b	255	;G
    943  3e44		       81		      .byte.b	129	;B
    944  3e45		       26		      .byte.b	38	;R (48)
    945  3e46		       d9		      .byte.b	217	;G
    946  3e47		       81		      .byte.b	129	;B
    947  3e48		       66		      .byte.b	102	;R (47)
    948  3e49		       99		      .byte.b	153	;G
    949  3e4a		       99		      .byte.b	153	;B
    950  3e4b		       47		      .byte.b	71	;R (46)
    951  3e4c		       08		      .byte.b	8	;G
    952  3e4d		       39		      .byte.b	57	;B
    953  3e4e		       47		      .byte.b	71	;R (45)
    954  3e4f		       10		      .byte.b	16	;G
    955  3e50		       19		      .byte.b	25	;B
    956  3e51		       47		      .byte.b	71	;R (44)
    957  3e52		       30		      .byte.b	48	;G
    958  3e53		       39		      .byte.b	57	;B
    959  3e54		       03		      .byte.b	3	;R (43)
    960  3e55		       50		      .byte.b	80	;G
    961  3e56		       5d		      .byte.b	93	;B
    962  3e57		       43		      .byte.b	67	;R (42)
    963  3e58		       20		      .byte.b	32	;G
    964  3e59		       3d		      .byte.b	61	;B
    965  3e5a		       7f		      .byte.b	127	;R (41)
    966  3e5b		       78		      .byte.b	120	;G
    967  3e5c		       41		      .byte.b	65	;B
    968  3e5d		       7f		      .byte.b	127	;R (40)
    969  3e5e		       38		      .byte.b	56	;G
    970  3e5f		       39		      .byte.b	57	;B
    971  3e60		       01		      .byte.b	1	;R (39)
    972  3e61		       00		      .byte.b	0	;G
    973  3e62		       01		      .byte.b	1	;B
    974  3e63		       ff		      .byte.b	255	;R (38)
    975  3e64		       00		      .byte.b	0	;G
    976  3e65		       ff		      .byte.b	255	;B
    977  3e66		       00		      .byte.b	0	;R (37)
    978  3e67		       00		      .byte.b	0	;G
    979  3e68		       ff		      .byte.b	255	;B
    980  3e69		       aa		      .byte.b	170	;R (36)
    981  3e6a		       00		      .byte.b	0	;G
    982  3e6b		       ff		      .byte.b	255	;B
    983  3e6c		       55		      .byte.b	85	;R (35)
    984  3e6d		       00		      .byte.b	0	;G
    985  3e6e		       ff		      .byte.b	255	;B
    986  3e6f		       ff		      .byte.b	255	;R (34)
    987  3e70		       55		      .byte.b	85	;G
    988  3e71		       aa		      .byte.b	170	;B
    989  3e72		       ff		      .byte.b	255	;R (33)
    990  3e73		       ff		      .byte.b	255	;G
    991  3e74		       00		      .byte.b	0	;B
    992  3e75		       ff		      .byte.b	255	;R (32)
    993  3e76		       ff		      .byte.b	255	;G
    994  3e77		       00		      .byte.b	0	;B
    995  3e78		       7f		      .byte.b	127	;R (31)
    996  3e79		       7f		      .byte.b	127	;G
    997  3e7a		       80		      .byte.b	128	;B
    998  3e7b		       3f		      .byte.b	63	;R (30)
    999  3e7c		       3f		      .byte.b	63	;G
   1000  3e7d		       c0		      .byte.b	192	;B
   1001  3e7e		       1f		      .byte.b	31	;R (29)
   1002  3e7f		       1f		      .byte.b	31	;G
   1003  3e80		       e0		      .byte.b	224	;B
   1004  3e81		       0f		      .byte.b	15	;R (28)
   1005  3e82		       0f		      .byte.b	15	;G
   1006  3e83		       f0		      .byte.b	240	;B
   1007  3e84		       07		      .byte.b	7	;R (27)
   1008  3e85		       07		      .byte.b	7	;G
   1009  3e86		       f8		      .byte.b	248	;B
   1010  3e87		       fb		      .byte.b	251	;R (26)
   1011  3e88		       03		      .byte.b	3	;G
   1012  3e89		       fc		      .byte.b	252	;B
   1013  3e8a		       80		      .byte.b	128	;R (25)
   1014  3e8b		       00		      .byte.b	0	;G
   1015  3e8c		       ff		      .byte.b	255	;B
   1016  3e8d		       80		      .byte.b	128	;R (24)
   1017  3e8e		       00		      .byte.b	0	;G
   1018  3e8f		       ff		      .byte.b	255	;B
   1019  3e90		       80		      .byte.b	128	;R (23)
   1020  3e91		       00		      .byte.b	0	;G
   1021  3e92		       ff		      .byte.b	255	;B
   1022  3e93		       80		      .byte.b	128	;R (22)
   1023  3e94		       00		      .byte.b	0	;G
   1024  3e95		       ff		      .byte.b	255	;B
   1025  3e96		       ff		      .byte.b	255	;R (21)
   1026  3e97		       00		      .byte.b	0	;G
   1027  3e98		       ff		      .byte.b	255	;B
   1028  3e99		       04		      .byte.b	4	;R (20)
   1029  3e9a		       00		      .byte.b	0	;G
   1030  3e9b		       ff		      .byte.b	255	;B
   1031  3e9c		       04		      .byte.b	4	;R (19)
   1032  3e9d		       00		      .byte.b	0	;G
   1033  3e9e		       ff		      .byte.b	255	;B
   1034  3e9f		       04		      .byte.b	4	;R (18)
   1035  3ea0		       00		      .byte.b	0	;G
   1036  3ea1		       ff		      .byte.b	255	;B
   1037  3ea2		       04		      .byte.b	4	;R (17)
   1038  3ea3		       00		      .byte.b	0	;G
   1039  3ea4		       ff		      .byte.b	255	;B
   1040  3ea5		       ff		      .byte.b	255	;R (16)
   1041  3ea6		       00		      .byte.b	0	;G
   1042  3ea7		       ff		      .byte.b	255	;B
   1043  3ea8		       ff		      .byte.b	255	;R (15)
   1044  3ea9		       00		      .byte.b	0	;G
   1045  3eaa		       00		      .byte.b	0	;B
   1046  3eab		       00		      .byte.b	0	;R (14)
   1047  3eac		       00		      .byte.b	0	;G
   1048  3ead		       00		      .byte.b	0	;B
   1049  3eae		       00		      .byte.b	0	;R (13)
   1050  3eaf		       00		      .byte.b	0	;G
   1051  3eb0		       00		      .byte.b	0	;B
   1052  3eb1		       00		      .byte.b	0	;R (12)
   1053  3eb2		       00		      .byte.b	0	;G
   1054  3eb3		       00		      .byte.b	0	;B
   1055  3eb4		       00		      .byte.b	0	;R (11)
   1056  3eb5		       00		      .byte.b	0	;G
   1057  3eb6		       00		      .byte.b	0	;B
   1058  3eb7		       00		      .byte.b	0	;R (10)
   1059  3eb8		       00		      .byte.b	0	;G
   1060  3eb9		       00		      .byte.b	0	;B
   1061  3eba		       00		      .byte.b	0	;R (9)
   1062  3ebb		       00		      .byte.b	0	;G
   1063  3ebc		       00		      .byte.b	0	;B
   1064  3ebd		       00		      .byte.b	0	;R (8)
   1065  3ebe		       00		      .byte.b	0	;G
   1066  3ebf		       00		      .byte.b	0	;B
   1067  3ec0		       00		      .byte.b	0	;R (7)
   1068  3ec1		       00		      .byte.b	0	;G
   1069  3ec2		       00		      .byte.b	0	;B
   1070  3ec3		       00		      .byte.b	0	;R (6)
   1071  3ec4		       00		      .byte.b	0	;G
   1072  3ec5		       00		      .byte.b	0	;B
   1073  3ec6		       00		      .byte.b	0	;R (5)
   1074  3ec7		       80		      .byte.b	128	;G
   1075  3ec8		       00		      .byte.b	0	;B
   1076  3ec9		       00		      .byte.b	0	;R (4)
   1077  3eca		       00		      .byte.b	0	;G
   1078  3ecb		       00		      .byte.b	0	;B
   1079  3ecc		       00		      .byte.b	0	;R (3)
   1080  3ecd		       00		      .byte.b	0	;G
   1081  3ece		       00		      .byte.b	0	;B
   1082  3ecf		       00		      .byte.b	0	;R (2)
   1083  3ed0		       00		      .byte.b	0	;G
   1084  3ed1		       00		      .byte.b	0	;B
   1085  3ed2		       00		      .byte.b	0	;R (1)
   1086  3ed3		       00		      .byte.b	0	;G
   1087  3ed4		       00		      .byte.b	0	;B
   1088  3ed5		       00		      .byte.b	0	;R (0)
   1089  3ed6		       00		      .byte.b	0	;G
   1090  3ed7		       00		      .byte.b	0	;B
      0  3ed8					      OPTIONAL_PAGEBREAK	"5", 72
 PAGE BREAK INSERTED FOR  5
 REQUESTED SIZE =  $48
 WASTED SPACE =  $28
 PAGEBREAK LOCATION =  $f700
     10  3f00					      LIST	ON
   1092  3f00				   COL_5
   1093  3f00		       01		      .byte.b	1	;R (71)
   1094  3f01		       00		      .byte.b	0	;G
   1095  3f02		       00		      .byte.b	0	;B
   1096  3f03		       00		      .byte.b	0	;R (70)
   1097  3f04		       01		      .byte.b	1	;G
   1098  3f05		       00		      .byte.b	0	;B
   1099  3f06		       00		      .byte.b	0	;R (69)
   1100  3f07		       01		      .byte.b	1	;G
   1101  3f08		       00		      .byte.b	0	;B
   1102  3f09		       01		      .byte.b	1	;R (68)
   1103  3f0a		       00		      .byte.b	0	;G
   1104  3f0b		       00		      .byte.b	0	;B
   1105  3f0c		       01		      .byte.b	1	;R (67)
   1106  3f0d		       00		      .byte.b	0	;G
   1107  3f0e		       00		      .byte.b	0	;B
   1108  3f0f		       00		      .byte.b	0	;R (66)
   1109  3f10		       00		      .byte.b	0	;G
   1110  3f11		       00		      .byte.b	0	;B
   1111  3f12		       01		      .byte.b	1	;R (65)
   1112  3f13		       00		      .byte.b	0	;G
   1113  3f14		       01		      .byte.b	1	;B
   1114  3f15		       01		      .byte.b	1	;R (64)
   1115  3f16		       00		      .byte.b	0	;G
   1116  3f17		       01		      .byte.b	1	;B
   1117  3f18		       01		      .byte.b	1	;R (63)
   1118  3f19		       00		      .byte.b	0	;G
   1119  3f1a		       01		      .byte.b	1	;B
   1120  3f1b		       39		      .byte.b	57	;R (62)
   1121  3f1c		       30		      .byte.b	48	;G
   1122  3f1d		       01		      .byte.b	1	;B
   1123  3f1e		       7d		      .byte.b	125	;R (61)
   1124  3f1f		       30		      .byte.b	48	;G
   1125  3f20		       41		      .byte.b	65	;B
   1126  3f21		       7d		      .byte.b	125	;R (60)
   1127  3f22		       30		      .byte.b	48	;G
   1128  3f23		       41		      .byte.b	65	;B
   1129  3f24		       45		      .byte.b	69	;R (59)
   1130  3f25		       00		      .byte.b	0	;G
   1131  3f26		       41		      .byte.b	65	;B
   1132  3f27		       45		      .byte.b	69	;R (58)
   1133  3f28		       00		      .byte.b	0	;G
   1134  3f29		       41		      .byte.b	65	;B
   1135  3f2a		       7d		      .byte.b	125	;R (57)
   1136  3f2b		       30		      .byte.b	48	;G
   1137  3f2c		       41		      .byte.b	65	;B
   1138  3f2d		       7d		      .byte.b	125	;R (56)
   1139  3f2e		       10		      .byte.b	16	;G
   1140  3f2f		       61		      .byte.b	97	;B
   1141  3f30		       39		      .byte.b	57	;R (55)
   1142  3f31		       00		      .byte.b	0	;G
   1143  3f32		       39		      .byte.b	57	;B
   1144  3f33		       01		      .byte.b	1	;R (54)
   1145  3f34		       00		      .byte.b	0	;G
   1146  3f35		       01		      .byte.b	1	;B
   1147  3f36		       39		      .byte.b	57	;R (53)
   1148  3f37		       30		      .byte.b	48	;G
   1149  3f38		       01		      .byte.b	1	;B
   1150  3f39		       7d		      .byte.b	125	;R (52)
   1151  3f3a		       30		      .byte.b	48	;G
   1152  3f3b		       41		      .byte.b	65	;B
   1153  3f3c		       7d		      .byte.b	125	;R (51)
   1154  3f3d		       30		      .byte.b	48	;G
   1155  3f3e		       41		      .byte.b	65	;B
   1156  3f3f		       45		      .byte.b	69	;R (50)
   1157  3f40		       00		      .byte.b	0	;G
   1158  3f41		       41		      .byte.b	65	;B
   1159  3f42		       45		      .byte.b	69	;R (49)
   1160  3f43		       00		      .byte.b	0	;G
   1161  3f44		       41		      .byte.b	65	;B
   1162  3f45		       7d		      .byte.b	125	;R (48)
   1163  3f46		       30		      .byte.b	48	;G
   1164  3f47		       41		      .byte.b	65	;B
   1165  3f48		       7d		      .byte.b	125	;R (47)
   1166  3f49		       10		      .byte.b	16	;G
   1167  3f4a		       61		      .byte.b	97	;B
   1168  3f4b		       39		      .byte.b	57	;R (46)
   1169  3f4c		       00		      .byte.b	0	;G
   1170  3f4d		       39		      .byte.b	57	;B
   1171  3f4e		       01		      .byte.b	1	;R (45)
   1172  3f4f		       00		      .byte.b	0	;G
   1173  3f50		       01		      .byte.b	1	;B
   1174  3f51		       29		      .byte.b	41	;R (44)
   1175  3f52		       20		      .byte.b	32	;G
   1176  3f53		       01		      .byte.b	1	;B
   1177  3f54		       7d		      .byte.b	125	;R (43)
   1178  3f55		       30		      .byte.b	48	;G
   1179  3f56		       41		      .byte.b	65	;B
   1180  3f57		       7d		      .byte.b	125	;R (42)
   1181  3f58		       30		      .byte.b	48	;G
   1182  3f59		       41		      .byte.b	65	;B
   1183  3f5a		       55		      .byte.b	85	;R (41)
   1184  3f5b		       10		      .byte.b	16	;G
   1185  3f5c		       41		      .byte.b	65	;B
   1186  3f5d		       55		      .byte.b	85	;R (40)
   1187  3f5e		       10		      .byte.b	16	;G
   1188  3f5f		       41		      .byte.b	65	;B
   1189  3f60		       7d		      .byte.b	125	;R (39)
   1190  3f61		       30		      .byte.b	48	;G
   1191  3f62		       41		      .byte.b	65	;B
   1192  3f63		       7d		      .byte.b	125	;R (38)
   1193  3f64		       10		      .byte.b	16	;G
   1194  3f65		       61		      .byte.b	97	;B
   1195  3f66		       7c		      .byte.b	124	;R (37)
   1196  3f67		       00		      .byte.b	0	;G
   1197  3f68		       7d		      .byte.b	125	;B
   1198  3f69		       01		      .byte.b	1	;R (36)
   1199  3f6a		       00		      .byte.b	0	;G
   1200  3f6b		       01		      .byte.b	1	;B
   1201  3f6c		       38		      .byte.b	56	;R (35)
   1202  3f6d		       30		      .byte.b	48	;G
   1203  3f6e		       01		      .byte.b	1	;B
   1204  3f6f		       7d		      .byte.b	125	;R (34)
   1205  3f70		       30		      .byte.b	48	;G
   1206  3f71		       41		      .byte.b	65	;B
   1207  3f72		       7d		      .byte.b	125	;R (33)
   1208  3f73		       31		      .byte.b	49	;G
   1209  3f74		       40		      .byte.b	64	;B
   1210  3f75		       45		      .byte.b	69	;R (32)
   1211  3f76		       01		      .byte.b	1	;G
   1212  3f77		       40		      .byte.b	64	;B
   1213  3f78		       45		      .byte.b	69	;R (31)
   1214  3f79		       01		      .byte.b	1	;G
   1215  3f7a		       40		      .byte.b	64	;B
   1216  3f7b		       7d		      .byte.b	125	;R (30)
   1217  3f7c		       31		      .byte.b	49	;G
   1218  3f7d		       40		      .byte.b	64	;B
   1219  3f7e		       7d		      .byte.b	125	;R (29)
   1220  3f7f		       11		      .byte.b	17	;G
   1221  3f80		       60		      .byte.b	96	;B
   1222  3f81		       39		      .byte.b	57	;R (28)
   1223  3f82		       01		      .byte.b	1	;G
   1224  3f83		       38		      .byte.b	56	;B
   1225  3f84		       01		      .byte.b	1	;R (27)
   1226  3f85		       01		      .byte.b	1	;G
   1227  3f86		       00		      .byte.b	0	;B
   1228  3f87		       45		      .byte.b	69	;R (26)
   1229  3f88		       01		      .byte.b	1	;G
   1230  3f89		       40		      .byte.b	64	;B
   1231  3f8a		       6c		      .byte.b	108	;R (25)
   1232  3f8b		       20		      .byte.b	32	;G
   1233  3f8c		       41		      .byte.b	65	;B
   1234  3f8d		       7c		      .byte.b	124	;R (24)
   1235  3f8e		       30		      .byte.b	48	;G
   1236  3f8f		       41		      .byte.b	65	;B
   1237  3f90		       18		      .byte.b	24	;R (23)
   1238  3f91		       10		      .byte.b	16	;G
   1239  3f92		       01		      .byte.b	1	;B
   1240  3f93		       7c		      .byte.b	124	;R (22)
   1241  3f94		       30		      .byte.b	48	;G
   1242  3f95		       41		      .byte.b	65	;B
   1243  3f96		       7d		      .byte.b	125	;R (21)
   1244  3f97		       10		      .byte.b	16	;G
   1245  3f98		       61		      .byte.b	97	;B
   1246  3f99		       7c		      .byte.b	124	;R (20)
   1247  3f9a		       00		      .byte.b	0	;G
   1248  3f9b		       7d		      .byte.b	125	;B
   1249  3f9c		       00		      .byte.b	0	;R (19)
   1250  3f9d		       00		      .byte.b	0	;G
   1251  3f9e		       01		      .byte.b	1	;B
   1252  3f9f		       38		      .byte.b	56	;R (18)
   1253  3fa0		       30		      .byte.b	48	;G
   1254  3fa1		       01		      .byte.b	1	;B
   1255  3fa2		       7c		      .byte.b	124	;R (17)
   1256  3fa3		       30		      .byte.b	48	;G
   1257  3fa4		       41		      .byte.b	65	;B
   1258  3fa5		       7d		      .byte.b	125	;R (16)
   1259  3fa6		       30		      .byte.b	48	;G
   1260  3fa7		       41		      .byte.b	65	;B
   1261  3fa8		       45		      .byte.b	69	;R (15)
   1262  3fa9		       00		      .byte.b	0	;G
   1263  3faa		       40		      .byte.b	64	;B
   1264  3fab		       44		      .byte.b	68	;R (14)
   1265  3fac		       00		      .byte.b	0	;G
   1266  3fad		       40		      .byte.b	64	;B
   1267  3fae		       7c		      .byte.b	124	;R (13)
   1268  3faf		       30		      .byte.b	48	;G
   1269  3fb0		       40		      .byte.b	64	;B
   1270  3fb1		       7c		      .byte.b	124	;R (12)
   1271  3fb2		       10		      .byte.b	16	;G
   1272  3fb3		       60		      .byte.b	96	;B
   1273  3fb4		       38		      .byte.b	56	;R (11)
   1274  3fb5		       00		      .byte.b	0	;G
   1275  3fb6		       38		      .byte.b	56	;B
   1276  3fb7		       00		      .byte.b	0	;R (10)
   1277  3fb8		       00		      .byte.b	0	;G
   1278  3fb9		       00		      .byte.b	0	;B
   1279  3fba		       18		      .byte.b	24	;R (9)
   1280  3fbb		       10		      .byte.b	16	;G
   1281  3fbc		       00		      .byte.b	0	;B
   1282  3fbd		       5c		      .byte.b	92	;R (8)
   1283  3fbe		       10		      .byte.b	16	;G
   1284  3fbf		       40		      .byte.b	64	;B
   1285  3fc0		       5c		      .byte.b	92	;R (7)
   1286  3fc1		       10		      .byte.b	16	;G
   1287  3fc2		       40		      .byte.b	64	;B
   1288  3fc3		       54		      .byte.b	84	;R (6)
   1289  3fc4		       10		      .byte.b	16	;G
   1290  3fc5		       40		      .byte.b	64	;B
   1291  3fc6		       74		      .byte.b	116	;R (5)
   1292  3fc7		       30		      .byte.b	48	;G
   1293  3fc8		       40		      .byte.b	64	;B
   1294  3fc9		       74		      .byte.b	116	;R (4)
   1295  3fca		       10		      .byte.b	16	;G
   1296  3fcb		       64		      .byte.b	100	;B
   1297  3fcc		       30		      .byte.b	48	;R (3)
   1298  3fcd		       00		      .byte.b	0	;G
   1299  3fce		       30		      .byte.b	48	;B
   1300  3fcf		       00		      .byte.b	0	;R (2)
   1301  3fd0		       00		      .byte.b	0	;G
   1302  3fd1		       00		      .byte.b	0	;B
   1303  3fd2		       00		      .byte.b	0	;R (1)
   1304  3fd3		       00		      .byte.b	0	;G
   1305  3fd4		       00		      .byte.b	0	;B
   1306  3fd5		       00		      .byte.b	0	;R (0)
   1307  3fd6		       00		      .byte.b	0	;G
   1308  3fd7		       00		      .byte.b	0	;B
------- FILE titleScreen.asm
    258  3fd8							;    include "pizza.asm"
    259  3fd8
      0  3fd8					      CHECK_BANK_SIZE	"TITLESCREEN"
      1  3fd8		       07 d8	   .TEMP      =	* - BANK_START
 TITLESCREEN (2K) SIZE =  $7d8 , FREE= $28
      2  3fd8					      ECHO	"TITLESCREEN", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3fd8				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  3fd8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3fd8				  -	      ERR
      6  3fd8					      endif
------- FILE ./sokoboo.asm
------- FILE levelScreen.asm LEVEL 2 PASS 3
      0  3fd8					      include	"levelScreen.asm"
      0  3fd8					      NEWBANK	LEVELSCREEN
      1  47e0 ????				      SEG	LEVELSCREEN
      2  4000					      ORG	ORIGIN
      3  4000					      RORG	$F000
      4  4000				   BANK_START SET	*
      5  4000				   LEVELSCREEN SET	ORIGIN / 2048
      6  4000				   ORIGIN     SET	ORIGIN + 2048
      7  4000				   _CURRENT_BANK SET	LEVELSCREEN
      2  4000
      3  4000		       00 12	   TOPHAT     =	18
      4  4000		       00 20	   BIGDIG_SIZE =	32
      5  4000
      6  4000
      0  4000					      DEFINE_SUBROUTINE	SelectionScreenInit
      1  4000		       00 08	   BANK_SelectionScreenInit =	_CURRENT_BANK
      2  4000					      SUBROUTINE
      3  4000				   SelectionScreenInit
      8  4000
      9  4000		       a9 00		      lda	#%0
     10  4002		       85 44		      sta	NUSIZ0
     11  4004		       85 45		      sta	NUSIZ1
     12  4006		       85 65		      sta	VDELP0
     13  4008		       85 66		      sta	VDELP1
     14  400a		       85 4b		      sta	REFP0
     15  400c		       85 4c		      sta	REFP1
     16  400e							;		  sta COLUBK
     17  400e		       85 59		      sta	AUDV0
     18  4010		       85 5a		      sta	AUDV1	; turn off music while levels init
     19  4012
     20  4012		       a9 14		      lda	#20
     21  4014		       85 e6		      sta	digitick
     22  4016
     23  4016		       a9 f0		      lda	#%11110000
     24  4018		       85 60		      sta	HMP0
     25  401a
     26  401a		       a9 d0		      lda	#%11010000
     27  401c		       85 61		      sta	HMP1
     28  401e
     29  401e
     30  401e		       a9 04		      lda	#%100
     31  4020		       85 4a		      sta	CTRLPF
     32  4022
     33  4022		       a6 80		      ldx	Platform
     34  4024							;		  lda PlatformAdjustColour,x
      0  4024					      NEXT_RANDOM
      1  4024
      2  4024		       a5 c7		      lda	rnd
      3  4026		       4a		      lsr
      4  4027					      IFCONST	rndHi
      5  4027		       66 c6		      ror	rndHi
      6  4029					      ENDIF
      7  4029		       90 02		      bcc	.skipEOR
      8  402b		       49 b4		      eor	#RND_EOR_VAL
      9  402d				   .skipEOR
     10  402d		       85 c7		      sta	rnd
     36  402f		       29 f0		      and	#$F0
     37  4031		       85 f2		      sta	adjustColour
     38  4033							;		  lda PlatformWallColour,x
      0  4033					      NEXT_RANDOM
      1  4033
      2  4033		       a5 c7		      lda	rnd
      3  4035		       4a		      lsr
      4  4036					      IFCONST	rndHi
      5  4036		       66 c6		      ror	rndHi
      6  4038					      ENDIF
      7  4038		       90 02		      bcc	.skipEOR
      8  403a		       49 b4		      eor	#RND_EOR_VAL
      9  403c				   .skipEOR
     10  403c		       85 c7		      sta	rnd
     40  403e		       29 f0		      and	#$F0
     41  4040		       d0 00		      bne	n00
     42  4042		       09 02	   n00	      ora	#2
     43  4044		       85 f1		      sta	wallColour
     44  4046
     45  4046		       85 46		      sta	COLUP0
     46  4048		       85 47		      sta	COLUP1
     47  404a
     48  404a		       60		      rts
     49  404b
     50  404b				   PlatformWallColour
     51  404b		       f0 f0 22 22	      .byte.b	$F0, $F0, $22, $22
     52  404f				   PlatformAdjustColour
     53  404f		       00 00 c0 c0	      .byte.b	0,0, $c0, $c0
     54  4053
      0  4053					      DEFINE_SUBROUTINE	LevelScreen
      1  4053		       00 08	   BANK_LevelScreen =	_CURRENT_BANK
      2  4053					      SUBROUTINE
      3  4053				   LevelScreen
     56  4053
     57  4053		       85 ed		      sta	selector
     58  4055
     59  4055							;    lda #%10
     60  4055							;    sta VBLANK
     61  4055
     62  4055
     63  4055		       20 00 f0 	      jsr	SelectionScreenInit
     64  4058
     65  4058		       a9 ff		      lda	#-1
     66  405a		       85 ea		      sta	endwait
     67  405c
     68  405c		       a9 ff		      lda	#-1
     69  405e		       85 e7		      sta	targetDigit
     70  4060		       85 e8		      sta	targetDigit+1
     71  4062		       85 e9		      sta	targetDigit+2
     72  4064
     73  4064		       a9 00		      lda	#0
     74  4066		       85 e3		      sta	digit
     75  4068		       85 e4		      sta	digit+1
     76  406a		       85 e5		      sta	digit+2
     77  406c		       85 ee		      sta	walkSpeed
     78  406e
     79  406e							; convert to 3 digits decimal
     80  406e		       20 10 f3 	      jsr	dd3
     81  4071
     82  4071		       20 36 f3 	      jsr	fixWalkFrame
     83  4074
      0  4074					      RESYNC		; uses overlay
      1  4074
      2  4074		       a9 02		      lda	#%10
      3  4076		       85 41		      sta	VBLANK
      4  4078
      5  4078		       a2 08		      ldx	#8
      6  407a				   .loopResync
      0  407a					      VERTICAL_SYNC
      1  407a		       a9 0e		      lda	#%1110
      2  407c		       85 42	   .VSLP1     sta	WSYNC
      3  407e		       85 40		      sta	VSYNC
      4  4080		       4a		      lsr
      5  4081		       d0 f9		      bne	.VSLP1
      8  4083
      9  4083		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  4085		       a5 80		      lda	Platform
     11  4087		       49 02		      eor	#PAL_50
     12  4089		       d0 02		      bne	.ntsc
     13  408b		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  408d				   .ntsc
     15  408d				   .loopWait
     16  408d		       85 42		      sta	WSYNC
     17  408f		       85 42		      sta	WSYNC
     18  4091		       88		      dey
     19  4092		       d0 f9		      bne	.loopWait
     20  4094		       ca		      dex
     21  4095		       d0 e3		      bne	.loopResync
     85  4097
     86  4097		       a5 ed		      lda	selector
     87  4099		       f0 0c		      beq	RestartFrameX
     88  409b
     89  409b		       a5 e7		      lda	targetDigit
     90  409d		       85 e3		      sta	digit
     91  409f		       a5 e9		      lda	targetDigit+2
     92  40a1		       85 e5		      sta	digit+2
     93  40a3		       a5 e8		      lda	targetDigit+1
     94  40a5		       85 e4		      sta	digit+1
     95  40a7
     96  40a7
     97  40a7				   RestartFrameX
     98  40a7		       a9 0e		      lda	#%1110	; VSYNC ON
     99  40a9		       85 42	   .loopVSync3 sta	WSYNC
    100  40ab		       85 40		      sta	VSYNC
    101  40ad		       4a		      lsr
    102  40ae		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
    103  40b0
    104  40b0		       a6 80		      ldx	Platform
    105  40b2		       bd b3 f3 	      lda	VBlankTime2x,x
    106  40b5		       8d 96 02 	      sta	TIM64T
    107  40b8
    108  40b8		       a9 02		      lda	#2
    109  40ba		       85 41		      sta	VBLANK
    110  40bc		       a2 25		      ldx	#37
    111  40be		       85 42	   toplines   sta	WSYNC
    112  40c0		       ca		      dex
    113  40c1		       d0 fb		      bne	toplines
    114  40c3		       86 41		      stx	VBLANK
    115  40c5
    116  40c5		       a9 00		      lda	#0
    117  40c7		       85 49		      sta	COLUBK
    118  40c9
    119  40c9		       ad 84 02    topsync    lda	INTIM
    120  40cc		       d0 fb		      bne	topsync
    121  40ce
    122  40ce							;		  ldx Platform
    123  40ce							;		  ldy VBlankTime2x,x
    124  40ce							;		  sty TIM64T
    125  40ce
    126  40ce		       a5 e5		      lda	digit+2	; hundreds
    127  40d0		       0a		      asl
    128  40d1		       aa		      tax
    129  40d2		       bd e7 f3 	      lda	DIGITHUND,x
    130  40d5		       85 eb		      sta	digitHundreds
    131  40d7		       bd e8 f3 	      lda	DIGITHUND+1,x
    132  40da		       85 ec		      sta	digitHundreds+1
    133  40dc
    134  40dc		       a5 e4		      lda	digit+1	; tens
    135  40de		       0a		      asl
    136  40df		       aa		      tax
    137  40e0		       bd bf f3 	      lda	LDIGIT,x
    138  40e3		       85 dd		      sta	digit1
    139  40e5		       bd c0 f3 	      lda	LDIGIT+1,x
    140  40e8		       85 de		      sta	digit1+1
    141  40ea
    142  40ea		       a5 e3		      lda	digit	; units
    143  40ec		       0a		      asl
    144  40ed		       aa		      tax
    145  40ee		       bd d3 f3 	      lda	RDIGIT,x
    146  40f1		       85 df		      sta	digit2
    147  40f3		       bd d4 f3 	      lda	RDIGIT+1,x
    148  40f6		       85 e0		      sta	digit2+1
    149  40f8
    150  40f8
    151  40f8
    152  40f8							;------------------------------------------------------------------
    153  40f8
    154  40f8
    155  40f8							;VerticalBlankX;
    156  40f8							;		  lda INTIM
    157  40f8							;		  bne VerticalBlankX
    158  40f8
    159  40f8
    160  40f8		       a9 00		      lda	#0
    161  40fa		       85 4d		      sta	PF0
    162  40fc		       85 4e		      sta	PF1
    163  40fe		       85 4f		      sta	PF2
    164  4100		       85 49		      sta	COLUBK
    165  4102
    166  4102							; position the sprites for the box walls
    167  4102
    168  4102		       85 42		      sta	WSYNC
    169  4104
      0  4104					      SLEEP	17
      1  4104				   .CYCLES    SET	17
      2  4104
      3  4104				  -	      IF	.CYCLES < 2
      4  4104				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4104				  -	      ERR
      6  4104					      ENDIF
      7  4104
      8  4104					      IF	.CYCLES & 1
      9  4104					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4104		       04 00		      nop	0
     11  4106				  -	      ELSE
     12  4106				  -	      bit	VSYNC
     13  4106					      ENDIF
     14  4106				   .CYCLES    SET	.CYCLES - 3
     15  4106					      ENDIF
     16  4106
     17  4106					      REPEAT	.CYCLES / 2
     18  4106		       ea		      nop
     17  4106					      REPEND
     18  4107		       ea		      nop
     17  4107					      REPEND
     18  4108		       ea		      nop
     17  4108					      REPEND
     18  4109		       ea		      nop
     17  4109					      REPEND
     18  410a		       ea		      nop
     17  410a					      REPEND
     18  410b		       ea		      nop
     17  410b					      REPEND
     18  410c		       ea		      nop
     19  410d					      REPEND
    171  410d		       85 50		      sta	RESP0
    172  410f
      0  410f					      SLEEP	37
      1  410f				   .CYCLES    SET	37
      2  410f
      3  410f				  -	      IF	.CYCLES < 2
      4  410f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  410f				  -	      ERR
      6  410f					      ENDIF
      7  410f
      8  410f					      IF	.CYCLES & 1
      9  410f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  410f		       04 00		      nop	0
     11  4111				  -	      ELSE
     12  4111				  -	      bit	VSYNC
     13  4111					      ENDIF
     14  4111				   .CYCLES    SET	.CYCLES - 3
     15  4111					      ENDIF
     16  4111
     17  4111					      REPEAT	.CYCLES / 2
     18  4111		       ea		      nop
     17  4111					      REPEND
     18  4112		       ea		      nop
     17  4112					      REPEND
     18  4113		       ea		      nop
     17  4113					      REPEND
     18  4114		       ea		      nop
     17  4114					      REPEND
     18  4115		       ea		      nop
     17  4115					      REPEND
     18  4116		       ea		      nop
     17  4116					      REPEND
     18  4117		       ea		      nop
     17  4117					      REPEND
     18  4118		       ea		      nop
     17  4118					      REPEND
     18  4119		       ea		      nop
     17  4119					      REPEND
     18  411a		       ea		      nop
     17  411a					      REPEND
     18  411b		       ea		      nop
     17  411b					      REPEND
     18  411c		       ea		      nop
     17  411c					      REPEND
     18  411d		       ea		      nop
     17  411d					      REPEND
     18  411e		       ea		      nop
     17  411e					      REPEND
     18  411f		       ea		      nop
     17  411f					      REPEND
     18  4120		       ea		      nop
     17  4120					      REPEND
     18  4121		       ea		      nop
     19  4122					      REPEND
    174  4122		       85 51		      sta	RESP1
    175  4124
    176  4124		       85 42		      sta	WSYNC
    177  4126		       85 6a		      sta	HMOVE
    178  4128
    179  4128
    180  4128							;===================================================================================================
    181  4128
    182  4128							; now a top for the 'box'
    183  4128
    184  4128		       a9 00		      lda	#0
    185  412a		       85 4d		      sta	PF0
    186  412c		       85 4e		      sta	PF1
    187  412e		       85 4f		      sta	PF2
    188  4130
    189  4130		       a0 11		      ldy	#TOPHAT-1
    190  4132		       85 42	   boxtop     sta	WSYNC	;@0
    191  4134
    192  4134		       98		      tya
    193  4135		       0a		      asl
    194  4136		       29 06		      and	#%110
    195  4138		       05 f1		      ora	wallColour
    196  413a		       85 48		      sta	COLUPF
    197  413c		       b9 f1 f3 	      lda	lid0,y	;#%11100000
    198  413f		       85 4d		      sta	PF0
    199  4141		       b9 03 f4 	      lda	lid1,y	;#255
    200  4144							;nop
    201  4144		       85 4e		      sta	PF1
    202  4146		       b9 03 f4 	      lda	lid2,y	;#255
    203  4149							;nop
    204  4149		       85 4f		      sta	PF2	; 3 = 8 @ 19
    205  414b
    206  414b							; RHS
    207  414b		       b9 15 f4 	      lda	lid3,y	;#255
    208  414e							;nop
    209  414e		       85 4d		      sta	PF0	; 3 = 8 @ 27 OK	D7D6D5D4 <--- mirrored
    210  4150
      0  4150					      SLEEP	8
      1  4150				   .CYCLES    SET	8
      2  4150
      3  4150				  -	      IF	.CYCLES < 2
      4  4150				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4150				  -	      ERR
      6  4150					      ENDIF
      7  4150
      8  4150				  -	      IF	.CYCLES & 1
      9  4150				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  4150				  -	      nop	0
     11  4150				  -	      ELSE
     12  4150				  -	      bit	VSYNC
     13  4150				  -	      ENDIF
     14  4150				  -.CYCLES    SET	.CYCLES - 3
     15  4150					      ENDIF
     16  4150
     17  4150					      REPEAT	.CYCLES / 2
     18  4150		       ea		      nop
     17  4150					      REPEND
     18  4151		       ea		      nop
     17  4151					      REPEND
     18  4152		       ea		      nop
     17  4152					      REPEND
     18  4153		       ea		      nop
     19  4154					      REPEND
    212  4154		       b9 15 f4 	      lda	lid4,y	;#255
    213  4157		       85 4e		      sta	PF1	; 3 @40		 NOT MIRRORED, D7D6D5D4 -->
    214  4159
    215  4159		       a9 00		      lda	#%00000000
    216  415b							;		  nop
    217  415b		       85 4f		      sta	PF2	; 3 = 8 @48
    218  415d
    219  415d		       a9 00		      lda	#0
    220  415f		       85 49		      sta	COLUBK
    221  4161
    222  4161
    223  4161		       88		      dey		; 2
    224  4162		       10 ce		      bpl	boxtop
    225  4164
    226  4164
    227  4164		       a9 00		      lda	#0
    228  4166		       85 4d		      sta	PF0
    229  4168		       85 4e		      sta	PF1
    230  416a		       85 4f		      sta	PF2
    231  416c							;		  sta GRP0
    232  416c							;		  sta GRP1
    233  416c
    234  416c		       a9 fc		      lda	#%11111100
    235  416e		       85 5b		      sta	GRP0
    236  4170		       a9 3f		      lda	#%00111111
    237  4172		       85 5c		      sta	GRP1
    238  4174
    239  4174
    240  4174		       85 42		      sta	WSYNC
    241  4176							;		  sta WSYNC
    242  4176							;		  sta WSYNC
    243  4176							;		  sta WSYNC
    244  4176							;		  sta WSYNC
    245  4176
    246  4176							;===================================================================================================
    247  4176
    248  4176		       a6 80		      ldx	Platform
    249  4178		       bd bb f3 	      lda	colvecX,x
    250  417b		       aa		      tax
    251  417c
    252  417c							;------------------------------------------------------------------
    253  417c
    254  417c							; Do X scanlines of color-changing (our picture)
    255  417c
    256  417c
    257  417c		       a9 2a		      lda	#$2A	; 2
    258  417e		       85 48		      sta	COLUPF	; 3 = 5 @8
    259  4180
    260  4180		       a0 1f		      ldy	#BIGDIG_SIZE-1	; #lines in characters-1
    261  4182
    262  4182		       a2 00		      ldx	#0	; used as a generic "0" during the kernel
    263  4184		       85 42		      sta	WSYNC
    264  4186
    265  4186
    266  4186		       00 04	   DUPES      =	4
    267  4186				   LevelNumberDigits
    268  4186
    269  4186				   .LOOP      SET	0
    270  4186					      REPEAT	DUPES
    271  4186
    272  4186		       86 4d		      stx	PF0	; 3
    273  4188
    274  4188					      IF	.LOOP < DUPES-1
    275  4188		       a9 04		      lda	#4	;!!!
    276  418a		       ea		      nop
    277  418b							;lda Level,y		  ; 4
    278  418b		       65 f2		      adc	adjustColour	; 3
    279  418d		       85 48		      sta	COLUPF	; 3 = 10 @13
    280  418f				  -	      ELSE
    281  418f				  -	      lda	#0	;wallColour	      ; 3
    282  418f				  -	      sta	COLUPF	; 3 = 7
    283  418f				  -	      SLEEP	5	; 4 = 10 @13
    284  418f				  -
    285  418f					      ENDIF
    286  418f		       b1 eb		      lda	(digitHundreds),y	; 5
    287  4191		       85 4e		      sta	PF1	; 3 = 8 @21
    288  4193
    289  4193		       b1 dd		      lda	(digit1),y	; 5
    290  4195		       85 4f		      sta	PF2	; 3 = 8 @29
    291  4197
    292  4197							; RHS
    293  4197
    294  4197		       b1 df		      lda	(digit2),y	; 5
    295  4199		       85 4d		      sta	PF0	; 3 = 8 @ 37	     D7D6D5D4 <--- mirrored
    296  419b
    297  419b		       0a		      asl		; 2
    298  419c		       0a		      asl		; 2
    299  419d		       0a		      asl		; 2
    300  419e		       0a		      asl		; 2
    301  419f		       85 4e		      sta	PF1	; 3 = 11 @48	     NOT MIRRORED, D7D6D5D4 -->
    302  41a1
    303  41a1		       b1 e1		      lda	(digitstar),y	; 5
    304  41a3		       85 4f		      sta	PF2	; 3 = 8 @56
    305  41a5
    306  41a5		       b1 ef		      lda	(manc),y	; 5
    307  41a7		       85 48		      sta	COLUPF	; 3 = 8 @64
    308  41a9
    309  41a9		       00 0c	   SPARE      =	12
    310  41a9
    311  41a9					      IF	.LOOP < DUPES-1
      0  41a9					      SLEEP	SPARE
      1  41a9				   .CYCLES    SET	SPARE
      2  41a9
      3  41a9				  -	      IF	.CYCLES < 2
      4  41a9				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  41a9				  -	      ERR
      6  41a9					      ENDIF
      7  41a9
      8  41a9				  -	      IF	.CYCLES & 1
      9  41a9				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  41a9				  -	      nop	0
     11  41a9				  -	      ELSE
     12  41a9				  -	      bit	VSYNC
     13  41a9				  -	      ENDIF
     14  41a9				  -.CYCLES    SET	.CYCLES - 3
     15  41a9					      ENDIF
     16  41a9
     17  41a9					      REPEAT	.CYCLES / 2
     18  41a9		       ea		      nop
     17  41a9					      REPEND
     18  41aa		       ea		      nop
     17  41aa					      REPEND
     18  41ab		       ea		      nop
     17  41ab					      REPEND
     18  41ac		       ea		      nop
     17  41ac					      REPEND
     18  41ad		       ea		      nop
     17  41ad					      REPEND
     18  41ae		       ea		      nop
     19  41af					      REPEND
    313  41af					      ENDIF
    314  41af
    315  41af				  -	      IF	.LOOP = DUPES-1
    316  41af				  -	      SLEEP	SPARE-7
    317  41af					      ENDIF
    318  41af
    319  41af
    320  41af				   .LOOP      SET	.LOOP + 1
    270  41af					      REPEND
    271  41af
    272  41af		       86 4d		      stx	PF0	; 3
    273  41b1
    274  41b1					      IF	.LOOP < DUPES-1
    275  41b1		       a9 04		      lda	#4	;!!!
    276  41b3		       ea		      nop
    277  41b4							;lda Level,y		  ; 4
    278  41b4		       65 f2		      adc	adjustColour	; 3
    279  41b6		       85 48		      sta	COLUPF	; 3 = 10 @13
    280  41b8				  -	      ELSE
    281  41b8				  -	      lda	#0	;wallColour	      ; 3
    282  41b8				  -	      sta	COLUPF	; 3 = 7
    283  41b8				  -	      SLEEP	5	; 4 = 10 @13
    284  41b8				  -
    285  41b8					      ENDIF
    286  41b8		       b1 eb		      lda	(digitHundreds),y	; 5
    287  41ba		       85 4e		      sta	PF1	; 3 = 8 @21
    288  41bc
    289  41bc		       b1 dd		      lda	(digit1),y	; 5
    290  41be		       85 4f		      sta	PF2	; 3 = 8 @29
    291  41c0
    292  41c0							; RHS
    293  41c0
    294  41c0		       b1 df		      lda	(digit2),y	; 5
    295  41c2		       85 4d		      sta	PF0	; 3 = 8 @ 37	     D7D6D5D4 <--- mirrored
    296  41c4
    297  41c4		       0a		      asl		; 2
    298  41c5		       0a		      asl		; 2
    299  41c6		       0a		      asl		; 2
    300  41c7		       0a		      asl		; 2
    301  41c8		       85 4e		      sta	PF1	; 3 = 11 @48	     NOT MIRRORED, D7D6D5D4 -->
    302  41ca
    303  41ca		       b1 e1		      lda	(digitstar),y	; 5
    304  41cc		       85 4f		      sta	PF2	; 3 = 8 @56
    305  41ce
    306  41ce		       b1 ef		      lda	(manc),y	; 5
    307  41d0		       85 48		      sta	COLUPF	; 3 = 8 @64
    308  41d2
    309  41d2		       00 0c	   SPARE      =	12
    310  41d2
    311  41d2					      IF	.LOOP < DUPES-1
      0  41d2					      SLEEP	SPARE
      1  41d2				   .CYCLES    SET	SPARE
      2  41d2
      3  41d2				  -	      IF	.CYCLES < 2
      4  41d2				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  41d2				  -	      ERR
      6  41d2					      ENDIF
      7  41d2
      8  41d2				  -	      IF	.CYCLES & 1
      9  41d2				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  41d2				  -	      nop	0
     11  41d2				  -	      ELSE
     12  41d2				  -	      bit	VSYNC
     13  41d2				  -	      ENDIF
     14  41d2				  -.CYCLES    SET	.CYCLES - 3
     15  41d2					      ENDIF
     16  41d2
     17  41d2					      REPEAT	.CYCLES / 2
     18  41d2		       ea		      nop
     17  41d2					      REPEND
     18  41d3		       ea		      nop
     17  41d3					      REPEND
     18  41d4		       ea		      nop
     17  41d4					      REPEND
     18  41d5		       ea		      nop
     17  41d5					      REPEND
     18  41d6		       ea		      nop
     17  41d6					      REPEND
     18  41d7		       ea		      nop
     19  41d8					      REPEND
    313  41d8					      ENDIF
    314  41d8
    315  41d8				  -	      IF	.LOOP = DUPES-1
    316  41d8				  -	      SLEEP	SPARE-7
    317  41d8					      ENDIF
    318  41d8
    319  41d8
    320  41d8				   .LOOP      SET	.LOOP + 1
    270  41d8					      REPEND
    271  41d8
    272  41d8		       86 4d		      stx	PF0	; 3
    273  41da
    274  41da					      IF	.LOOP < DUPES-1
    275  41da		       a9 04		      lda	#4	;!!!
    276  41dc		       ea		      nop
    277  41dd							;lda Level,y		  ; 4
    278  41dd		       65 f2		      adc	adjustColour	; 3
    279  41df		       85 48		      sta	COLUPF	; 3 = 10 @13
    280  41e1				  -	      ELSE
    281  41e1				  -	      lda	#0	;wallColour	      ; 3
    282  41e1				  -	      sta	COLUPF	; 3 = 7
    283  41e1				  -	      SLEEP	5	; 4 = 10 @13
    284  41e1				  -
    285  41e1					      ENDIF
    286  41e1		       b1 eb		      lda	(digitHundreds),y	; 5
    287  41e3		       85 4e		      sta	PF1	; 3 = 8 @21
    288  41e5
    289  41e5		       b1 dd		      lda	(digit1),y	; 5
    290  41e7		       85 4f		      sta	PF2	; 3 = 8 @29
    291  41e9
    292  41e9							; RHS
    293  41e9
    294  41e9		       b1 df		      lda	(digit2),y	; 5
    295  41eb		       85 4d		      sta	PF0	; 3 = 8 @ 37	     D7D6D5D4 <--- mirrored
    296  41ed
    297  41ed		       0a		      asl		; 2
    298  41ee		       0a		      asl		; 2
    299  41ef		       0a		      asl		; 2
    300  41f0		       0a		      asl		; 2
    301  41f1		       85 4e		      sta	PF1	; 3 = 11 @48	     NOT MIRRORED, D7D6D5D4 -->
    302  41f3
    303  41f3		       b1 e1		      lda	(digitstar),y	; 5
    304  41f5		       85 4f		      sta	PF2	; 3 = 8 @56
    305  41f7
    306  41f7		       b1 ef		      lda	(manc),y	; 5
    307  41f9		       85 48		      sta	COLUPF	; 3 = 8 @64
    308  41fb
    309  41fb		       00 0c	   SPARE      =	12
    310  41fb
    311  41fb					      IF	.LOOP < DUPES-1
      0  41fb					      SLEEP	SPARE
      1  41fb				   .CYCLES    SET	SPARE
      2  41fb
      3  41fb				  -	      IF	.CYCLES < 2
      4  41fb				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  41fb				  -	      ERR
      6  41fb					      ENDIF
      7  41fb
      8  41fb				  -	      IF	.CYCLES & 1
      9  41fb				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  41fb				  -	      nop	0
     11  41fb				  -	      ELSE
     12  41fb				  -	      bit	VSYNC
     13  41fb				  -	      ENDIF
     14  41fb				  -.CYCLES    SET	.CYCLES - 3
     15  41fb					      ENDIF
     16  41fb
     17  41fb					      REPEAT	.CYCLES / 2
     18  41fb		       ea		      nop
     17  41fb					      REPEND
     18  41fc		       ea		      nop
     17  41fc					      REPEND
     18  41fd		       ea		      nop
     17  41fd					      REPEND
     18  41fe		       ea		      nop
     17  41fe					      REPEND
     18  41ff		       ea		      nop
     17  41ff					      REPEND
     18  4200		       ea		      nop
     19  4201					      REPEND
    313  4201					      ENDIF
    314  4201
    315  4201				  -	      IF	.LOOP = DUPES-1
    316  4201				  -	      SLEEP	SPARE-7
    317  4201					      ENDIF
    318  4201
    319  4201
    320  4201				   .LOOP      SET	.LOOP + 1
    270  4201					      REPEND
    271  4201
    272  4201		       86 4d		      stx	PF0	; 3
    273  4203
    274  4203				  -	      IF	.LOOP < DUPES-1
    275  4203				  -	      lda	#4	;!!!
    276  4203				  -	      nop
    277  4203				  -			;lda Level,y		  ; 4
    278  4203				  -	      adc	adjustColour	; 3
    279  4203				  -	      sta	COLUPF	; 3 = 10 @13
    280  4203					      ELSE
    281  4203		       a9 00		      lda	#0	;wallColour	      ; 3
    282  4205		       85 48		      sta	COLUPF	; 3 = 7
      0  4207					      SLEEP	5	; 4 = 10 @13
      1  4207				   .CYCLES    SET	5
      2  4207
      3  4207				  -	      IF	.CYCLES < 2
      4  4207				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4207				  -	      ERR
      6  4207					      ENDIF
      7  4207
      8  4207					      IF	.CYCLES & 1
      9  4207					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4207		       04 00		      nop	0
     11  4209				  -	      ELSE
     12  4209				  -	      bit	VSYNC
     13  4209					      ENDIF
     14  4209				   .CYCLES    SET	.CYCLES - 3
     15  4209					      ENDIF
     16  4209
     17  4209					      REPEAT	.CYCLES / 2
     18  4209		       ea		      nop
     19  420a					      REPEND
    284  420a
    285  420a					      ENDIF
    286  420a		       b1 eb		      lda	(digitHundreds),y	; 5
    287  420c		       85 4e		      sta	PF1	; 3 = 8 @21
    288  420e
    289  420e		       b1 dd		      lda	(digit1),y	; 5
    290  4210		       85 4f		      sta	PF2	; 3 = 8 @29
    291  4212
    292  4212							; RHS
    293  4212
    294  4212		       b1 df		      lda	(digit2),y	; 5
    295  4214		       85 4d		      sta	PF0	; 3 = 8 @ 37	     D7D6D5D4 <--- mirrored
    296  4216
    297  4216		       0a		      asl		; 2
    298  4217		       0a		      asl		; 2
    299  4218		       0a		      asl		; 2
    300  4219		       0a		      asl		; 2
    301  421a		       85 4e		      sta	PF1	; 3 = 11 @48	     NOT MIRRORED, D7D6D5D4 -->
    302  421c
    303  421c		       b1 e1		      lda	(digitstar),y	; 5
    304  421e		       85 4f		      sta	PF2	; 3 = 8 @56
    305  4220
    306  4220		       b1 ef		      lda	(manc),y	; 5
    307  4222		       85 48		      sta	COLUPF	; 3 = 8 @64
    308  4224
    309  4224		       00 0c	   SPARE      =	12
    310  4224
    311  4224				  -	      IF	.LOOP < DUPES-1
    312  4224				  -	      SLEEP	SPARE
    313  4224					      ENDIF
    314  4224
    315  4224					      IF	.LOOP = DUPES-1
      0  4224					      SLEEP	SPARE-7
      1  4224				   .CYCLES    SET	SPARE-7
      2  4224
      3  4224				  -	      IF	.CYCLES < 2
      4  4224				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4224				  -	      ERR
      6  4224					      ENDIF
      7  4224
      8  4224					      IF	.CYCLES & 1
      9  4224					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4224		       04 00		      nop	0
     11  4226				  -	      ELSE
     12  4226				  -	      bit	VSYNC
     13  4226					      ENDIF
     14  4226				   .CYCLES    SET	.CYCLES - 3
     15  4226					      ENDIF
     16  4226
     17  4226					      REPEAT	.CYCLES / 2
     18  4226		       ea		      nop
     19  4227					      REPEND
    317  4227					      ENDIF
    318  4227
    319  4227
    320  4227				   .LOOP      SET	.LOOP + 1
    321  4227					      REPEND
    322  4227		       88		      dey		; 2
    323  4228		       30 03		      bmi	ess	; 2/3
    324  422a		       4c 86 f1 	      jmp	LevelNumberDigits	; 3 = 7 mostly @ 71
    325  422d
    326  422d
    327  422d				   ess
    328  422d
    329  422d							;		  sta WSYNC
    330  422d
    331  422d
    332  422d							; now a bottom for the 'box'
    333  422d
    334  422d		       a9 00		      lda	#0
    335  422f		       85 4d		      sta	PF0
    336  4231		       85 4e		      sta	PF1
    337  4233		       85 4f		      sta	PF2
    338  4235
    339  4235		       a5 f1		      lda	wallColour
    340  4237		       85 48		      sta	COLUPF
    341  4239
    342  4239		       a0 08		      ldy	#8
    343  423b		       85 42	   boxbottom  sta	WSYNC	;@0
    344  423d		       b9 27 f4 	      lda	lidb0,y	;#%11100000
    345  4240		       29 c0		      and	#%11000000
    346  4242		       85 4d		      sta	PF0
    347  4244		       b9 27 f4 	      lda	lidb1,y	;#255
    348  4247		       85 4e		      sta	PF1
    349  4249		       b9 27 f4 	      lda	lidb2,y	;#255
    350  424c		       85 4f		      sta	PF2	; 3 = 8 @ 19
    351  424e
    352  424e							; RHS
    353  424e		       b9 27 f4 	      lda	lidb3,y
    354  4251		       85 4d		      sta	PF0	; 3 = 8 @ 27 OK	D7D6D5D4 <--- mirrored
    355  4253
      0  4253					      SLEEP	8
      1  4253				   .CYCLES    SET	8
      2  4253
      3  4253				  -	      IF	.CYCLES < 2
      4  4253				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4253				  -	      ERR
      6  4253					      ENDIF
      7  4253
      8  4253				  -	      IF	.CYCLES & 1
      9  4253				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  4253				  -	      nop	0
     11  4253				  -	      ELSE
     12  4253				  -	      bit	VSYNC
     13  4253				  -	      ENDIF
     14  4253				  -.CYCLES    SET	.CYCLES - 3
     15  4253					      ENDIF
     16  4253
     17  4253					      REPEAT	.CYCLES / 2
     18  4253		       ea		      nop
     17  4253					      REPEND
     18  4254		       ea		      nop
     17  4254					      REPEND
     18  4255		       ea		      nop
     17  4255					      REPEND
     18  4256		       ea		      nop
     19  4257					      REPEND
    357  4257		       b9 27 f4 	      lda	lidb4,y
    358  425a		       85 4e		      sta	PF1	; 3 @40		 NOT MIRRORED, D7D6D5D4 -->
    359  425c
    360  425c		       a9 00		      lda	#%00000000
    361  425e							;		  nop
    362  425e		       85 4f		      sta	PF2	; 3 = 8 @48
    363  4260
    364  4260		       a9 06		      lda	#6
    365  4262		       85 49		      sta	COLUBK
    366  4264
    367  4264
    368  4264		       88		      dey		; 2
    369  4265		       10 d4		      bpl	boxbottom
    370  4267
    371  4267
    372  4267		       a9 00		      lda	#0
    373  4269		       85 4d		      sta	PF0
    374  426b		       85 4e		      sta	PF1
    375  426d		       85 4f		      sta	PF2
    376  426f		       85 5b		      sta	GRP0
    377  4271		       85 5c		      sta	GRP1
    378  4273
    379  4273		       a4 80		      ldy	Platform
    380  4275		       b9 b7 f3 	      lda	OverscanTime2X,y
    381  4278		       8d 96 02 	      sta	TIM64T
    382  427b
    383  427b		       85 42		      sta	WSYNC
    384  427d
    385  427d							;--------------------------------------------------------------------------
    386  427d
    387  427d		       c6 e6		      dec	digitick
    388  427f		       10 65		      bpl	donedig
    389  4281		       a9 07		      lda	#7
    390  4283		       85 e6		      sta	digitick
    391  4285
    392  4285		       a2 02		      ldx	#2
    393  4287		       b5 e3	   scanner    lda	digit,x
    394  4289		       d5 e7		      cmp	targetDigit,x
    395  428b		       f0 0e		      beq	scanOK
    396  428d
    397  428d		       f8		      sed
    398  428e		       69 01		      adc	#1
    399  4290		       29 0f		      and	#$F
    400  4292		       95 e3		      sta	digit,x
    401  4294		       d8		      cld
    402  4295
    403  4295		       a9 64		      lda	#100
    404  4297		       85 ea		      sta	endwait
    405  4299		       d0 4b		      bne	donedig
    406  429b
    407  429b		       ca	   scanOK     dex
    408  429c		       10 e9		      bpl	scanner
    409  429e
    410  429e		       a5 ed		      lda	selector
    411  42a0		       f0 44		      beq	donedig	; don't allow joystick selection
    412  42a2
    413  42a2		       a9 ff		      lda	#-1
    414  42a4		       85 e7		      sta	targetDigit
    415  42a6		       85 e8		      sta	targetDigit+1
    416  42a8		       85 e9		      sta	targetDigit+2
    417  42aa
    418  42aa		       ad 80 02 	      lda	SWCHA
    419  42ad		       4a		      lsr
    420  42ae		       4a		      lsr
    421  42af		       4a		      lsr
    422  42b0		       4a		      lsr
    423  42b1		       aa		      tax
    424  42b2
    425  42b2		       bd a3 f3 	      lda	xJoyMoveX,x
    426  42b5		       f0 23		      beq	noadjustLevelNum
    427  42b7
    428  42b7							; level is changing, so animate the man too
    429  42b7
    430  42b7		       20 36 f3 	      jsr	fixWalkFrame
    431  42ba
    432  42ba
    433  42ba
    434  42ba		       bd a3 f3 	      lda	xJoyMoveX,x
    435  42bd		       30 0e		      bmi	downx
    436  42bf
    437  42bf		       e6 b1		      inc	levelX
    438  42c1							;		  bne lxok
    439  42c1							;		  inc levelX+1
    440  42c1							;lxok
    441  42c1
    442  42c1							;		  lda levelX+1
    443  42c1							;		  cmp #>MAX_LEVEL
    444  42c1							;		  bcc lxok2
    445  42c1		       a5 b1		      lda	levelX
    446  42c3		       c9 26		      cmp	#<MAX_LEVEL
    447  42c5		       90 13		      bcc	lxok2
    448  42c7
    449  42c7		       a9 00		      lda	#0
    450  42c9		       85 b1		      sta	levelX
    451  42cb							;		  sta levelX+1
    452  42cb		       f0 0d		      beq	lxok2
    453  42cd
    454  42cd		       38	   downx      sec
    455  42ce		       a5 b1		      lda	levelX
    456  42d0		       e9 01		      sbc	#1
    457  42d2		       85 b1		      sta	levelX
    458  42d4							;		  lda levelX+1
    459  42d4							;		  sbc #0
    460  42d4							;		  sta levelX+1
    461  42d4		       b0 04		      bcs	lxok2
    462  42d6
    463  42d6		       a9 25		      lda	#<(MAX_LEVEL-1)
    464  42d8		       85 b1		      sta	levelX
    465  42da							;		  lda #>(MAX_LEVEL-1)
    466  42da							;		  sta levelX+1
    467  42da
    468  42da				   lxok2
    469  42da				   noadjustLevelNum
    470  42da
    471  42da		       20 10 f3 	      jsr	dd3
    472  42dd
    473  42dd		       a2 02		      ldx	#2
    474  42df		       b5 e7	   zapper     lda	targetDigit,x
    475  42e1		       95 e3		      sta	digit,x
    476  42e3		       ca		      dex
    477  42e4		       10 f9		      bpl	zapper
    478  42e6
    479  42e6				   donedig
    480  42e6
      0  42e6					      NEXT_RANDOM
      1  42e6
      2  42e6		       a5 c7		      lda	rnd
      3  42e8		       4a		      lsr
      4  42e9					      IFCONST	rndHi
      5  42e9		       66 c6		      ror	rndHi
      6  42eb					      ENDIF
      7  42eb		       90 02		      bcc	.skipEOR
      8  42ed		       49 b4		      eor	#RND_EOR_VAL
      9  42ef				   .skipEOR
     10  42ef		       85 c7		      sta	rnd
    482  42f1
    483  42f1		       ad 84 02    oscanX     lda	INTIM
    484  42f4		       d0 fb		      bne	oscanX
    485  42f6
    486  42f6		       85 49		      sta	COLUBK
    487  42f8		       a9 42		      lda	#%01000010	; bit6 is not required
    488  42fa		       85 41		      sta	VBLANK	; end of screen - enter blanking
    489  42fc
    490  42fc		       a9 00		      lda	#0
    491  42fe		       85 40		      sta	VSYNC
    492  4300
    493  4300
    494  4300		       a5 ed		      lda	selector
    495  4302		       d0 04		      bne	waitbutton
    496  4304		       c6 ea		      dec	endwait
    497  4306		       f0 07		      beq	retX
    498  4308
    499  4308		       a5 4c	   waitbutton lda	INPT4
    500  430a		       10 03		      bpl	retX
    501  430c
    502  430c		       4c a7 f0 	      jmp	RestartFrameX
    503  430f
    504  430f		       60	   retX       rts
    505  4310
    506  4310
    507  4310
    508  4310				   dd3
    509  4310		       a2 00		      ldx	#0	;levelX+1
    510  4312		       18		      clc
    511  4313		       a5 b1		      lda	levelX
    512  4315		       69 01		      adc	#1
    513  4317		       90 01		      bcc	not100s
    514  4319		       e8		      inx
    515  431a
    516  431a		       38	   not100s    sec
    517  431b		       e9 64	   m100       sbc	#100
    518  431d		       e6 e9		      inc	targetDigit+2
    519  431f		       b0 fa		      bcs	m100
    520  4321		       ca		      dex
    521  4322		       10 f6		      bpl	not100s
    522  4324		       e8		      inx
    523  4325		       69 64		      adc	#100
    524  4327		       38	   csets      sec
    525  4328		       e9 0a	   m10	      sbc	#10
    526  432a		       e6 e8		      inc	targetDigit+1
    527  432c		       b0 fa		      bcs	m10
    528  432e		       ca		      dex
    529  432f		       10 f6		      bpl	csets
    530  4331		       69 0a		      adc	#10
    531  4333		       85 e7		      sta	targetDigit
    532  4335
    533  4335
    534  4335							; leading zero removal
    535  4335							;lda targetDigit+2
    536  4335							;bne hunds
    537  4335							;lda #10
    538  4335							;sta targetDigit+2
    539  4335							;sta digit+2		  ; hide hundreds if 0
    540  4335				   hunds
    541  4335
    542  4335		       60		      rts
    543  4336
    544  4336
      0  4336					      DEFINE_SUBROUTINE	fixWalkFrame
      1  4336		       00 08	   BANK_fixWalkFrame =	_CURRENT_BANK
      2  4336					      SUBROUTINE
      3  4336				   fixWalkFrame
    546  4336
    547  4336
    548  4336		       a5 ed		      lda	selector
    549  4338		       f0 10		      beq	walk0
    550  433a
    551  433a		       18		      clc
    552  433b		       a5 ee		      lda	walkSpeed
    553  433d		       69 04		      adc	#4
    554  433f		       85 ee		      sta	walkSpeed
    555  4341
    556  4341		       4a		      lsr
    557  4342		       4a		      lsr
    558  4343		       29 03		      and	#%11
    559  4345		       a8		      tay
    560  4346		       b9 60 f3 	      lda	walkOrder,y
    561  4349		       0a		      asl
    562  434a		       a8	   walk0      tay
    563  434b		       b9 64 f3 	      lda	walkFrame,y
    564  434e		       85 e1		      sta	digitstar
    565  4350		       b9 65 f3 	      lda	walkFrame+1,y
    566  4353		       85 e2		      sta	digitstar+1
    567  4355
    568  4355
    569  4355		       b9 6c f3 	      lda	walkColour,y
    570  4358		       85 ef		      sta	manc
    571  435a		       b9 6d f3 	      lda	walkColour+1,y
    572  435d		       85 f0		      sta	manc+1
    573  435f		       60		      rts
    574  4360
    575  4360
    576  4360
    577  4360				  -	      if	0
    578  4360				  -	      OPTIONAL_PAGEBREAK	"colbk @levelScreen.asm", BIGDIG_SIZE
    579  4360				  -
    580  4360				  -colbk		; hardwired for 32 - will need manual changing
    581  4360				  -
    582  4360				  -.CRK       SET	256*$B2
    583  4360				  -.CGK       SET	256*$B2
    584  4360				  -.CBK       SET	256*$B2
    585  4360				  -
    586  4360				  -	      REPEAT	10
    587  4360				  -	      .byte	.CRK/256
    588  4360				  -	      .byte	.CBK/256
    589  4360				  -	      .byte	.CGK/256
    590  4360				  -
    591  4360				  -.CRK       SET	.CRK + 280	;135
    592  4360				  -.CGK       SET	.CGK + 280	;135
    593  4360				  -.CBK       SET	.CBK + 280	;135
    594  4360				  -	      REPEND
    595  4360				  -	      .byte	.CRK/256
    596  4360				  -	      .byte	.CBK/256
    597  4360				  -
    598  4360				  -	      CHECKPAGEX	colbk, "WARNING: colbk crosses page @levelScreen.asm"
    599  4360					      endif
    600  4360
    601  4360
    602  4360
    603  4360		       01 02 03 02 walkOrder  .byte.b	1,2,3,2
    604  4364				   walkFrame
    605  4364		       60 f7		      .word.w	LEFT_star0
    606  4366		       80 f7		      .word.w	LEFT_star1
    607  4368		       a0 f7		      .word.w	LEFT_star2
    608  436a		       c0 f7		      .word.w	LEFT_star3
    609  436c
    610  436c				   walkColour
    611  436c		       8b f3		      .word.w	mancolourPAL2
    612  436e		       74 f3		      .word.w	mancolourPAL
    613  4370		       8b f3		      .word.w	mancolourPAL2
    614  4372		       74 f3		      .word.w	mancolourPAL
    615  4374
    616  4374
    617  4374				   mancolourPAL
    618  4374							; NTSC_TO_PAL $10, 4
      0  4374					      NTSC_TO_PAL	$10, 4
      1  4374				  -	      IF	$10 = 0
      2  4374				  -	      .byte	$10+4
      3  4374					      ENDIF
      4  4374					      IF	$10 = $10
      5  4374		       24		      .byte.b	$20+4
      6  4375					      ENDIF
      7  4375				  -	      IF	$10 = $20
      8  4375				  -	      .byte	$40+4
      9  4375					      ENDIF
     10  4375				  -	      IF	$10 = $30
     11  4375				  -	      .byte	$40+4
     12  4375					      ENDIF
     13  4375				  -	      IF	$10 = $40
     14  4375				  -	      .byte	$60+4
     15  4375					      ENDIF
     16  4375				  -	      IF	$10 = $50
     17  4375				  -	      .byte	$80+4
     18  4375					      ENDIF
     19  4375				  -	      IF	$10 = $60
     20  4375				  -	      .byte	$C0+4
     21  4375					      ENDIF
     22  4375				  -	      IF	$10 = $70
     23  4375				  -	      .byte	$D0+4
     24  4375					      ENDIF
     25  4375				  -	      IF	$10 = $80
     26  4375				  -	      .byte	$B0+4
     27  4375					      ENDIF
     28  4375				  -	      IF	$10 = $90
     29  4375				  -	      .byte	$90+4
     30  4375					      ENDIF
     31  4375				  -	      IF	$10 = $A0
     32  4375				  -	      .byte	$70+4
     33  4375					      ENDIF
     34  4375				  -	      IF	$10 = $B0
     35  4375				  -	      .byte	$50+4
     36  4375					      ENDIF
     37  4375				  -	      IF	$10 = $C0
     38  4375				  -	      .byte	$30+4
     39  4375					      ENDIF
     40  4375				  -	      IF	$10 = $D0
     41  4375				  -	      .byte	$30+4
     42  4375					      ENDIF
     43  4375				  -	      IF	$10 = $E0
     44  4375				  -	      .byte	$20+4
     45  4375					      ENDIF
     46  4375				  -	      IF	$10 = $F0
     47  4375				  -	      .byte	$40+4
     48  4375					      ENDIF
      0  4375					      NTSC_TO_PAL	$10, 4
      1  4375				  -	      IF	$10 = 0
      2  4375				  -	      .byte	$10+4
      3  4375					      ENDIF
      4  4375					      IF	$10 = $10
      5  4375		       24		      .byte.b	$20+4
      6  4376					      ENDIF
      7  4376				  -	      IF	$10 = $20
      8  4376				  -	      .byte	$40+4
      9  4376					      ENDIF
     10  4376				  -	      IF	$10 = $30
     11  4376				  -	      .byte	$40+4
     12  4376					      ENDIF
     13  4376				  -	      IF	$10 = $40
     14  4376				  -	      .byte	$60+4
     15  4376					      ENDIF
     16  4376				  -	      IF	$10 = $50
     17  4376				  -	      .byte	$80+4
     18  4376					      ENDIF
     19  4376				  -	      IF	$10 = $60
     20  4376				  -	      .byte	$C0+4
     21  4376					      ENDIF
     22  4376				  -	      IF	$10 = $70
     23  4376				  -	      .byte	$D0+4
     24  4376					      ENDIF
     25  4376				  -	      IF	$10 = $80
     26  4376				  -	      .byte	$B0+4
     27  4376					      ENDIF
     28  4376				  -	      IF	$10 = $90
     29  4376				  -	      .byte	$90+4
     30  4376					      ENDIF
     31  4376				  -	      IF	$10 = $A0
     32  4376				  -	      .byte	$70+4
     33  4376					      ENDIF
     34  4376				  -	      IF	$10 = $B0
     35  4376				  -	      .byte	$50+4
     36  4376					      ENDIF
     37  4376				  -	      IF	$10 = $C0
     38  4376				  -	      .byte	$30+4
     39  4376					      ENDIF
     40  4376				  -	      IF	$10 = $D0
     41  4376				  -	      .byte	$30+4
     42  4376					      ENDIF
     43  4376				  -	      IF	$10 = $E0
     44  4376				  -	      .byte	$20+4
     45  4376					      ENDIF
     46  4376				  -	      IF	$10 = $F0
     47  4376				  -	      .byte	$40+4
     48  4376					      ENDIF
      0  4376					      NTSC_TO_PAL	$90, 4
      1  4376				  -	      IF	$90 = 0
      2  4376				  -	      .byte	$90+4
      3  4376					      ENDIF
      4  4376				  -	      IF	$90 = $10
      5  4376				  -	      .byte	$20+4
      6  4376					      ENDIF
      7  4376				  -	      IF	$90 = $20
      8  4376				  -	      .byte	$40+4
      9  4376					      ENDIF
     10  4376				  -	      IF	$90 = $30
     11  4376				  -	      .byte	$40+4
     12  4376					      ENDIF
     13  4376				  -	      IF	$90 = $40
     14  4376				  -	      .byte	$60+4
     15  4376					      ENDIF
     16  4376				  -	      IF	$90 = $50
     17  4376				  -	      .byte	$80+4
     18  4376					      ENDIF
     19  4376				  -	      IF	$90 = $60
     20  4376				  -	      .byte	$C0+4
     21  4376					      ENDIF
     22  4376				  -	      IF	$90 = $70
     23  4376				  -	      .byte	$D0+4
     24  4376					      ENDIF
     25  4376				  -	      IF	$90 = $80
     26  4376				  -	      .byte	$B0+4
     27  4376					      ENDIF
     28  4376					      IF	$90 = $90
     29  4376		       94		      .byte.b	$90+4
     30  4377					      ENDIF
     31  4377				  -	      IF	$90 = $A0
     32  4377				  -	      .byte	$70+4
     33  4377					      ENDIF
     34  4377				  -	      IF	$90 = $B0
     35  4377				  -	      .byte	$50+4
     36  4377					      ENDIF
     37  4377				  -	      IF	$90 = $C0
     38  4377				  -	      .byte	$30+4
     39  4377					      ENDIF
     40  4377				  -	      IF	$90 = $D0
     41  4377				  -	      .byte	$30+4
     42  4377					      ENDIF
     43  4377				  -	      IF	$90 = $E0
     44  4377				  -	      .byte	$20+4
     45  4377					      ENDIF
     46  4377				  -	      IF	$90 = $F0
     47  4377				  -	      .byte	$40+4
     48  4377					      ENDIF
      0  4377					      NTSC_TO_PAL	$90, 4
      1  4377				  -	      IF	$90 = 0
      2  4377				  -	      .byte	$90+4
      3  4377					      ENDIF
      4  4377				  -	      IF	$90 = $10
      5  4377				  -	      .byte	$20+4
      6  4377					      ENDIF
      7  4377				  -	      IF	$90 = $20
      8  4377				  -	      .byte	$40+4
      9  4377					      ENDIF
     10  4377				  -	      IF	$90 = $30
     11  4377				  -	      .byte	$40+4
     12  4377					      ENDIF
     13  4377				  -	      IF	$90 = $40
     14  4377				  -	      .byte	$60+4
     15  4377					      ENDIF
     16  4377				  -	      IF	$90 = $50
     17  4377				  -	      .byte	$80+4
     18  4377					      ENDIF
     19  4377				  -	      IF	$90 = $60
     20  4377				  -	      .byte	$C0+4
     21  4377					      ENDIF
     22  4377				  -	      IF	$90 = $70
     23  4377				  -	      .byte	$D0+4
     24  4377					      ENDIF
     25  4377				  -	      IF	$90 = $80
     26  4377				  -	      .byte	$B0+4
     27  4377					      ENDIF
     28  4377					      IF	$90 = $90
     29  4377		       94		      .byte.b	$90+4
     30  4378					      ENDIF
     31  4378				  -	      IF	$90 = $A0
     32  4378				  -	      .byte	$70+4
     33  4378					      ENDIF
     34  4378				  -	      IF	$90 = $B0
     35  4378				  -	      .byte	$50+4
     36  4378					      ENDIF
     37  4378				  -	      IF	$90 = $C0
     38  4378				  -	      .byte	$30+4
     39  4378					      ENDIF
     40  4378				  -	      IF	$90 = $D0
     41  4378				  -	      .byte	$30+4
     42  4378					      ENDIF
     43  4378				  -	      IF	$90 = $E0
     44  4378				  -	      .byte	$20+4
     45  4378					      ENDIF
     46  4378				  -	      IF	$90 = $F0
     47  4378				  -	      .byte	$40+4
     48  4378					      ENDIF
      0  4378					      NTSC_TO_PAL	$90, 4
      1  4378				  -	      IF	$90 = 0
      2  4378				  -	      .byte	$90+4
      3  4378					      ENDIF
      4  4378				  -	      IF	$90 = $10
      5  4378				  -	      .byte	$20+4
      6  4378					      ENDIF
      7  4378				  -	      IF	$90 = $20
      8  4378				  -	      .byte	$40+4
      9  4378					      ENDIF
     10  4378				  -	      IF	$90 = $30
     11  4378				  -	      .byte	$40+4
     12  4378					      ENDIF
     13  4378				  -	      IF	$90 = $40
     14  4378				  -	      .byte	$60+4
     15  4378					      ENDIF
     16  4378				  -	      IF	$90 = $50
     17  4378				  -	      .byte	$80+4
     18  4378					      ENDIF
     19  4378				  -	      IF	$90 = $60
     20  4378				  -	      .byte	$C0+4
     21  4378					      ENDIF
     22  4378				  -	      IF	$90 = $70
     23  4378				  -	      .byte	$D0+4
     24  4378					      ENDIF
     25  4378				  -	      IF	$90 = $80
     26  4378				  -	      .byte	$B0+4
     27  4378					      ENDIF
     28  4378					      IF	$90 = $90
     29  4378		       94		      .byte.b	$90+4
     30  4379					      ENDIF
     31  4379				  -	      IF	$90 = $A0
     32  4379				  -	      .byte	$70+4
     33  4379					      ENDIF
     34  4379				  -	      IF	$90 = $B0
     35  4379				  -	      .byte	$50+4
     36  4379					      ENDIF
     37  4379				  -	      IF	$90 = $C0
     38  4379				  -	      .byte	$30+4
     39  4379					      ENDIF
     40  4379				  -	      IF	$90 = $D0
     41  4379				  -	      .byte	$30+4
     42  4379					      ENDIF
     43  4379				  -	      IF	$90 = $E0
     44  4379				  -	      .byte	$20+4
     45  4379					      ENDIF
     46  4379				  -	      IF	$90 = $F0
     47  4379				  -	      .byte	$40+4
     48  4379					      ENDIF
      0  4379					      NTSC_TO_PAL	$90, 4
      1  4379				  -	      IF	$90 = 0
      2  4379				  -	      .byte	$90+4
      3  4379					      ENDIF
      4  4379				  -	      IF	$90 = $10
      5  4379				  -	      .byte	$20+4
      6  4379					      ENDIF
      7  4379				  -	      IF	$90 = $20
      8  4379				  -	      .byte	$40+4
      9  4379					      ENDIF
     10  4379				  -	      IF	$90 = $30
     11  4379				  -	      .byte	$40+4
     12  4379					      ENDIF
     13  4379				  -	      IF	$90 = $40
     14  4379				  -	      .byte	$60+4
     15  4379					      ENDIF
     16  4379				  -	      IF	$90 = $50
     17  4379				  -	      .byte	$80+4
     18  4379					      ENDIF
     19  4379				  -	      IF	$90 = $60
     20  4379				  -	      .byte	$C0+4
     21  4379					      ENDIF
     22  4379				  -	      IF	$90 = $70
     23  4379				  -	      .byte	$D0+4
     24  4379					      ENDIF
     25  4379				  -	      IF	$90 = $80
     26  4379				  -	      .byte	$B0+4
     27  4379					      ENDIF
     28  4379					      IF	$90 = $90
     29  4379		       94		      .byte.b	$90+4
     30  437a					      ENDIF
     31  437a				  -	      IF	$90 = $A0
     32  437a				  -	      .byte	$70+4
     33  437a					      ENDIF
     34  437a				  -	      IF	$90 = $B0
     35  437a				  -	      .byte	$50+4
     36  437a					      ENDIF
     37  437a				  -	      IF	$90 = $C0
     38  437a				  -	      .byte	$30+4
     39  437a					      ENDIF
     40  437a				  -	      IF	$90 = $D0
     41  437a				  -	      .byte	$30+4
     42  437a					      ENDIF
     43  437a				  -	      IF	$90 = $E0
     44  437a				  -	      .byte	$20+4
     45  437a					      ENDIF
     46  437a				  -	      IF	$90 = $F0
     47  437a				  -	      .byte	$40+4
     48  437a					      ENDIF
      0  437a					      NTSC_TO_PAL	$90, 4
      1  437a				  -	      IF	$90 = 0
      2  437a				  -	      .byte	$90+4
      3  437a					      ENDIF
      4  437a				  -	      IF	$90 = $10
      5  437a				  -	      .byte	$20+4
      6  437a					      ENDIF
      7  437a				  -	      IF	$90 = $20
      8  437a				  -	      .byte	$40+4
      9  437a					      ENDIF
     10  437a				  -	      IF	$90 = $30
     11  437a				  -	      .byte	$40+4
     12  437a					      ENDIF
     13  437a				  -	      IF	$90 = $40
     14  437a				  -	      .byte	$60+4
     15  437a					      ENDIF
     16  437a				  -	      IF	$90 = $50
     17  437a				  -	      .byte	$80+4
     18  437a					      ENDIF
     19  437a				  -	      IF	$90 = $60
     20  437a				  -	      .byte	$C0+4
     21  437a					      ENDIF
     22  437a				  -	      IF	$90 = $70
     23  437a				  -	      .byte	$D0+4
     24  437a					      ENDIF
     25  437a				  -	      IF	$90 = $80
     26  437a				  -	      .byte	$B0+4
     27  437a					      ENDIF
     28  437a					      IF	$90 = $90
     29  437a		       94		      .byte.b	$90+4
     30  437b					      ENDIF
     31  437b				  -	      IF	$90 = $A0
     32  437b				  -	      .byte	$70+4
     33  437b					      ENDIF
     34  437b				  -	      IF	$90 = $B0
     35  437b				  -	      .byte	$50+4
     36  437b					      ENDIF
     37  437b				  -	      IF	$90 = $C0
     38  437b				  -	      .byte	$30+4
     39  437b					      ENDIF
     40  437b				  -	      IF	$90 = $D0
     41  437b				  -	      .byte	$30+4
     42  437b					      ENDIF
     43  437b				  -	      IF	$90 = $E0
     44  437b				  -	      .byte	$20+4
     45  437b					      ENDIF
     46  437b				  -	      IF	$90 = $F0
     47  437b				  -	      .byte	$40+4
     48  437b					      ENDIF
      0  437b					      NTSC_TO_PAL	$30, 4
      1  437b				  -	      IF	$30 = 0
      2  437b				  -	      .byte	$30+4
      3  437b					      ENDIF
      4  437b				  -	      IF	$30 = $10
      5  437b				  -	      .byte	$20+4
      6  437b					      ENDIF
      7  437b				  -	      IF	$30 = $20
      8  437b				  -	      .byte	$40+4
      9  437b					      ENDIF
     10  437b					      IF	$30 = $30
     11  437b		       44		      .byte.b	$40+4
     12  437c					      ENDIF
     13  437c				  -	      IF	$30 = $40
     14  437c				  -	      .byte	$60+4
     15  437c					      ENDIF
     16  437c				  -	      IF	$30 = $50
     17  437c				  -	      .byte	$80+4
     18  437c					      ENDIF
     19  437c				  -	      IF	$30 = $60
     20  437c				  -	      .byte	$C0+4
     21  437c					      ENDIF
     22  437c				  -	      IF	$30 = $70
     23  437c				  -	      .byte	$D0+4
     24  437c					      ENDIF
     25  437c				  -	      IF	$30 = $80
     26  437c				  -	      .byte	$B0+4
     27  437c					      ENDIF
     28  437c				  -	      IF	$30 = $90
     29  437c				  -	      .byte	$90+4
     30  437c					      ENDIF
     31  437c				  -	      IF	$30 = $A0
     32  437c				  -	      .byte	$70+4
     33  437c					      ENDIF
     34  437c				  -	      IF	$30 = $B0
     35  437c				  -	      .byte	$50+4
     36  437c					      ENDIF
     37  437c				  -	      IF	$30 = $C0
     38  437c				  -	      .byte	$30+4
     39  437c					      ENDIF
     40  437c				  -	      IF	$30 = $D0
     41  437c				  -	      .byte	$30+4
     42  437c					      ENDIF
     43  437c				  -	      IF	$30 = $E0
     44  437c				  -	      .byte	$20+4
     45  437c					      ENDIF
     46  437c				  -	      IF	$30 = $F0
     47  437c				  -	      .byte	$40+4
     48  437c					      ENDIF
      0  437c					      NTSC_TO_PAL	$0, 12
      1  437c					      IF	$0 = 0
      2  437c		       0c		      .byte.b	$0+12
      3  437d					      ENDIF
      4  437d				  -	      IF	$0 = $10
      5  437d				  -	      .byte	$20+12
      6  437d					      ENDIF
      7  437d				  -	      IF	$0 = $20
      8  437d				  -	      .byte	$40+12
      9  437d					      ENDIF
     10  437d				  -	      IF	$0 = $30
     11  437d				  -	      .byte	$40+12
     12  437d					      ENDIF
     13  437d				  -	      IF	$0 = $40
     14  437d				  -	      .byte	$60+12
     15  437d					      ENDIF
     16  437d				  -	      IF	$0 = $50
     17  437d				  -	      .byte	$80+12
     18  437d					      ENDIF
     19  437d				  -	      IF	$0 = $60
     20  437d				  -	      .byte	$C0+12
     21  437d					      ENDIF
     22  437d				  -	      IF	$0 = $70
     23  437d				  -	      .byte	$D0+12
     24  437d					      ENDIF
     25  437d				  -	      IF	$0 = $80
     26  437d				  -	      .byte	$B0+12
     27  437d					      ENDIF
     28  437d				  -	      IF	$0 = $90
     29  437d				  -	      .byte	$90+12
     30  437d					      ENDIF
     31  437d				  -	      IF	$0 = $A0
     32  437d				  -	      .byte	$70+12
     33  437d					      ENDIF
     34  437d				  -	      IF	$0 = $B0
     35  437d				  -	      .byte	$50+12
     36  437d					      ENDIF
     37  437d				  -	      IF	$0 = $C0
     38  437d				  -	      .byte	$30+12
     39  437d					      ENDIF
     40  437d				  -	      IF	$0 = $D0
     41  437d				  -	      .byte	$30+12
     42  437d					      ENDIF
     43  437d				  -	      IF	$0 = $E0
     44  437d				  -	      .byte	$20+12
     45  437d					      ENDIF
     46  437d				  -	      IF	$0 = $F0
     47  437d				  -	      .byte	$40+12
     48  437d					      ENDIF
      0  437d					      NTSC_TO_PAL	$90, 6
      1  437d				  -	      IF	$90 = 0
      2  437d				  -	      .byte	$90+6
      3  437d					      ENDIF
      4  437d				  -	      IF	$90 = $10
      5  437d				  -	      .byte	$20+6
      6  437d					      ENDIF
      7  437d				  -	      IF	$90 = $20
      8  437d				  -	      .byte	$40+6
      9  437d					      ENDIF
     10  437d				  -	      IF	$90 = $30
     11  437d				  -	      .byte	$40+6
     12  437d					      ENDIF
     13  437d				  -	      IF	$90 = $40
     14  437d				  -	      .byte	$60+6
     15  437d					      ENDIF
     16  437d				  -	      IF	$90 = $50
     17  437d				  -	      .byte	$80+6
     18  437d					      ENDIF
     19  437d				  -	      IF	$90 = $60
     20  437d				  -	      .byte	$C0+6
     21  437d					      ENDIF
     22  437d				  -	      IF	$90 = $70
     23  437d				  -	      .byte	$D0+6
     24  437d					      ENDIF
     25  437d				  -	      IF	$90 = $80
     26  437d				  -	      .byte	$B0+6
     27  437d					      ENDIF
     28  437d					      IF	$90 = $90
     29  437d		       96		      .byte.b	$90+6
     30  437e					      ENDIF
     31  437e				  -	      IF	$90 = $A0
     32  437e				  -	      .byte	$70+6
     33  437e					      ENDIF
     34  437e				  -	      IF	$90 = $B0
     35  437e				  -	      .byte	$50+6
     36  437e					      ENDIF
     37  437e				  -	      IF	$90 = $C0
     38  437e				  -	      .byte	$30+6
     39  437e					      ENDIF
     40  437e				  -	      IF	$90 = $D0
     41  437e				  -	      .byte	$30+6
     42  437e					      ENDIF
     43  437e				  -	      IF	$90 = $E0
     44  437e				  -	      .byte	$20+6
     45  437e					      ENDIF
     46  437e				  -	      IF	$90 = $F0
     47  437e				  -	      .byte	$40+6
     48  437e					      ENDIF
      0  437e					      NTSC_TO_PAL	$90, 6
      1  437e				  -	      IF	$90 = 0
      2  437e				  -	      .byte	$90+6
      3  437e					      ENDIF
      4  437e				  -	      IF	$90 = $10
      5  437e				  -	      .byte	$20+6
      6  437e					      ENDIF
      7  437e				  -	      IF	$90 = $20
      8  437e				  -	      .byte	$40+6
      9  437e					      ENDIF
     10  437e				  -	      IF	$90 = $30
     11  437e				  -	      .byte	$40+6
     12  437e					      ENDIF
     13  437e				  -	      IF	$90 = $40
     14  437e				  -	      .byte	$60+6
     15  437e					      ENDIF
     16  437e				  -	      IF	$90 = $50
     17  437e				  -	      .byte	$80+6
     18  437e					      ENDIF
     19  437e				  -	      IF	$90 = $60
     20  437e				  -	      .byte	$C0+6
     21  437e					      ENDIF
     22  437e				  -	      IF	$90 = $70
     23  437e				  -	      .byte	$D0+6
     24  437e					      ENDIF
     25  437e				  -	      IF	$90 = $80
     26  437e				  -	      .byte	$B0+6
     27  437e					      ENDIF
     28  437e					      IF	$90 = $90
     29  437e		       96		      .byte.b	$90+6
     30  437f					      ENDIF
     31  437f				  -	      IF	$90 = $A0
     32  437f				  -	      .byte	$70+6
     33  437f					      ENDIF
     34  437f				  -	      IF	$90 = $B0
     35  437f				  -	      .byte	$50+6
     36  437f					      ENDIF
     37  437f				  -	      IF	$90 = $C0
     38  437f				  -	      .byte	$30+6
     39  437f					      ENDIF
     40  437f				  -	      IF	$90 = $D0
     41  437f				  -	      .byte	$30+6
     42  437f					      ENDIF
     43  437f				  -	      IF	$90 = $E0
     44  437f				  -	      .byte	$20+6
     45  437f					      ENDIF
     46  437f				  -	      IF	$90 = $F0
     47  437f				  -	      .byte	$40+6
     48  437f					      ENDIF
      0  437f					      NTSC_TO_PAL	$90, 6
      1  437f				  -	      IF	$90 = 0
      2  437f				  -	      .byte	$90+6
      3  437f					      ENDIF
      4  437f				  -	      IF	$90 = $10
      5  437f				  -	      .byte	$20+6
      6  437f					      ENDIF
      7  437f				  -	      IF	$90 = $20
      8  437f				  -	      .byte	$40+6
      9  437f					      ENDIF
     10  437f				  -	      IF	$90 = $30
     11  437f				  -	      .byte	$40+6
     12  437f					      ENDIF
     13  437f				  -	      IF	$90 = $40
     14  437f				  -	      .byte	$60+6
     15  437f					      ENDIF
     16  437f				  -	      IF	$90 = $50
     17  437f				  -	      .byte	$80+6
     18  437f					      ENDIF
     19  437f				  -	      IF	$90 = $60
     20  437f				  -	      .byte	$C0+6
     21  437f					      ENDIF
     22  437f				  -	      IF	$90 = $70
     23  437f				  -	      .byte	$D0+6
     24  437f					      ENDIF
     25  437f				  -	      IF	$90 = $80
     26  437f				  -	      .byte	$B0+6
     27  437f					      ENDIF
     28  437f					      IF	$90 = $90
     29  437f		       96		      .byte.b	$90+6
     30  4380					      ENDIF
     31  4380				  -	      IF	$90 = $A0
     32  4380				  -	      .byte	$70+6
     33  4380					      ENDIF
     34  4380				  -	      IF	$90 = $B0
     35  4380				  -	      .byte	$50+6
     36  4380					      ENDIF
     37  4380				  -	      IF	$90 = $C0
     38  4380				  -	      .byte	$30+6
     39  4380					      ENDIF
     40  4380				  -	      IF	$90 = $D0
     41  4380				  -	      .byte	$30+6
     42  4380					      ENDIF
     43  4380				  -	      IF	$90 = $E0
     44  4380				  -	      .byte	$20+6
     45  4380					      ENDIF
     46  4380				  -	      IF	$90 = $F0
     47  4380				  -	      .byte	$40+6
     48  4380					      ENDIF
      0  4380					      NTSC_TO_PAL	$90, 6
      1  4380				  -	      IF	$90 = 0
      2  4380				  -	      .byte	$90+6
      3  4380					      ENDIF
      4  4380				  -	      IF	$90 = $10
      5  4380				  -	      .byte	$20+6
      6  4380					      ENDIF
      7  4380				  -	      IF	$90 = $20
      8  4380				  -	      .byte	$40+6
      9  4380					      ENDIF
     10  4380				  -	      IF	$90 = $30
     11  4380				  -	      .byte	$40+6
     12  4380					      ENDIF
     13  4380				  -	      IF	$90 = $40
     14  4380				  -	      .byte	$60+6
     15  4380					      ENDIF
     16  4380				  -	      IF	$90 = $50
     17  4380				  -	      .byte	$80+6
     18  4380					      ENDIF
     19  4380				  -	      IF	$90 = $60
     20  4380				  -	      .byte	$C0+6
     21  4380					      ENDIF
     22  4380				  -	      IF	$90 = $70
     23  4380				  -	      .byte	$D0+6
     24  4380					      ENDIF
     25  4380				  -	      IF	$90 = $80
     26  4380				  -	      .byte	$B0+6
     27  4380					      ENDIF
     28  4380					      IF	$90 = $90
     29  4380		       96		      .byte.b	$90+6
     30  4381					      ENDIF
     31  4381				  -	      IF	$90 = $A0
     32  4381				  -	      .byte	$70+6
     33  4381					      ENDIF
     34  4381				  -	      IF	$90 = $B0
     35  4381				  -	      .byte	$50+6
     36  4381					      ENDIF
     37  4381				  -	      IF	$90 = $C0
     38  4381				  -	      .byte	$30+6
     39  4381					      ENDIF
     40  4381				  -	      IF	$90 = $D0
     41  4381				  -	      .byte	$30+6
     42  4381					      ENDIF
     43  4381				  -	      IF	$90 = $E0
     44  4381				  -	      .byte	$20+6
     45  4381					      ENDIF
     46  4381				  -	      IF	$90 = $F0
     47  4381				  -	      .byte	$40+6
     48  4381					      ENDIF
      0  4381					      NTSC_TO_PAL	$90, 6
      1  4381				  -	      IF	$90 = 0
      2  4381				  -	      .byte	$90+6
      3  4381					      ENDIF
      4  4381				  -	      IF	$90 = $10
      5  4381				  -	      .byte	$20+6
      6  4381					      ENDIF
      7  4381				  -	      IF	$90 = $20
      8  4381				  -	      .byte	$40+6
      9  4381					      ENDIF
     10  4381				  -	      IF	$90 = $30
     11  4381				  -	      .byte	$40+6
     12  4381					      ENDIF
     13  4381				  -	      IF	$90 = $40
     14  4381				  -	      .byte	$60+6
     15  4381					      ENDIF
     16  4381				  -	      IF	$90 = $50
     17  4381				  -	      .byte	$80+6
     18  4381					      ENDIF
     19  4381				  -	      IF	$90 = $60
     20  4381				  -	      .byte	$C0+6
     21  4381					      ENDIF
     22  4381				  -	      IF	$90 = $70
     23  4381				  -	      .byte	$D0+6
     24  4381					      ENDIF
     25  4381				  -	      IF	$90 = $80
     26  4381				  -	      .byte	$B0+6
     27  4381					      ENDIF
     28  4381					      IF	$90 = $90
     29  4381		       96		      .byte.b	$90+6
     30  4382					      ENDIF
     31  4382				  -	      IF	$90 = $A0
     32  4382				  -	      .byte	$70+6
     33  4382					      ENDIF
     34  4382				  -	      IF	$90 = $B0
     35  4382				  -	      .byte	$50+6
     36  4382					      ENDIF
     37  4382				  -	      IF	$90 = $C0
     38  4382				  -	      .byte	$30+6
     39  4382					      ENDIF
     40  4382				  -	      IF	$90 = $D0
     41  4382				  -	      .byte	$30+6
     42  4382					      ENDIF
     43  4382				  -	      IF	$90 = $E0
     44  4382				  -	      .byte	$20+6
     45  4382					      ENDIF
     46  4382				  -	      IF	$90 = $F0
     47  4382				  -	      .byte	$40+6
     48  4382					      ENDIF
      0  4382					      NTSC_TO_PAL	$0, 12
      1  4382					      IF	$0 = 0
      2  4382		       0c		      .byte.b	$0+12
      3  4383					      ENDIF
      4  4383				  -	      IF	$0 = $10
      5  4383				  -	      .byte	$20+12
      6  4383					      ENDIF
      7  4383				  -	      IF	$0 = $20
      8  4383				  -	      .byte	$40+12
      9  4383					      ENDIF
     10  4383				  -	      IF	$0 = $30
     11  4383				  -	      .byte	$40+12
     12  4383					      ENDIF
     13  4383				  -	      IF	$0 = $40
     14  4383				  -	      .byte	$60+12
     15  4383					      ENDIF
     16  4383				  -	      IF	$0 = $50
     17  4383				  -	      .byte	$80+12
     18  4383					      ENDIF
     19  4383				  -	      IF	$0 = $60
     20  4383				  -	      .byte	$C0+12
     21  4383					      ENDIF
     22  4383				  -	      IF	$0 = $70
     23  4383				  -	      .byte	$D0+12
     24  4383					      ENDIF
     25  4383				  -	      IF	$0 = $80
     26  4383				  -	      .byte	$B0+12
     27  4383					      ENDIF
     28  4383				  -	      IF	$0 = $90
     29  4383				  -	      .byte	$90+12
     30  4383					      ENDIF
     31  4383				  -	      IF	$0 = $A0
     32  4383				  -	      .byte	$70+12
     33  4383					      ENDIF
     34  4383				  -	      IF	$0 = $B0
     35  4383				  -	      .byte	$50+12
     36  4383					      ENDIF
     37  4383				  -	      IF	$0 = $C0
     38  4383				  -	      .byte	$30+12
     39  4383					      ENDIF
     40  4383				  -	      IF	$0 = $D0
     41  4383				  -	      .byte	$30+12
     42  4383					      ENDIF
     43  4383				  -	      IF	$0 = $E0
     44  4383				  -	      .byte	$20+12
     45  4383					      ENDIF
     46  4383				  -	      IF	$0 = $F0
     47  4383				  -	      .byte	$40+12
     48  4383					      ENDIF
      0  4383					      NTSC_TO_PAL	$30, 8
      1  4383				  -	      IF	$30 = 0
      2  4383				  -	      .byte	$30+8
      3  4383					      ENDIF
      4  4383				  -	      IF	$30 = $10
      5  4383				  -	      .byte	$20+8
      6  4383					      ENDIF
      7  4383				  -	      IF	$30 = $20
      8  4383				  -	      .byte	$40+8
      9  4383					      ENDIF
     10  4383					      IF	$30 = $30
     11  4383		       48		      .byte.b	$40+8
     12  4384					      ENDIF
     13  4384				  -	      IF	$30 = $40
     14  4384				  -	      .byte	$60+8
     15  4384					      ENDIF
     16  4384				  -	      IF	$30 = $50
     17  4384				  -	      .byte	$80+8
     18  4384					      ENDIF
     19  4384				  -	      IF	$30 = $60
     20  4384				  -	      .byte	$C0+8
     21  4384					      ENDIF
     22  4384				  -	      IF	$30 = $70
     23  4384				  -	      .byte	$D0+8
     24  4384					      ENDIF
     25  4384				  -	      IF	$30 = $80
     26  4384				  -	      .byte	$B0+8
     27  4384					      ENDIF
     28  4384				  -	      IF	$30 = $90
     29  4384				  -	      .byte	$90+8
     30  4384					      ENDIF
     31  4384				  -	      IF	$30 = $A0
     32  4384				  -	      .byte	$70+8
     33  4384					      ENDIF
     34  4384				  -	      IF	$30 = $B0
     35  4384				  -	      .byte	$50+8
     36  4384					      ENDIF
     37  4384				  -	      IF	$30 = $C0
     38  4384				  -	      .byte	$30+8
     39  4384					      ENDIF
     40  4384				  -	      IF	$30 = $D0
     41  4384				  -	      .byte	$30+8
     42  4384					      ENDIF
     43  4384				  -	      IF	$30 = $E0
     44  4384				  -	      .byte	$20+8
     45  4384					      ENDIF
     46  4384				  -	      IF	$30 = $F0
     47  4384				  -	      .byte	$40+8
     48  4384					      ENDIF
      0  4384					      NTSC_TO_PAL	$30, 8
      1  4384				  -	      IF	$30 = 0
      2  4384				  -	      .byte	$30+8
      3  4384					      ENDIF
      4  4384				  -	      IF	$30 = $10
      5  4384				  -	      .byte	$20+8
      6  4384					      ENDIF
      7  4384				  -	      IF	$30 = $20
      8  4384				  -	      .byte	$40+8
      9  4384					      ENDIF
     10  4384					      IF	$30 = $30
     11  4384		       48		      .byte.b	$40+8
     12  4385					      ENDIF
     13  4385				  -	      IF	$30 = $40
     14  4385				  -	      .byte	$60+8
     15  4385					      ENDIF
     16  4385				  -	      IF	$30 = $50
     17  4385				  -	      .byte	$80+8
     18  4385					      ENDIF
     19  4385				  -	      IF	$30 = $60
     20  4385				  -	      .byte	$C0+8
     21  4385					      ENDIF
     22  4385				  -	      IF	$30 = $70
     23  4385				  -	      .byte	$D0+8
     24  4385					      ENDIF
     25  4385				  -	      IF	$30 = $80
     26  4385				  -	      .byte	$B0+8
     27  4385					      ENDIF
     28  4385				  -	      IF	$30 = $90
     29  4385				  -	      .byte	$90+8
     30  4385					      ENDIF
     31  4385				  -	      IF	$30 = $A0
     32  4385				  -	      .byte	$70+8
     33  4385					      ENDIF
     34  4385				  -	      IF	$30 = $B0
     35  4385				  -	      .byte	$50+8
     36  4385					      ENDIF
     37  4385				  -	      IF	$30 = $C0
     38  4385				  -	      .byte	$30+8
     39  4385					      ENDIF
     40  4385				  -	      IF	$30 = $D0
     41  4385				  -	      .byte	$30+8
     42  4385					      ENDIF
     43  4385				  -	      IF	$30 = $E0
     44  4385				  -	      .byte	$20+8
     45  4385					      ENDIF
     46  4385				  -	      IF	$30 = $F0
     47  4385				  -	      .byte	$40+8
     48  4385					      ENDIF
      0  4385					      NTSC_TO_PAL	$30, 8
      1  4385				  -	      IF	$30 = 0
      2  4385				  -	      .byte	$30+8
      3  4385					      ENDIF
      4  4385				  -	      IF	$30 = $10
      5  4385				  -	      .byte	$20+8
      6  4385					      ENDIF
      7  4385				  -	      IF	$30 = $20
      8  4385				  -	      .byte	$40+8
      9  4385					      ENDIF
     10  4385					      IF	$30 = $30
     11  4385		       48		      .byte.b	$40+8
     12  4386					      ENDIF
     13  4386				  -	      IF	$30 = $40
     14  4386				  -	      .byte	$60+8
     15  4386					      ENDIF
     16  4386				  -	      IF	$30 = $50
     17  4386				  -	      .byte	$80+8
     18  4386					      ENDIF
     19  4386				  -	      IF	$30 = $60
     20  4386				  -	      .byte	$C0+8
     21  4386					      ENDIF
     22  4386				  -	      IF	$30 = $70
     23  4386				  -	      .byte	$D0+8
     24  4386					      ENDIF
     25  4386				  -	      IF	$30 = $80
     26  4386				  -	      .byte	$B0+8
     27  4386					      ENDIF
     28  4386				  -	      IF	$30 = $90
     29  4386				  -	      .byte	$90+8
     30  4386					      ENDIF
     31  4386				  -	      IF	$30 = $A0
     32  4386				  -	      .byte	$70+8
     33  4386					      ENDIF
     34  4386				  -	      IF	$30 = $B0
     35  4386				  -	      .byte	$50+8
     36  4386					      ENDIF
     37  4386				  -	      IF	$30 = $C0
     38  4386				  -	      .byte	$30+8
     39  4386					      ENDIF
     40  4386				  -	      IF	$30 = $D0
     41  4386				  -	      .byte	$30+8
     42  4386					      ENDIF
     43  4386				  -	      IF	$30 = $E0
     44  4386				  -	      .byte	$20+8
     45  4386					      ENDIF
     46  4386				  -	      IF	$30 = $F0
     47  4386				  -	      .byte	$40+8
     48  4386					      ENDIF
      0  4386					      NTSC_TO_PAL	$30, 8
      1  4386				  -	      IF	$30 = 0
      2  4386				  -	      .byte	$30+8
      3  4386					      ENDIF
      4  4386				  -	      IF	$30 = $10
      5  4386				  -	      .byte	$20+8
      6  4386					      ENDIF
      7  4386				  -	      IF	$30 = $20
      8  4386				  -	      .byte	$40+8
      9  4386					      ENDIF
     10  4386					      IF	$30 = $30
     11  4386		       48		      .byte.b	$40+8
     12  4387					      ENDIF
     13  4387				  -	      IF	$30 = $40
     14  4387				  -	      .byte	$60+8
     15  4387					      ENDIF
     16  4387				  -	      IF	$30 = $50
     17  4387				  -	      .byte	$80+8
     18  4387					      ENDIF
     19  4387				  -	      IF	$30 = $60
     20  4387				  -	      .byte	$C0+8
     21  4387					      ENDIF
     22  4387				  -	      IF	$30 = $70
     23  4387				  -	      .byte	$D0+8
     24  4387					      ENDIF
     25  4387				  -	      IF	$30 = $80
     26  4387				  -	      .byte	$B0+8
     27  4387					      ENDIF
     28  4387				  -	      IF	$30 = $90
     29  4387				  -	      .byte	$90+8
     30  4387					      ENDIF
     31  4387				  -	      IF	$30 = $A0
     32  4387				  -	      .byte	$70+8
     33  4387					      ENDIF
     34  4387				  -	      IF	$30 = $B0
     35  4387				  -	      .byte	$50+8
     36  4387					      ENDIF
     37  4387				  -	      IF	$30 = $C0
     38  4387				  -	      .byte	$30+8
     39  4387					      ENDIF
     40  4387				  -	      IF	$30 = $D0
     41  4387				  -	      .byte	$30+8
     42  4387					      ENDIF
     43  4387				  -	      IF	$30 = $E0
     44  4387				  -	      .byte	$20+8
     45  4387					      ENDIF
     46  4387				  -	      IF	$30 = $F0
     47  4387				  -	      .byte	$40+8
     48  4387					      ENDIF
      0  4387					      NTSC_TO_PAL	$30, 8
      1  4387				  -	      IF	$30 = 0
      2  4387				  -	      .byte	$30+8
      3  4387					      ENDIF
      4  4387				  -	      IF	$30 = $10
      5  4387				  -	      .byte	$20+8
      6  4387					      ENDIF
      7  4387				  -	      IF	$30 = $20
      8  4387				  -	      .byte	$40+8
      9  4387					      ENDIF
     10  4387					      IF	$30 = $30
     11  4387		       48		      .byte.b	$40+8
     12  4388					      ENDIF
     13  4388				  -	      IF	$30 = $40
     14  4388				  -	      .byte	$60+8
     15  4388					      ENDIF
     16  4388				  -	      IF	$30 = $50
     17  4388				  -	      .byte	$80+8
     18  4388					      ENDIF
     19  4388				  -	      IF	$30 = $60
     20  4388				  -	      .byte	$C0+8
     21  4388					      ENDIF
     22  4388				  -	      IF	$30 = $70
     23  4388				  -	      .byte	$D0+8
     24  4388					      ENDIF
     25  4388				  -	      IF	$30 = $80
     26  4388				  -	      .byte	$B0+8
     27  4388					      ENDIF
     28  4388				  -	      IF	$30 = $90
     29  4388				  -	      .byte	$90+8
     30  4388					      ENDIF
     31  4388				  -	      IF	$30 = $A0
     32  4388				  -	      .byte	$70+8
     33  4388					      ENDIF
     34  4388				  -	      IF	$30 = $B0
     35  4388				  -	      .byte	$50+8
     36  4388					      ENDIF
     37  4388				  -	      IF	$30 = $C0
     38  4388				  -	      .byte	$30+8
     39  4388					      ENDIF
     40  4388				  -	      IF	$30 = $D0
     41  4388				  -	      .byte	$30+8
     42  4388					      ENDIF
     43  4388				  -	      IF	$30 = $E0
     44  4388				  -	      .byte	$20+8
     45  4388					      ENDIF
     46  4388				  -	      IF	$30 = $F0
     47  4388				  -	      .byte	$40+8
     48  4388					      ENDIF
      0  4388					      NTSC_TO_PAL	$30, 8
      1  4388				  -	      IF	$30 = 0
      2  4388				  -	      .byte	$30+8
      3  4388					      ENDIF
      4  4388				  -	      IF	$30 = $10
      5  4388				  -	      .byte	$20+8
      6  4388					      ENDIF
      7  4388				  -	      IF	$30 = $20
      8  4388				  -	      .byte	$40+8
      9  4388					      ENDIF
     10  4388					      IF	$30 = $30
     11  4388		       48		      .byte.b	$40+8
     12  4389					      ENDIF
     13  4389				  -	      IF	$30 = $40
     14  4389				  -	      .byte	$60+8
     15  4389					      ENDIF
     16  4389				  -	      IF	$30 = $50
     17  4389				  -	      .byte	$80+8
     18  4389					      ENDIF
     19  4389				  -	      IF	$30 = $60
     20  4389				  -	      .byte	$C0+8
     21  4389					      ENDIF
     22  4389				  -	      IF	$30 = $70
     23  4389				  -	      .byte	$D0+8
     24  4389					      ENDIF
     25  4389				  -	      IF	$30 = $80
     26  4389				  -	      .byte	$B0+8
     27  4389					      ENDIF
     28  4389				  -	      IF	$30 = $90
     29  4389				  -	      .byte	$90+8
     30  4389					      ENDIF
     31  4389				  -	      IF	$30 = $A0
     32  4389				  -	      .byte	$70+8
     33  4389					      ENDIF
     34  4389				  -	      IF	$30 = $B0
     35  4389				  -	      .byte	$50+8
     36  4389					      ENDIF
     37  4389				  -	      IF	$30 = $C0
     38  4389				  -	      .byte	$30+8
     39  4389					      ENDIF
     40  4389				  -	      IF	$30 = $D0
     41  4389				  -	      .byte	$30+8
     42  4389					      ENDIF
     43  4389				  -	      IF	$30 = $E0
     44  4389				  -	      .byte	$20+8
     45  4389					      ENDIF
     46  4389				  -	      IF	$30 = $F0
     47  4389				  -	      .byte	$40+8
     48  4389					      ENDIF
      0  4389					      NTSC_TO_PAL	$10, $C
      1  4389				  -	      IF	$10 = 0
      2  4389				  -	      .byte	$10+$C
      3  4389					      ENDIF
      4  4389					      IF	$10 = $10
      5  4389		       2c		      .byte.b	$20+$C
      6  438a					      ENDIF
      7  438a				  -	      IF	$10 = $20
      8  438a				  -	      .byte	$40+$C
      9  438a					      ENDIF
     10  438a				  -	      IF	$10 = $30
     11  438a				  -	      .byte	$40+$C
     12  438a					      ENDIF
     13  438a				  -	      IF	$10 = $40
     14  438a				  -	      .byte	$60+$C
     15  438a					      ENDIF
     16  438a				  -	      IF	$10 = $50
     17  438a				  -	      .byte	$80+$C
     18  438a					      ENDIF
     19  438a				  -	      IF	$10 = $60
     20  438a				  -	      .byte	$C0+$C
     21  438a					      ENDIF
     22  438a				  -	      IF	$10 = $70
     23  438a				  -	      .byte	$D0+$C
     24  438a					      ENDIF
     25  438a				  -	      IF	$10 = $80
     26  438a				  -	      .byte	$B0+$C
     27  438a					      ENDIF
     28  438a				  -	      IF	$10 = $90
     29  438a				  -	      .byte	$90+$C
     30  438a					      ENDIF
     31  438a				  -	      IF	$10 = $A0
     32  438a				  -	      .byte	$70+$C
     33  438a					      ENDIF
     34  438a				  -	      IF	$10 = $B0
     35  438a				  -	      .byte	$50+$C
     36  438a					      ENDIF
     37  438a				  -	      IF	$10 = $C0
     38  438a				  -	      .byte	$30+$C
     39  438a					      ENDIF
     40  438a				  -	      IF	$10 = $D0
     41  438a				  -	      .byte	$30+$C
     42  438a					      ENDIF
     43  438a				  -	      IF	$10 = $E0
     44  438a				  -	      .byte	$20+$C
     45  438a					      ENDIF
     46  438a				  -	      IF	$10 = $F0
     47  438a				  -	      .byte	$40+$C
     48  438a					      ENDIF
      0  438a					      NTSC_TO_PAL	$10, $C
      1  438a				  -	      IF	$10 = 0
      2  438a				  -	      .byte	$10+$C
      3  438a					      ENDIF
      4  438a					      IF	$10 = $10
      5  438a		       2c		      .byte.b	$20+$C
      6  438b					      ENDIF
      7  438b				  -	      IF	$10 = $20
      8  438b				  -	      .byte	$40+$C
      9  438b					      ENDIF
     10  438b				  -	      IF	$10 = $30
     11  438b				  -	      .byte	$40+$C
     12  438b					      ENDIF
     13  438b				  -	      IF	$10 = $40
     14  438b				  -	      .byte	$60+$C
     15  438b					      ENDIF
     16  438b				  -	      IF	$10 = $50
     17  438b				  -	      .byte	$80+$C
     18  438b					      ENDIF
     19  438b				  -	      IF	$10 = $60
     20  438b				  -	      .byte	$C0+$C
     21  438b					      ENDIF
     22  438b				  -	      IF	$10 = $70
     23  438b				  -	      .byte	$D0+$C
     24  438b					      ENDIF
     25  438b				  -	      IF	$10 = $80
     26  438b				  -	      .byte	$B0+$C
     27  438b					      ENDIF
     28  438b				  -	      IF	$10 = $90
     29  438b				  -	      .byte	$90+$C
     30  438b					      ENDIF
     31  438b				  -	      IF	$10 = $A0
     32  438b				  -	      .byte	$70+$C
     33  438b					      ENDIF
     34  438b				  -	      IF	$10 = $B0
     35  438b				  -	      .byte	$50+$C
     36  438b					      ENDIF
     37  438b				  -	      IF	$10 = $C0
     38  438b				  -	      .byte	$30+$C
     39  438b					      ENDIF
     40  438b				  -	      IF	$10 = $D0
     41  438b				  -	      .byte	$30+$C
     42  438b					      ENDIF
     43  438b				  -	      IF	$10 = $E0
     44  438b				  -	      .byte	$20+$C
     45  438b					      ENDIF
     46  438b				  -	      IF	$10 = $F0
     47  438b				  -	      .byte	$40+$C
     48  438b					      ENDIF
    642  438b
    643  438b				   mancolourPAL2
      0  438b					      NTSC_TO_PAL	$10, 4
      1  438b				  -	      IF	$10 = 0
      2  438b				  -	      .byte	$10+4
      3  438b					      ENDIF
      4  438b					      IF	$10 = $10
      5  438b		       24		      .byte.b	$20+4
      6  438c					      ENDIF
      7  438c				  -	      IF	$10 = $20
      8  438c				  -	      .byte	$40+4
      9  438c					      ENDIF
     10  438c				  -	      IF	$10 = $30
     11  438c				  -	      .byte	$40+4
     12  438c					      ENDIF
     13  438c				  -	      IF	$10 = $40
     14  438c				  -	      .byte	$60+4
     15  438c					      ENDIF
     16  438c				  -	      IF	$10 = $50
     17  438c				  -	      .byte	$80+4
     18  438c					      ENDIF
     19  438c				  -	      IF	$10 = $60
     20  438c				  -	      .byte	$C0+4
     21  438c					      ENDIF
     22  438c				  -	      IF	$10 = $70
     23  438c				  -	      .byte	$D0+4
     24  438c					      ENDIF
     25  438c				  -	      IF	$10 = $80
     26  438c				  -	      .byte	$B0+4
     27  438c					      ENDIF
     28  438c				  -	      IF	$10 = $90
     29  438c				  -	      .byte	$90+4
     30  438c					      ENDIF
     31  438c				  -	      IF	$10 = $A0
     32  438c				  -	      .byte	$70+4
     33  438c					      ENDIF
     34  438c				  -	      IF	$10 = $B0
     35  438c				  -	      .byte	$50+4
     36  438c					      ENDIF
     37  438c				  -	      IF	$10 = $C0
     38  438c				  -	      .byte	$30+4
     39  438c					      ENDIF
     40  438c				  -	      IF	$10 = $D0
     41  438c				  -	      .byte	$30+4
     42  438c					      ENDIF
     43  438c				  -	      IF	$10 = $E0
     44  438c				  -	      .byte	$20+4
     45  438c					      ENDIF
     46  438c				  -	      IF	$10 = $F0
     47  438c				  -	      .byte	$40+4
     48  438c					      ENDIF
      0  438c					      NTSC_TO_PAL	$10, 4
      1  438c				  -	      IF	$10 = 0
      2  438c				  -	      .byte	$10+4
      3  438c					      ENDIF
      4  438c					      IF	$10 = $10
      5  438c		       24		      .byte.b	$20+4
      6  438d					      ENDIF
      7  438d				  -	      IF	$10 = $20
      8  438d				  -	      .byte	$40+4
      9  438d					      ENDIF
     10  438d				  -	      IF	$10 = $30
     11  438d				  -	      .byte	$40+4
     12  438d					      ENDIF
     13  438d				  -	      IF	$10 = $40
     14  438d				  -	      .byte	$60+4
     15  438d					      ENDIF
     16  438d				  -	      IF	$10 = $50
     17  438d				  -	      .byte	$80+4
     18  438d					      ENDIF
     19  438d				  -	      IF	$10 = $60
     20  438d				  -	      .byte	$C0+4
     21  438d					      ENDIF
     22  438d				  -	      IF	$10 = $70
     23  438d				  -	      .byte	$D0+4
     24  438d					      ENDIF
     25  438d				  -	      IF	$10 = $80
     26  438d				  -	      .byte	$B0+4
     27  438d					      ENDIF
     28  438d				  -	      IF	$10 = $90
     29  438d				  -	      .byte	$90+4
     30  438d					      ENDIF
     31  438d				  -	      IF	$10 = $A0
     32  438d				  -	      .byte	$70+4
     33  438d					      ENDIF
     34  438d				  -	      IF	$10 = $B0
     35  438d				  -	      .byte	$50+4
     36  438d					      ENDIF
     37  438d				  -	      IF	$10 = $C0
     38  438d				  -	      .byte	$30+4
     39  438d					      ENDIF
     40  438d				  -	      IF	$10 = $D0
     41  438d				  -	      .byte	$30+4
     42  438d					      ENDIF
     43  438d				  -	      IF	$10 = $E0
     44  438d				  -	      .byte	$20+4
     45  438d					      ENDIF
     46  438d				  -	      IF	$10 = $F0
     47  438d				  -	      .byte	$40+4
     48  438d					      ENDIF
      0  438d					      NTSC_TO_PAL	$90, 4
      1  438d				  -	      IF	$90 = 0
      2  438d				  -	      .byte	$90+4
      3  438d					      ENDIF
      4  438d				  -	      IF	$90 = $10
      5  438d				  -	      .byte	$20+4
      6  438d					      ENDIF
      7  438d				  -	      IF	$90 = $20
      8  438d				  -	      .byte	$40+4
      9  438d					      ENDIF
     10  438d				  -	      IF	$90 = $30
     11  438d				  -	      .byte	$40+4
     12  438d					      ENDIF
     13  438d				  -	      IF	$90 = $40
     14  438d				  -	      .byte	$60+4
     15  438d					      ENDIF
     16  438d				  -	      IF	$90 = $50
     17  438d				  -	      .byte	$80+4
     18  438d					      ENDIF
     19  438d				  -	      IF	$90 = $60
     20  438d				  -	      .byte	$C0+4
     21  438d					      ENDIF
     22  438d				  -	      IF	$90 = $70
     23  438d				  -	      .byte	$D0+4
     24  438d					      ENDIF
     25  438d				  -	      IF	$90 = $80
     26  438d				  -	      .byte	$B0+4
     27  438d					      ENDIF
     28  438d					      IF	$90 = $90
     29  438d		       94		      .byte.b	$90+4
     30  438e					      ENDIF
     31  438e				  -	      IF	$90 = $A0
     32  438e				  -	      .byte	$70+4
     33  438e					      ENDIF
     34  438e				  -	      IF	$90 = $B0
     35  438e				  -	      .byte	$50+4
     36  438e					      ENDIF
     37  438e				  -	      IF	$90 = $C0
     38  438e				  -	      .byte	$30+4
     39  438e					      ENDIF
     40  438e				  -	      IF	$90 = $D0
     41  438e				  -	      .byte	$30+4
     42  438e					      ENDIF
     43  438e				  -	      IF	$90 = $E0
     44  438e				  -	      .byte	$20+4
     45  438e					      ENDIF
     46  438e				  -	      IF	$90 = $F0
     47  438e				  -	      .byte	$40+4
     48  438e					      ENDIF
      0  438e					      NTSC_TO_PAL	$90, 4
      1  438e				  -	      IF	$90 = 0
      2  438e				  -	      .byte	$90+4
      3  438e					      ENDIF
      4  438e				  -	      IF	$90 = $10
      5  438e				  -	      .byte	$20+4
      6  438e					      ENDIF
      7  438e				  -	      IF	$90 = $20
      8  438e				  -	      .byte	$40+4
      9  438e					      ENDIF
     10  438e				  -	      IF	$90 = $30
     11  438e				  -	      .byte	$40+4
     12  438e					      ENDIF
     13  438e				  -	      IF	$90 = $40
     14  438e				  -	      .byte	$60+4
     15  438e					      ENDIF
     16  438e				  -	      IF	$90 = $50
     17  438e				  -	      .byte	$80+4
     18  438e					      ENDIF
     19  438e				  -	      IF	$90 = $60
     20  438e				  -	      .byte	$C0+4
     21  438e					      ENDIF
     22  438e				  -	      IF	$90 = $70
     23  438e				  -	      .byte	$D0+4
     24  438e					      ENDIF
     25  438e				  -	      IF	$90 = $80
     26  438e				  -	      .byte	$B0+4
     27  438e					      ENDIF
     28  438e					      IF	$90 = $90
     29  438e		       94		      .byte.b	$90+4
     30  438f					      ENDIF
     31  438f				  -	      IF	$90 = $A0
     32  438f				  -	      .byte	$70+4
     33  438f					      ENDIF
     34  438f				  -	      IF	$90 = $B0
     35  438f				  -	      .byte	$50+4
     36  438f					      ENDIF
     37  438f				  -	      IF	$90 = $C0
     38  438f				  -	      .byte	$30+4
     39  438f					      ENDIF
     40  438f				  -	      IF	$90 = $D0
     41  438f				  -	      .byte	$30+4
     42  438f					      ENDIF
     43  438f				  -	      IF	$90 = $E0
     44  438f				  -	      .byte	$20+4
     45  438f					      ENDIF
     46  438f				  -	      IF	$90 = $F0
     47  438f				  -	      .byte	$40+4
     48  438f					      ENDIF
      0  438f					      NTSC_TO_PAL	$90, 4
      1  438f				  -	      IF	$90 = 0
      2  438f				  -	      .byte	$90+4
      3  438f					      ENDIF
      4  438f				  -	      IF	$90 = $10
      5  438f				  -	      .byte	$20+4
      6  438f					      ENDIF
      7  438f				  -	      IF	$90 = $20
      8  438f				  -	      .byte	$40+4
      9  438f					      ENDIF
     10  438f				  -	      IF	$90 = $30
     11  438f				  -	      .byte	$40+4
     12  438f					      ENDIF
     13  438f				  -	      IF	$90 = $40
     14  438f				  -	      .byte	$60+4
     15  438f					      ENDIF
     16  438f				  -	      IF	$90 = $50
     17  438f				  -	      .byte	$80+4
     18  438f					      ENDIF
     19  438f				  -	      IF	$90 = $60
     20  438f				  -	      .byte	$C0+4
     21  438f					      ENDIF
     22  438f				  -	      IF	$90 = $70
     23  438f				  -	      .byte	$D0+4
     24  438f					      ENDIF
     25  438f				  -	      IF	$90 = $80
     26  438f				  -	      .byte	$B0+4
     27  438f					      ENDIF
     28  438f					      IF	$90 = $90
     29  438f		       94		      .byte.b	$90+4
     30  4390					      ENDIF
     31  4390				  -	      IF	$90 = $A0
     32  4390				  -	      .byte	$70+4
     33  4390					      ENDIF
     34  4390				  -	      IF	$90 = $B0
     35  4390				  -	      .byte	$50+4
     36  4390					      ENDIF
     37  4390				  -	      IF	$90 = $C0
     38  4390				  -	      .byte	$30+4
     39  4390					      ENDIF
     40  4390				  -	      IF	$90 = $D0
     41  4390				  -	      .byte	$30+4
     42  4390					      ENDIF
     43  4390				  -	      IF	$90 = $E0
     44  4390				  -	      .byte	$20+4
     45  4390					      ENDIF
     46  4390				  -	      IF	$90 = $F0
     47  4390				  -	      .byte	$40+4
     48  4390					      ENDIF
      0  4390					      NTSC_TO_PAL	$90, 4
      1  4390				  -	      IF	$90 = 0
      2  4390				  -	      .byte	$90+4
      3  4390					      ENDIF
      4  4390				  -	      IF	$90 = $10
      5  4390				  -	      .byte	$20+4
      6  4390					      ENDIF
      7  4390				  -	      IF	$90 = $20
      8  4390				  -	      .byte	$40+4
      9  4390					      ENDIF
     10  4390				  -	      IF	$90 = $30
     11  4390				  -	      .byte	$40+4
     12  4390					      ENDIF
     13  4390				  -	      IF	$90 = $40
     14  4390				  -	      .byte	$60+4
     15  4390					      ENDIF
     16  4390				  -	      IF	$90 = $50
     17  4390				  -	      .byte	$80+4
     18  4390					      ENDIF
     19  4390				  -	      IF	$90 = $60
     20  4390				  -	      .byte	$C0+4
     21  4390					      ENDIF
     22  4390				  -	      IF	$90 = $70
     23  4390				  -	      .byte	$D0+4
     24  4390					      ENDIF
     25  4390				  -	      IF	$90 = $80
     26  4390				  -	      .byte	$B0+4
     27  4390					      ENDIF
     28  4390					      IF	$90 = $90
     29  4390		       94		      .byte.b	$90+4
     30  4391					      ENDIF
     31  4391				  -	      IF	$90 = $A0
     32  4391				  -	      .byte	$70+4
     33  4391					      ENDIF
     34  4391				  -	      IF	$90 = $B0
     35  4391				  -	      .byte	$50+4
     36  4391					      ENDIF
     37  4391				  -	      IF	$90 = $C0
     38  4391				  -	      .byte	$30+4
     39  4391					      ENDIF
     40  4391				  -	      IF	$90 = $D0
     41  4391				  -	      .byte	$30+4
     42  4391					      ENDIF
     43  4391				  -	      IF	$90 = $E0
     44  4391				  -	      .byte	$20+4
     45  4391					      ENDIF
     46  4391				  -	      IF	$90 = $F0
     47  4391				  -	      .byte	$40+4
     48  4391					      ENDIF
      0  4391					      NTSC_TO_PAL	$90, 4
      1  4391				  -	      IF	$90 = 0
      2  4391				  -	      .byte	$90+4
      3  4391					      ENDIF
      4  4391				  -	      IF	$90 = $10
      5  4391				  -	      .byte	$20+4
      6  4391					      ENDIF
      7  4391				  -	      IF	$90 = $20
      8  4391				  -	      .byte	$40+4
      9  4391					      ENDIF
     10  4391				  -	      IF	$90 = $30
     11  4391				  -	      .byte	$40+4
     12  4391					      ENDIF
     13  4391				  -	      IF	$90 = $40
     14  4391				  -	      .byte	$60+4
     15  4391					      ENDIF
     16  4391				  -	      IF	$90 = $50
     17  4391				  -	      .byte	$80+4
     18  4391					      ENDIF
     19  4391				  -	      IF	$90 = $60
     20  4391				  -	      .byte	$C0+4
     21  4391					      ENDIF
     22  4391				  -	      IF	$90 = $70
     23  4391				  -	      .byte	$D0+4
     24  4391					      ENDIF
     25  4391				  -	      IF	$90 = $80
     26  4391				  -	      .byte	$B0+4
     27  4391					      ENDIF
     28  4391					      IF	$90 = $90
     29  4391		       94		      .byte.b	$90+4
     30  4392					      ENDIF
     31  4392				  -	      IF	$90 = $A0
     32  4392				  -	      .byte	$70+4
     33  4392					      ENDIF
     34  4392				  -	      IF	$90 = $B0
     35  4392				  -	      .byte	$50+4
     36  4392					      ENDIF
     37  4392				  -	      IF	$90 = $C0
     38  4392				  -	      .byte	$30+4
     39  4392					      ENDIF
     40  4392				  -	      IF	$90 = $D0
     41  4392				  -	      .byte	$30+4
     42  4392					      ENDIF
     43  4392				  -	      IF	$90 = $E0
     44  4392				  -	      .byte	$20+4
     45  4392					      ENDIF
     46  4392				  -	      IF	$90 = $F0
     47  4392				  -	      .byte	$40+4
     48  4392					      ENDIF
      0  4392					      NTSC_TO_PAL	$90, 4
      1  4392				  -	      IF	$90 = 0
      2  4392				  -	      .byte	$90+4
      3  4392					      ENDIF
      4  4392				  -	      IF	$90 = $10
      5  4392				  -	      .byte	$20+4
      6  4392					      ENDIF
      7  4392				  -	      IF	$90 = $20
      8  4392				  -	      .byte	$40+4
      9  4392					      ENDIF
     10  4392				  -	      IF	$90 = $30
     11  4392				  -	      .byte	$40+4
     12  4392					      ENDIF
     13  4392				  -	      IF	$90 = $40
     14  4392				  -	      .byte	$60+4
     15  4392					      ENDIF
     16  4392				  -	      IF	$90 = $50
     17  4392				  -	      .byte	$80+4
     18  4392					      ENDIF
     19  4392				  -	      IF	$90 = $60
     20  4392				  -	      .byte	$C0+4
     21  4392					      ENDIF
     22  4392				  -	      IF	$90 = $70
     23  4392				  -	      .byte	$D0+4
     24  4392					      ENDIF
     25  4392				  -	      IF	$90 = $80
     26  4392				  -	      .byte	$B0+4
     27  4392					      ENDIF
     28  4392					      IF	$90 = $90
     29  4392		       94		      .byte.b	$90+4
     30  4393					      ENDIF
     31  4393				  -	      IF	$90 = $A0
     32  4393				  -	      .byte	$70+4
     33  4393					      ENDIF
     34  4393				  -	      IF	$90 = $B0
     35  4393				  -	      .byte	$50+4
     36  4393					      ENDIF
     37  4393				  -	      IF	$90 = $C0
     38  4393				  -	      .byte	$30+4
     39  4393					      ENDIF
     40  4393				  -	      IF	$90 = $D0
     41  4393				  -	      .byte	$30+4
     42  4393					      ENDIF
     43  4393				  -	      IF	$90 = $E0
     44  4393				  -	      .byte	$20+4
     45  4393					      ENDIF
     46  4393				  -	      IF	$90 = $F0
     47  4393				  -	      .byte	$40+4
     48  4393					      ENDIF
      0  4393					      NTSC_TO_PAL	$30, 4
      1  4393				  -	      IF	$30 = 0
      2  4393				  -	      .byte	$30+4
      3  4393					      ENDIF
      4  4393				  -	      IF	$30 = $10
      5  4393				  -	      .byte	$20+4
      6  4393					      ENDIF
      7  4393				  -	      IF	$30 = $20
      8  4393				  -	      .byte	$40+4
      9  4393					      ENDIF
     10  4393					      IF	$30 = $30
     11  4393		       44		      .byte.b	$40+4
     12  4394					      ENDIF
     13  4394				  -	      IF	$30 = $40
     14  4394				  -	      .byte	$60+4
     15  4394					      ENDIF
     16  4394				  -	      IF	$30 = $50
     17  4394				  -	      .byte	$80+4
     18  4394					      ENDIF
     19  4394				  -	      IF	$30 = $60
     20  4394				  -	      .byte	$C0+4
     21  4394					      ENDIF
     22  4394				  -	      IF	$30 = $70
     23  4394				  -	      .byte	$D0+4
     24  4394					      ENDIF
     25  4394				  -	      IF	$30 = $80
     26  4394				  -	      .byte	$B0+4
     27  4394					      ENDIF
     28  4394				  -	      IF	$30 = $90
     29  4394				  -	      .byte	$90+4
     30  4394					      ENDIF
     31  4394				  -	      IF	$30 = $A0
     32  4394				  -	      .byte	$70+4
     33  4394					      ENDIF
     34  4394				  -	      IF	$30 = $B0
     35  4394				  -	      .byte	$50+4
     36  4394					      ENDIF
     37  4394				  -	      IF	$30 = $C0
     38  4394				  -	      .byte	$30+4
     39  4394					      ENDIF
     40  4394				  -	      IF	$30 = $D0
     41  4394				  -	      .byte	$30+4
     42  4394					      ENDIF
     43  4394				  -	      IF	$30 = $E0
     44  4394				  -	      .byte	$20+4
     45  4394					      ENDIF
     46  4394				  -	      IF	$30 = $F0
     47  4394				  -	      .byte	$40+4
     48  4394					      ENDIF
      0  4394					      NTSC_TO_PAL	$0,12
      1  4394					      IF	$0 = 0
      2  4394		       0c		      .byte.b	$0+12
      3  4395					      ENDIF
      4  4395				  -	      IF	$0 = $10
      5  4395				  -	      .byte	$20+12
      6  4395					      ENDIF
      7  4395				  -	      IF	$0 = $20
      8  4395				  -	      .byte	$40+12
      9  4395					      ENDIF
     10  4395				  -	      IF	$0 = $30
     11  4395				  -	      .byte	$40+12
     12  4395					      ENDIF
     13  4395				  -	      IF	$0 = $40
     14  4395				  -	      .byte	$60+12
     15  4395					      ENDIF
     16  4395				  -	      IF	$0 = $50
     17  4395				  -	      .byte	$80+12
     18  4395					      ENDIF
     19  4395				  -	      IF	$0 = $60
     20  4395				  -	      .byte	$C0+12
     21  4395					      ENDIF
     22  4395				  -	      IF	$0 = $70
     23  4395				  -	      .byte	$D0+12
     24  4395					      ENDIF
     25  4395				  -	      IF	$0 = $80
     26  4395				  -	      .byte	$B0+12
     27  4395					      ENDIF
     28  4395				  -	      IF	$0 = $90
     29  4395				  -	      .byte	$90+12
     30  4395					      ENDIF
     31  4395				  -	      IF	$0 = $A0
     32  4395				  -	      .byte	$70+12
     33  4395					      ENDIF
     34  4395				  -	      IF	$0 = $B0
     35  4395				  -	      .byte	$50+12
     36  4395					      ENDIF
     37  4395				  -	      IF	$0 = $C0
     38  4395				  -	      .byte	$30+12
     39  4395					      ENDIF
     40  4395				  -	      IF	$0 = $D0
     41  4395				  -	      .byte	$30+12
     42  4395					      ENDIF
     43  4395				  -	      IF	$0 = $E0
     44  4395				  -	      .byte	$20+12
     45  4395					      ENDIF
     46  4395				  -	      IF	$0 = $F0
     47  4395				  -	      .byte	$40+12
     48  4395					      ENDIF
      0  4395					      NTSC_TO_PAL	$90, 6
      1  4395				  -	      IF	$90 = 0
      2  4395				  -	      .byte	$90+6
      3  4395					      ENDIF
      4  4395				  -	      IF	$90 = $10
      5  4395				  -	      .byte	$20+6
      6  4395					      ENDIF
      7  4395				  -	      IF	$90 = $20
      8  4395				  -	      .byte	$40+6
      9  4395					      ENDIF
     10  4395				  -	      IF	$90 = $30
     11  4395				  -	      .byte	$40+6
     12  4395					      ENDIF
     13  4395				  -	      IF	$90 = $40
     14  4395				  -	      .byte	$60+6
     15  4395					      ENDIF
     16  4395				  -	      IF	$90 = $50
     17  4395				  -	      .byte	$80+6
     18  4395					      ENDIF
     19  4395				  -	      IF	$90 = $60
     20  4395				  -	      .byte	$C0+6
     21  4395					      ENDIF
     22  4395				  -	      IF	$90 = $70
     23  4395				  -	      .byte	$D0+6
     24  4395					      ENDIF
     25  4395				  -	      IF	$90 = $80
     26  4395				  -	      .byte	$B0+6
     27  4395					      ENDIF
     28  4395					      IF	$90 = $90
     29  4395		       96		      .byte.b	$90+6
     30  4396					      ENDIF
     31  4396				  -	      IF	$90 = $A0
     32  4396				  -	      .byte	$70+6
     33  4396					      ENDIF
     34  4396				  -	      IF	$90 = $B0
     35  4396				  -	      .byte	$50+6
     36  4396					      ENDIF
     37  4396				  -	      IF	$90 = $C0
     38  4396				  -	      .byte	$30+6
     39  4396					      ENDIF
     40  4396				  -	      IF	$90 = $D0
     41  4396				  -	      .byte	$30+6
     42  4396					      ENDIF
     43  4396				  -	      IF	$90 = $E0
     44  4396				  -	      .byte	$20+6
     45  4396					      ENDIF
     46  4396				  -	      IF	$90 = $F0
     47  4396				  -	      .byte	$40+6
     48  4396					      ENDIF
      0  4396					      NTSC_TO_PAL	$90, 6
      1  4396				  -	      IF	$90 = 0
      2  4396				  -	      .byte	$90+6
      3  4396					      ENDIF
      4  4396				  -	      IF	$90 = $10
      5  4396				  -	      .byte	$20+6
      6  4396					      ENDIF
      7  4396				  -	      IF	$90 = $20
      8  4396				  -	      .byte	$40+6
      9  4396					      ENDIF
     10  4396				  -	      IF	$90 = $30
     11  4396				  -	      .byte	$40+6
     12  4396					      ENDIF
     13  4396				  -	      IF	$90 = $40
     14  4396				  -	      .byte	$60+6
     15  4396					      ENDIF
     16  4396				  -	      IF	$90 = $50
     17  4396				  -	      .byte	$80+6
     18  4396					      ENDIF
     19  4396				  -	      IF	$90 = $60
     20  4396				  -	      .byte	$C0+6
     21  4396					      ENDIF
     22  4396				  -	      IF	$90 = $70
     23  4396				  -	      .byte	$D0+6
     24  4396					      ENDIF
     25  4396				  -	      IF	$90 = $80
     26  4396				  -	      .byte	$B0+6
     27  4396					      ENDIF
     28  4396					      IF	$90 = $90
     29  4396		       96		      .byte.b	$90+6
     30  4397					      ENDIF
     31  4397				  -	      IF	$90 = $A0
     32  4397				  -	      .byte	$70+6
     33  4397					      ENDIF
     34  4397				  -	      IF	$90 = $B0
     35  4397				  -	      .byte	$50+6
     36  4397					      ENDIF
     37  4397				  -	      IF	$90 = $C0
     38  4397				  -	      .byte	$30+6
     39  4397					      ENDIF
     40  4397				  -	      IF	$90 = $D0
     41  4397				  -	      .byte	$30+6
     42  4397					      ENDIF
     43  4397				  -	      IF	$90 = $E0
     44  4397				  -	      .byte	$20+6
     45  4397					      ENDIF
     46  4397				  -	      IF	$90 = $F0
     47  4397				  -	      .byte	$40+6
     48  4397					      ENDIF
      0  4397					      NTSC_TO_PAL	$90, 6
      1  4397				  -	      IF	$90 = 0
      2  4397				  -	      .byte	$90+6
      3  4397					      ENDIF
      4  4397				  -	      IF	$90 = $10
      5  4397				  -	      .byte	$20+6
      6  4397					      ENDIF
      7  4397				  -	      IF	$90 = $20
      8  4397				  -	      .byte	$40+6
      9  4397					      ENDIF
     10  4397				  -	      IF	$90 = $30
     11  4397				  -	      .byte	$40+6
     12  4397					      ENDIF
     13  4397				  -	      IF	$90 = $40
     14  4397				  -	      .byte	$60+6
     15  4397					      ENDIF
     16  4397				  -	      IF	$90 = $50
     17  4397				  -	      .byte	$80+6
     18  4397					      ENDIF
     19  4397				  -	      IF	$90 = $60
     20  4397				  -	      .byte	$C0+6
     21  4397					      ENDIF
     22  4397				  -	      IF	$90 = $70
     23  4397				  -	      .byte	$D0+6
     24  4397					      ENDIF
     25  4397				  -	      IF	$90 = $80
     26  4397				  -	      .byte	$B0+6
     27  4397					      ENDIF
     28  4397					      IF	$90 = $90
     29  4397		       96		      .byte.b	$90+6
     30  4398					      ENDIF
     31  4398				  -	      IF	$90 = $A0
     32  4398				  -	      .byte	$70+6
     33  4398					      ENDIF
     34  4398				  -	      IF	$90 = $B0
     35  4398				  -	      .byte	$50+6
     36  4398					      ENDIF
     37  4398				  -	      IF	$90 = $C0
     38  4398				  -	      .byte	$30+6
     39  4398					      ENDIF
     40  4398				  -	      IF	$90 = $D0
     41  4398				  -	      .byte	$30+6
     42  4398					      ENDIF
     43  4398				  -	      IF	$90 = $E0
     44  4398				  -	      .byte	$20+6
     45  4398					      ENDIF
     46  4398				  -	      IF	$90 = $F0
     47  4398				  -	      .byte	$40+6
     48  4398					      ENDIF
      0  4398					      NTSC_TO_PAL	$90, 6
      1  4398				  -	      IF	$90 = 0
      2  4398				  -	      .byte	$90+6
      3  4398					      ENDIF
      4  4398				  -	      IF	$90 = $10
      5  4398				  -	      .byte	$20+6
      6  4398					      ENDIF
      7  4398				  -	      IF	$90 = $20
      8  4398				  -	      .byte	$40+6
      9  4398					      ENDIF
     10  4398				  -	      IF	$90 = $30
     11  4398				  -	      .byte	$40+6
     12  4398					      ENDIF
     13  4398				  -	      IF	$90 = $40
     14  4398				  -	      .byte	$60+6
     15  4398					      ENDIF
     16  4398				  -	      IF	$90 = $50
     17  4398				  -	      .byte	$80+6
     18  4398					      ENDIF
     19  4398				  -	      IF	$90 = $60
     20  4398				  -	      .byte	$C0+6
     21  4398					      ENDIF
     22  4398				  -	      IF	$90 = $70
     23  4398				  -	      .byte	$D0+6
     24  4398					      ENDIF
     25  4398				  -	      IF	$90 = $80
     26  4398				  -	      .byte	$B0+6
     27  4398					      ENDIF
     28  4398					      IF	$90 = $90
     29  4398		       96		      .byte.b	$90+6
     30  4399					      ENDIF
     31  4399				  -	      IF	$90 = $A0
     32  4399				  -	      .byte	$70+6
     33  4399					      ENDIF
     34  4399				  -	      IF	$90 = $B0
     35  4399				  -	      .byte	$50+6
     36  4399					      ENDIF
     37  4399				  -	      IF	$90 = $C0
     38  4399				  -	      .byte	$30+6
     39  4399					      ENDIF
     40  4399				  -	      IF	$90 = $D0
     41  4399				  -	      .byte	$30+6
     42  4399					      ENDIF
     43  4399				  -	      IF	$90 = $E0
     44  4399				  -	      .byte	$20+6
     45  4399					      ENDIF
     46  4399				  -	      IF	$90 = $F0
     47  4399				  -	      .byte	$40+6
     48  4399					      ENDIF
      0  4399					      NTSC_TO_PAL	$90, 6
      1  4399				  -	      IF	$90 = 0
      2  4399				  -	      .byte	$90+6
      3  4399					      ENDIF
      4  4399				  -	      IF	$90 = $10
      5  4399				  -	      .byte	$20+6
      6  4399					      ENDIF
      7  4399				  -	      IF	$90 = $20
      8  4399				  -	      .byte	$40+6
      9  4399					      ENDIF
     10  4399				  -	      IF	$90 = $30
     11  4399				  -	      .byte	$40+6
     12  4399					      ENDIF
     13  4399				  -	      IF	$90 = $40
     14  4399				  -	      .byte	$60+6
     15  4399					      ENDIF
     16  4399				  -	      IF	$90 = $50
     17  4399				  -	      .byte	$80+6
     18  4399					      ENDIF
     19  4399				  -	      IF	$90 = $60
     20  4399				  -	      .byte	$C0+6
     21  4399					      ENDIF
     22  4399				  -	      IF	$90 = $70
     23  4399				  -	      .byte	$D0+6
     24  4399					      ENDIF
     25  4399				  -	      IF	$90 = $80
     26  4399				  -	      .byte	$B0+6
     27  4399					      ENDIF
     28  4399					      IF	$90 = $90
     29  4399		       96		      .byte.b	$90+6
     30  439a					      ENDIF
     31  439a				  -	      IF	$90 = $A0
     32  439a				  -	      .byte	$70+6
     33  439a					      ENDIF
     34  439a				  -	      IF	$90 = $B0
     35  439a				  -	      .byte	$50+6
     36  439a					      ENDIF
     37  439a				  -	      IF	$90 = $C0
     38  439a				  -	      .byte	$30+6
     39  439a					      ENDIF
     40  439a				  -	      IF	$90 = $D0
     41  439a				  -	      .byte	$30+6
     42  439a					      ENDIF
     43  439a				  -	      IF	$90 = $E0
     44  439a				  -	      .byte	$20+6
     45  439a					      ENDIF
     46  439a				  -	      IF	$90 = $F0
     47  439a				  -	      .byte	$40+6
     48  439a					      ENDIF
      0  439a					      NTSC_TO_PAL	$0, 12
      1  439a					      IF	$0 = 0
      2  439a		       0c		      .byte.b	$0+12
      3  439b					      ENDIF
      4  439b				  -	      IF	$0 = $10
      5  439b				  -	      .byte	$20+12
      6  439b					      ENDIF
      7  439b				  -	      IF	$0 = $20
      8  439b				  -	      .byte	$40+12
      9  439b					      ENDIF
     10  439b				  -	      IF	$0 = $30
     11  439b				  -	      .byte	$40+12
     12  439b					      ENDIF
     13  439b				  -	      IF	$0 = $40
     14  439b				  -	      .byte	$60+12
     15  439b					      ENDIF
     16  439b				  -	      IF	$0 = $50
     17  439b				  -	      .byte	$80+12
     18  439b					      ENDIF
     19  439b				  -	      IF	$0 = $60
     20  439b				  -	      .byte	$C0+12
     21  439b					      ENDIF
     22  439b				  -	      IF	$0 = $70
     23  439b				  -	      .byte	$D0+12
     24  439b					      ENDIF
     25  439b				  -	      IF	$0 = $80
     26  439b				  -	      .byte	$B0+12
     27  439b					      ENDIF
     28  439b				  -	      IF	$0 = $90
     29  439b				  -	      .byte	$90+12
     30  439b					      ENDIF
     31  439b				  -	      IF	$0 = $A0
     32  439b				  -	      .byte	$70+12
     33  439b					      ENDIF
     34  439b				  -	      IF	$0 = $B0
     35  439b				  -	      .byte	$50+12
     36  439b					      ENDIF
     37  439b				  -	      IF	$0 = $C0
     38  439b				  -	      .byte	$30+12
     39  439b					      ENDIF
     40  439b				  -	      IF	$0 = $D0
     41  439b				  -	      .byte	$30+12
     42  439b					      ENDIF
     43  439b				  -	      IF	$0 = $E0
     44  439b				  -	      .byte	$20+12
     45  439b					      ENDIF
     46  439b				  -	      IF	$0 = $F0
     47  439b				  -	      .byte	$40+12
     48  439b					      ENDIF
      0  439b					      NTSC_TO_PAL	$30, 8
      1  439b				  -	      IF	$30 = 0
      2  439b				  -	      .byte	$30+8
      3  439b					      ENDIF
      4  439b				  -	      IF	$30 = $10
      5  439b				  -	      .byte	$20+8
      6  439b					      ENDIF
      7  439b				  -	      IF	$30 = $20
      8  439b				  -	      .byte	$40+8
      9  439b					      ENDIF
     10  439b					      IF	$30 = $30
     11  439b		       48		      .byte.b	$40+8
     12  439c					      ENDIF
     13  439c				  -	      IF	$30 = $40
     14  439c				  -	      .byte	$60+8
     15  439c					      ENDIF
     16  439c				  -	      IF	$30 = $50
     17  439c				  -	      .byte	$80+8
     18  439c					      ENDIF
     19  439c				  -	      IF	$30 = $60
     20  439c				  -	      .byte	$C0+8
     21  439c					      ENDIF
     22  439c				  -	      IF	$30 = $70
     23  439c				  -	      .byte	$D0+8
     24  439c					      ENDIF
     25  439c				  -	      IF	$30 = $80
     26  439c				  -	      .byte	$B0+8
     27  439c					      ENDIF
     28  439c				  -	      IF	$30 = $90
     29  439c				  -	      .byte	$90+8
     30  439c					      ENDIF
     31  439c				  -	      IF	$30 = $A0
     32  439c				  -	      .byte	$70+8
     33  439c					      ENDIF
     34  439c				  -	      IF	$30 = $B0
     35  439c				  -	      .byte	$50+8
     36  439c					      ENDIF
     37  439c				  -	      IF	$30 = $C0
     38  439c				  -	      .byte	$30+8
     39  439c					      ENDIF
     40  439c				  -	      IF	$30 = $D0
     41  439c				  -	      .byte	$30+8
     42  439c					      ENDIF
     43  439c				  -	      IF	$30 = $E0
     44  439c				  -	      .byte	$20+8
     45  439c					      ENDIF
     46  439c				  -	      IF	$30 = $F0
     47  439c				  -	      .byte	$40+8
     48  439c					      ENDIF
      0  439c					      NTSC_TO_PAL	$30, 8
      1  439c				  -	      IF	$30 = 0
      2  439c				  -	      .byte	$30+8
      3  439c					      ENDIF
      4  439c				  -	      IF	$30 = $10
      5  439c				  -	      .byte	$20+8
      6  439c					      ENDIF
      7  439c				  -	      IF	$30 = $20
      8  439c				  -	      .byte	$40+8
      9  439c					      ENDIF
     10  439c					      IF	$30 = $30
     11  439c		       48		      .byte.b	$40+8
     12  439d					      ENDIF
     13  439d				  -	      IF	$30 = $40
     14  439d				  -	      .byte	$60+8
     15  439d					      ENDIF
     16  439d				  -	      IF	$30 = $50
     17  439d				  -	      .byte	$80+8
     18  439d					      ENDIF
     19  439d				  -	      IF	$30 = $60
     20  439d				  -	      .byte	$C0+8
     21  439d					      ENDIF
     22  439d				  -	      IF	$30 = $70
     23  439d				  -	      .byte	$D0+8
     24  439d					      ENDIF
     25  439d				  -	      IF	$30 = $80
     26  439d				  -	      .byte	$B0+8
     27  439d					      ENDIF
     28  439d				  -	      IF	$30 = $90
     29  439d				  -	      .byte	$90+8
     30  439d					      ENDIF
     31  439d				  -	      IF	$30 = $A0
     32  439d				  -	      .byte	$70+8
     33  439d					      ENDIF
     34  439d				  -	      IF	$30 = $B0
     35  439d				  -	      .byte	$50+8
     36  439d					      ENDIF
     37  439d				  -	      IF	$30 = $C0
     38  439d				  -	      .byte	$30+8
     39  439d					      ENDIF
     40  439d				  -	      IF	$30 = $D0
     41  439d				  -	      .byte	$30+8
     42  439d					      ENDIF
     43  439d				  -	      IF	$30 = $E0
     44  439d				  -	      .byte	$20+8
     45  439d					      ENDIF
     46  439d				  -	      IF	$30 = $F0
     47  439d				  -	      .byte	$40+8
     48  439d					      ENDIF
      0  439d					      NTSC_TO_PAL	$30, 8
      1  439d				  -	      IF	$30 = 0
      2  439d				  -	      .byte	$30+8
      3  439d					      ENDIF
      4  439d				  -	      IF	$30 = $10
      5  439d				  -	      .byte	$20+8
      6  439d					      ENDIF
      7  439d				  -	      IF	$30 = $20
      8  439d				  -	      .byte	$40+8
      9  439d					      ENDIF
     10  439d					      IF	$30 = $30
     11  439d		       48		      .byte.b	$40+8
     12  439e					      ENDIF
     13  439e				  -	      IF	$30 = $40
     14  439e				  -	      .byte	$60+8
     15  439e					      ENDIF
     16  439e				  -	      IF	$30 = $50
     17  439e				  -	      .byte	$80+8
     18  439e					      ENDIF
     19  439e				  -	      IF	$30 = $60
     20  439e				  -	      .byte	$C0+8
     21  439e					      ENDIF
     22  439e				  -	      IF	$30 = $70
     23  439e				  -	      .byte	$D0+8
     24  439e					      ENDIF
     25  439e				  -	      IF	$30 = $80
     26  439e				  -	      .byte	$B0+8
     27  439e					      ENDIF
     28  439e				  -	      IF	$30 = $90
     29  439e				  -	      .byte	$90+8
     30  439e					      ENDIF
     31  439e				  -	      IF	$30 = $A0
     32  439e				  -	      .byte	$70+8
     33  439e					      ENDIF
     34  439e				  -	      IF	$30 = $B0
     35  439e				  -	      .byte	$50+8
     36  439e					      ENDIF
     37  439e				  -	      IF	$30 = $C0
     38  439e				  -	      .byte	$30+8
     39  439e					      ENDIF
     40  439e				  -	      IF	$30 = $D0
     41  439e				  -	      .byte	$30+8
     42  439e					      ENDIF
     43  439e				  -	      IF	$30 = $E0
     44  439e				  -	      .byte	$20+8
     45  439e					      ENDIF
     46  439e				  -	      IF	$30 = $F0
     47  439e				  -	      .byte	$40+8
     48  439e					      ENDIF
      0  439e					      NTSC_TO_PAL	$30, 8
      1  439e				  -	      IF	$30 = 0
      2  439e				  -	      .byte	$30+8
      3  439e					      ENDIF
      4  439e				  -	      IF	$30 = $10
      5  439e				  -	      .byte	$20+8
      6  439e					      ENDIF
      7  439e				  -	      IF	$30 = $20
      8  439e				  -	      .byte	$40+8
      9  439e					      ENDIF
     10  439e					      IF	$30 = $30
     11  439e		       48		      .byte.b	$40+8
     12  439f					      ENDIF
     13  439f				  -	      IF	$30 = $40
     14  439f				  -	      .byte	$60+8
     15  439f					      ENDIF
     16  439f				  -	      IF	$30 = $50
     17  439f				  -	      .byte	$80+8
     18  439f					      ENDIF
     19  439f				  -	      IF	$30 = $60
     20  439f				  -	      .byte	$C0+8
     21  439f					      ENDIF
     22  439f				  -	      IF	$30 = $70
     23  439f				  -	      .byte	$D0+8
     24  439f					      ENDIF
     25  439f				  -	      IF	$30 = $80
     26  439f				  -	      .byte	$B0+8
     27  439f					      ENDIF
     28  439f				  -	      IF	$30 = $90
     29  439f				  -	      .byte	$90+8
     30  439f					      ENDIF
     31  439f				  -	      IF	$30 = $A0
     32  439f				  -	      .byte	$70+8
     33  439f					      ENDIF
     34  439f				  -	      IF	$30 = $B0
     35  439f				  -	      .byte	$50+8
     36  439f					      ENDIF
     37  439f				  -	      IF	$30 = $C0
     38  439f				  -	      .byte	$30+8
     39  439f					      ENDIF
     40  439f				  -	      IF	$30 = $D0
     41  439f				  -	      .byte	$30+8
     42  439f					      ENDIF
     43  439f				  -	      IF	$30 = $E0
     44  439f				  -	      .byte	$20+8
     45  439f					      ENDIF
     46  439f				  -	      IF	$30 = $F0
     47  439f				  -	      .byte	$40+8
     48  439f					      ENDIF
      0  439f					      NTSC_TO_PAL	$30, 8
      1  439f				  -	      IF	$30 = 0
      2  439f				  -	      .byte	$30+8
      3  439f					      ENDIF
      4  439f				  -	      IF	$30 = $10
      5  439f				  -	      .byte	$20+8
      6  439f					      ENDIF
      7  439f				  -	      IF	$30 = $20
      8  439f				  -	      .byte	$40+8
      9  439f					      ENDIF
     10  439f					      IF	$30 = $30
     11  439f		       48		      .byte.b	$40+8
     12  43a0					      ENDIF
     13  43a0				  -	      IF	$30 = $40
     14  43a0				  -	      .byte	$60+8
     15  43a0					      ENDIF
     16  43a0				  -	      IF	$30 = $50
     17  43a0				  -	      .byte	$80+8
     18  43a0					      ENDIF
     19  43a0				  -	      IF	$30 = $60
     20  43a0				  -	      .byte	$C0+8
     21  43a0					      ENDIF
     22  43a0				  -	      IF	$30 = $70
     23  43a0				  -	      .byte	$D0+8
     24  43a0					      ENDIF
     25  43a0				  -	      IF	$30 = $80
     26  43a0				  -	      .byte	$B0+8
     27  43a0					      ENDIF
     28  43a0				  -	      IF	$30 = $90
     29  43a0				  -	      .byte	$90+8
     30  43a0					      ENDIF
     31  43a0				  -	      IF	$30 = $A0
     32  43a0				  -	      .byte	$70+8
     33  43a0					      ENDIF
     34  43a0				  -	      IF	$30 = $B0
     35  43a0				  -	      .byte	$50+8
     36  43a0					      ENDIF
     37  43a0				  -	      IF	$30 = $C0
     38  43a0				  -	      .byte	$30+8
     39  43a0					      ENDIF
     40  43a0				  -	      IF	$30 = $D0
     41  43a0				  -	      .byte	$30+8
     42  43a0					      ENDIF
     43  43a0				  -	      IF	$30 = $E0
     44  43a0				  -	      .byte	$20+8
     45  43a0					      ENDIF
     46  43a0				  -	      IF	$30 = $F0
     47  43a0				  -	      .byte	$40+8
     48  43a0					      ENDIF
      0  43a0					      NTSC_TO_PAL	$30, 8
      1  43a0				  -	      IF	$30 = 0
      2  43a0				  -	      .byte	$30+8
      3  43a0					      ENDIF
      4  43a0				  -	      IF	$30 = $10
      5  43a0				  -	      .byte	$20+8
      6  43a0					      ENDIF
      7  43a0				  -	      IF	$30 = $20
      8  43a0				  -	      .byte	$40+8
      9  43a0					      ENDIF
     10  43a0					      IF	$30 = $30
     11  43a0		       48		      .byte.b	$40+8
     12  43a1					      ENDIF
     13  43a1				  -	      IF	$30 = $40
     14  43a1				  -	      .byte	$60+8
     15  43a1					      ENDIF
     16  43a1				  -	      IF	$30 = $50
     17  43a1				  -	      .byte	$80+8
     18  43a1					      ENDIF
     19  43a1				  -	      IF	$30 = $60
     20  43a1				  -	      .byte	$C0+8
     21  43a1					      ENDIF
     22  43a1				  -	      IF	$30 = $70
     23  43a1				  -	      .byte	$D0+8
     24  43a1					      ENDIF
     25  43a1				  -	      IF	$30 = $80
     26  43a1				  -	      .byte	$B0+8
     27  43a1					      ENDIF
     28  43a1				  -	      IF	$30 = $90
     29  43a1				  -	      .byte	$90+8
     30  43a1					      ENDIF
     31  43a1				  -	      IF	$30 = $A0
     32  43a1				  -	      .byte	$70+8
     33  43a1					      ENDIF
     34  43a1				  -	      IF	$30 = $B0
     35  43a1				  -	      .byte	$50+8
     36  43a1					      ENDIF
     37  43a1				  -	      IF	$30 = $C0
     38  43a1				  -	      .byte	$30+8
     39  43a1					      ENDIF
     40  43a1				  -	      IF	$30 = $D0
     41  43a1				  -	      .byte	$30+8
     42  43a1					      ENDIF
     43  43a1				  -	      IF	$30 = $E0
     44  43a1				  -	      .byte	$20+8
     45  43a1					      ENDIF
     46  43a1				  -	      IF	$30 = $F0
     47  43a1				  -	      .byte	$40+8
     48  43a1					      ENDIF
      0  43a1					      NTSC_TO_PAL	$10, $C
      1  43a1				  -	      IF	$10 = 0
      2  43a1				  -	      .byte	$10+$C
      3  43a1					      ENDIF
      4  43a1					      IF	$10 = $10
      5  43a1		       2c		      .byte.b	$20+$C
      6  43a2					      ENDIF
      7  43a2				  -	      IF	$10 = $20
      8  43a2				  -	      .byte	$40+$C
      9  43a2					      ENDIF
     10  43a2				  -	      IF	$10 = $30
     11  43a2				  -	      .byte	$40+$C
     12  43a2					      ENDIF
     13  43a2				  -	      IF	$10 = $40
     14  43a2				  -	      .byte	$60+$C
     15  43a2					      ENDIF
     16  43a2				  -	      IF	$10 = $50
     17  43a2				  -	      .byte	$80+$C
     18  43a2					      ENDIF
     19  43a2				  -	      IF	$10 = $60
     20  43a2				  -	      .byte	$C0+$C
     21  43a2					      ENDIF
     22  43a2				  -	      IF	$10 = $70
     23  43a2				  -	      .byte	$D0+$C
     24  43a2					      ENDIF
     25  43a2				  -	      IF	$10 = $80
     26  43a2				  -	      .byte	$B0+$C
     27  43a2					      ENDIF
     28  43a2				  -	      IF	$10 = $90
     29  43a2				  -	      .byte	$90+$C
     30  43a2					      ENDIF
     31  43a2				  -	      IF	$10 = $A0
     32  43a2				  -	      .byte	$70+$C
     33  43a2					      ENDIF
     34  43a2				  -	      IF	$10 = $B0
     35  43a2				  -	      .byte	$50+$C
     36  43a2					      ENDIF
     37  43a2				  -	      IF	$10 = $C0
     38  43a2				  -	      .byte	$30+$C
     39  43a2					      ENDIF
     40  43a2				  -	      IF	$10 = $D0
     41  43a2				  -	      .byte	$30+$C
     42  43a2					      ENDIF
     43  43a2				  -	      IF	$10 = $E0
     44  43a2				  -	      .byte	$20+$C
     45  43a2					      ENDIF
     46  43a2				  -	      IF	$10 = $F0
     47  43a2				  -	      .byte	$40+$C
     48  43a2					      ENDIF
      0  43a2					      NTSC_TO_PAL	$10, $C
      1  43a2				  -	      IF	$10 = 0
      2  43a2				  -	      .byte	$10+$C
      3  43a2					      ENDIF
      4  43a2					      IF	$10 = $10
      5  43a2		       2c		      .byte.b	$20+$C
      6  43a3					      ENDIF
      7  43a3				  -	      IF	$10 = $20
      8  43a3				  -	      .byte	$40+$C
      9  43a3					      ENDIF
     10  43a3				  -	      IF	$10 = $30
     11  43a3				  -	      .byte	$40+$C
     12  43a3					      ENDIF
     13  43a3				  -	      IF	$10 = $40
     14  43a3				  -	      .byte	$60+$C
     15  43a3					      ENDIF
     16  43a3				  -	      IF	$10 = $50
     17  43a3				  -	      .byte	$80+$C
     18  43a3					      ENDIF
     19  43a3				  -	      IF	$10 = $60
     20  43a3				  -	      .byte	$C0+$C
     21  43a3					      ENDIF
     22  43a3				  -	      IF	$10 = $70
     23  43a3				  -	      .byte	$D0+$C
     24  43a3					      ENDIF
     25  43a3				  -	      IF	$10 = $80
     26  43a3				  -	      .byte	$B0+$C
     27  43a3					      ENDIF
     28  43a3				  -	      IF	$10 = $90
     29  43a3				  -	      .byte	$90+$C
     30  43a3					      ENDIF
     31  43a3				  -	      IF	$10 = $A0
     32  43a3				  -	      .byte	$70+$C
     33  43a3					      ENDIF
     34  43a3				  -	      IF	$10 = $B0
     35  43a3				  -	      .byte	$50+$C
     36  43a3					      ENDIF
     37  43a3				  -	      IF	$10 = $C0
     38  43a3				  -	      .byte	$30+$C
     39  43a3					      ENDIF
     40  43a3				  -	      IF	$10 = $D0
     41  43a3				  -	      .byte	$30+$C
     42  43a3					      ENDIF
     43  43a3				  -	      IF	$10 = $E0
     44  43a3				  -	      .byte	$20+$C
     45  43a3					      ENDIF
     46  43a3				  -	      IF	$10 = $F0
     47  43a3				  -	      .byte	$40+$C
     48  43a3					      ENDIF
    668  43a3
    669  43a3
    670  43a3		       00 00 00 00*xJoyMoveX  .byte.b	0,0,0,0,0,1, 1,1,0,-1,-1,-1,0,-1,1,0
    671  43b3
    672  43b3				   VBlankTime2x
    673  43b3		       46 46		      .byte.b	70,70
    674  43b5		       62 62		      .byte.b	98,98
    675  43b7				   OverscanTime2X
    676  43b7		       3f 3f		      .byte.b	63, 63
    677  43b9		       4d 4d		      .byte.b	77, 77
    678  43bb
    679  43bb		       00 20	   COLOUR_LINES =	32
    680  43bb				   colvecX
    681  43bb		       00 00 20 20	      .byte.b	0, 0, COLOUR_LINES, COLOUR_LINES
    682  43bf
    683  43bf
    684  43bf							;blankDig ds COLOUR_LINES,0
    685  43bf
    686  43bf							;topcolour
    687  43bf
    688  43bf							;    .byte 0
    689  43bf
    690  43bf							;    REPEAT TOPHAT/2
    691  43bf							;    .byte $F2
    692  43bf							;    .byte $F0
    693  43bf							;    REPEND
    694  43bf
    695  43bf							;quest
    696  43bf							;    REPEAT 9
    697  43bf							;	  .byte $60,$60,$0
    698  43bf							;    REPEND
    699  43bf
    700  43bf				   LDIGIT
    701  43bf							;.word blankDig
    702  43bf		       30 f4		      .word.w	LEFT_0
    703  43c1		       90 f4		      .word.w	LEFT_1
    704  43c3		       00 f5		      .word.w	LEFT_2
    705  43c5		       60 f5		      .word.w	LEFT_3
    706  43c7		       c0 f5		      .word.w	LEFT_4
    707  43c9		       20 f6		      .word.w	LEFT_5
    708  43cb		       60 f6		      .word.w	LEFT_6
    709  43cd		       a0 f6		      .word.w	LEFT_7
    710  43cf		       e0 f6		      .word.w	LEFT_8
    711  43d1		       20 f7		      .word.w	LEFT_9
    712  43d3
    713  43d3				   RDIGIT
    714  43d3							;.word blankDig
    715  43d3		       50 f4		      .word.w	RIGHT_0
    716  43d5		       b0 f4		      .word.w	RIGHT_1
    717  43d7		       20 f5		      .word.w	RIGHT_2
    718  43d9		       80 f5		      .word.w	RIGHT_3
    719  43db		       e0 f5		      .word.w	RIGHT_4
    720  43dd		       40 f6		      .word.w	RIGHT_5
    721  43df		       80 f6		      .word.w	RIGHT_6
    722  43e1		       c0 f6		      .word.w	RIGHT_7
    723  43e3		       00 f7		      .word.w	RIGHT_8
    724  43e5		       40 f7		      .word.w	RIGHT_9
    725  43e7
    726  43e7				   DIGITHUND
    727  43e7							;.word blankDig
    728  43e7		       70 f4		      .word.w	HUNDPF1_0
    729  43e9		       d0 f4		      .word.w	HUNDPF1_1
    730  43eb		       40 f5		      .word.w	HUNDPF1_2
    731  43ed		       a0 f5		      .word.w	HUNDPF1_3
    732  43ef		       00 f6		      .word.w	HUNDPF1_4
    733  43f1							;	  .word HUNDPF1_5
    734  43f1							;	  .word HUNDPF1_6
    735  43f1							;	  .word HUNDPF1_7
    736  43f1							;	  .word HUNDPF1_8
    737  43f1							;	  .word HUNDPF1_9
    738  43f1							;	  .word blankDig
    739  43f1
    740  43f1
    741  43f1				   lid0
    742  43f1		       e0		      .byte.b	%11100000
    743  43f2		       e0		      .byte.b	%11100000
    744  43f3		       e0		      .byte.b	%11100000
    745  43f4		       e0		      .byte.b	%11100000
    746  43f5		       e0		      .byte.b	%11100000
    747  43f6		       e0		      .byte.b	%11100000
    748  43f7		       60		      .byte.b	%01100000
    749  43f8		       60		      .byte.b	%01100000
    750  43f9		       60		      .byte.b	%01100000
    751  43fa		       60		      .byte.b	%01100000
    752  43fb		       60		      .byte.b	%01100000
    753  43fc		       60		      .byte.b	%01100000
    754  43fd		       60		      .byte.b	%01100000
    755  43fe		       e0		      .byte.b	%11100000
    756  43ff		       e0		      .byte.b	%11100000
    757  4400		       e0		      .byte.b	%11100000
    758  4401		       e0		      .byte.b	%11100000
    759  4402		       e0		      .byte.b	%11100000
    760  4403
    761  4403				   lid1
    762  4403				   lid2
    763  4403		       ff		      .byte.b	%11111111
    764  4404		       ff		      .byte.b	%11111111
    765  4405		       ff		      .byte.b	%11111111
    766  4406		       ff		      .byte.b	%11111111
    767  4407		       ff		      .byte.b	%11111111
    768  4408		       ff		      .byte.b	%11111111
    769  4409		       ff		      .byte.b	%11111111
    770  440a		       ff		      .byte.b	%11111111
    771  440b		       ff		      .byte.b	%11111111
    772  440c		       f7		      .byte.b	%11110111
    773  440d		       f7		      .byte.b	%11110111
    774  440e		       f7		      .byte.b	%11110111
    775  440f		       f7		      .byte.b	%11110111
    776  4410		       ff		      .byte.b	%11111111
    777  4411		       ff		      .byte.b	%11111111
    778  4412		       ff		      .byte.b	%11111111
    779  4413		       ff		      .byte.b	%11111111
    780  4414		       c3		      .byte.b	%11000011
    781  4415
    782  4415				   lid3
    783  4415				   lid4
    784  4415		       ff		      .byte.b	%11111111
    785  4416		       ff		      .byte.b	%11111111
    786  4417		       ff		      .byte.b	%11111111
    787  4418		       ff		      .byte.b	%11111111
    788  4419		       ff		      .byte.b	%11111111
    789  441a		       ff		      .byte.b	%11111111
    790  441b		       ff		      .byte.b	%11111111
    791  441c		       ff		      .byte.b	%11111111
    792  441d		       ff		      .byte.b	%11111111
    793  441e		       f7		      .byte.b	%11110111
    794  441f		       f7		      .byte.b	%11110111
    795  4420		       f7		      .byte.b	%11110111
    796  4421		       f7		      .byte.b	%11110111
    797  4422		       ff		      .byte.b	%11111111
    798  4423		       ff		      .byte.b	%11111111
    799  4424		       ff		      .byte.b	%11111111
    800  4425		       ff		      .byte.b	%11111111
    801  4426		       c3		      .byte.b	%11000011
    802  4427
    803  4427				  -	      if	0
    804  4427				  -	      .byte	%11111111
    805  4427				  -	      .byte	%11111111
    806  4427				  -	      .byte	%11111111
    807  4427				  -	      .byte	%11111111
    808  4427				  -	      .byte	%11111111
    809  4427				  -	      .byte	%11111111
    810  4427				  -	      .byte	%11111011
    811  4427				  -	      .byte	%11111011
    812  4427				  -	      .byte	%11111011
    813  4427				  -	      .byte	%11111011
    814  4427				  -	      .byte	%11111011
    815  4427				  -	      .byte	%11111011
    816  4427				  -	      .byte	%11111011
    817  4427				  -	      .byte	%11111111
    818  4427				  -	      .byte	%11111111
    819  4427				  -	      .byte	%11111111
    820  4427				  -	      .byte	%11111111
    821  4427				  -	      .byte	%11000011
    822  4427					      endif
    823  4427
    824  4427				   lidb0
    825  4427				   lidb1
    826  4427				   lidb2
    827  4427				   lidb3
    828  4427				   lidb4
    829  4427
    830  4427		       aa		      .byte.b	%10101010
    831  4428		       ff		      .byte.b	%11111111
    832  4429		       ff		      .byte.b	%11111111
    833  442a		       ff		      .byte.b	%11111111
    834  442b		       ff		      .byte.b	%11111111
    835  442c		       ff		      .byte.b	%11111111
    836  442d		       ff		      .byte.b	%11111111
    837  442e		       ff		      .byte.b	%11111111
    838  442f		       ff		      .byte.b	%11111111
    839  4430
    840  4430							;    .byte |..XXX...|
    841  4430
------- FILE bigDigits.asm LEVEL 3 PASS 3
      0  4430					      include	"bigDigits.asm"
      0  4430					      OPTIONAL_PAGEBREAK	"LEFT_0", 32
     10  4430					      LIST	ON
      2  4430				   LEFT_0
      3  4430		       00		      .byte.b	0
      4  4431		       00		      .byte.b	0
      5  4432		       00		      .byte.b	0
      6  4433		       38		      .byte.b	56
      7  4434		       7c		      .byte.b	124
      8  4435		       7c		      .byte.b	124
      9  4436		       7c		      .byte.b	124
     10  4437		       ee		      .byte.b	238
     11  4438		       c6		      .byte.b	198
     12  4439		       c6		      .byte.b	198
     13  443a		       c6		      .byte.b	198
     14  443b		       c6		      .byte.b	198
     15  443c		       c6		      .byte.b	198
     16  443d		       c6		      .byte.b	198
     17  443e		       c6		      .byte.b	198
     18  443f		       c6		      .byte.b	198
     19  4440		       c6		      .byte.b	198
     20  4441		       c6		      .byte.b	198
     21  4442		       c6		      .byte.b	198
     22  4443		       c6		      .byte.b	198
     23  4444		       c6		      .byte.b	198
     24  4445		       c6		      .byte.b	198
     25  4446		       c6		      .byte.b	198
     26  4447		       c6		      .byte.b	198
     27  4448		       c6		      .byte.b	198
     28  4449		       ee		      .byte.b	238
     29  444a		       7c		      .byte.b	124
     30  444b		       7c		      .byte.b	124
     31  444c		       7c		      .byte.b	124
     32  444d		       38		      .byte.b	56
     33  444e		       00		      .byte.b	0
     34  444f		       00		      .byte.b	0
      0  4450					      OPTIONAL_PAGEBREAK	"RIGHT_0", 32
     10  4450					      LIST	ON
     36  4450				   RIGHT_0
     37  4450		       00		      .byte.b	0
     38  4451		       00		      .byte.b	0
     39  4452		       00		      .byte.b	0
     40  4453		       8c		      .byte.b	140
     41  4454		       ce		      .byte.b	206
     42  4455		       ce		      .byte.b	206
     43  4456		       ce		      .byte.b	206
     44  4457		       e7		      .byte.b	231
     45  4458		       63		      .byte.b	99
     46  4459		       63		      .byte.b	99
     47  445a		       63		      .byte.b	99
     48  445b		       63		      .byte.b	99
     49  445c		       63		      .byte.b	99
     50  445d		       63		      .byte.b	99
     51  445e		       63		      .byte.b	99
     52  445f		       63		      .byte.b	99
     53  4460		       63		      .byte.b	99
     54  4461		       63		      .byte.b	99
     55  4462		       63		      .byte.b	99
     56  4463		       63		      .byte.b	99
     57  4464		       63		      .byte.b	99
     58  4465		       63		      .byte.b	99
     59  4466		       63		      .byte.b	99
     60  4467		       63		      .byte.b	99
     61  4468		       63		      .byte.b	99
     62  4469		       e7		      .byte.b	231
     63  446a		       ce		      .byte.b	206
     64  446b		       ce		      .byte.b	206
     65  446c		       ce		      .byte.b	206
     66  446d		       8c		      .byte.b	140
     67  446e		       00		      .byte.b	0
     68  446f		       00		      .byte.b	0
      0  4470					      OPTIONAL_PAGEBREAK	"HUNDPF1_0", 32
     10  4470					      LIST	ON
     70  4470				   HUNDPF1_0
     71  4470		       00		      .byte.b	0
     72  4471		       00		      .byte.b	0
     73  4472		       00		      .byte.b	0
     74  4473		       1c		      .byte.b	28
     75  4474		       3e		      .byte.b	62
     76  4475		       3e		      .byte.b	62
     77  4476		       3e		      .byte.b	62
     78  4477		       77		      .byte.b	119
     79  4478		       63		      .byte.b	99
     80  4479		       63		      .byte.b	99
     81  447a		       63		      .byte.b	99
     82  447b		       63		      .byte.b	99
     83  447c		       63		      .byte.b	99
     84  447d		       63		      .byte.b	99
     85  447e		       63		      .byte.b	99
     86  447f		       63		      .byte.b	99
     87  4480		       63		      .byte.b	99
     88  4481		       63		      .byte.b	99
     89  4482		       63		      .byte.b	99
     90  4483		       63		      .byte.b	99
     91  4484		       63		      .byte.b	99
     92  4485		       63		      .byte.b	99
     93  4486		       63		      .byte.b	99
     94  4487		       63		      .byte.b	99
     95  4488		       63		      .byte.b	99
     96  4489		       77		      .byte.b	119
     97  448a		       3e		      .byte.b	62
     98  448b		       3e		      .byte.b	62
     99  448c		       3e		      .byte.b	62
    100  448d		       1c		      .byte.b	28
    101  448e		       00		      .byte.b	0
    102  448f		       00		      .byte.b	0
      0  4490					      OPTIONAL_PAGEBREAK	"LEFT_1", 32
     10  4490					      LIST	ON
    104  4490				   LEFT_1
    105  4490		       00		      .byte.b	0
    106  4491		       00		      .byte.b	0
    107  4492		       00		      .byte.b	0
    108  4493		       30		      .byte.b	48
    109  4494		       30		      .byte.b	48
    110  4495		       30		      .byte.b	48
    111  4496		       30		      .byte.b	48
    112  4497		       30		      .byte.b	48
    113  4498		       30		      .byte.b	48
    114  4499		       30		      .byte.b	48
    115  449a		       30		      .byte.b	48
    116  449b		       30		      .byte.b	48
    117  449c		       30		      .byte.b	48
    118  449d		       30		      .byte.b	48
    119  449e		       30		      .byte.b	48
    120  449f		       30		      .byte.b	48
    121  44a0		       30		      .byte.b	48
    122  44a1		       30		      .byte.b	48
    123  44a2		       30		      .byte.b	48
    124  44a3		       30		      .byte.b	48
    125  44a4		       30		      .byte.b	48
    126  44a5		       30		      .byte.b	48
    127  44a6		       30		      .byte.b	48
    128  44a7		       38		      .byte.b	56
    129  44a8		       38		      .byte.b	56
    130  44a9		       38		      .byte.b	56
    131  44aa		       38		      .byte.b	56
    132  44ab		       38		      .byte.b	56
    133  44ac		       30		      .byte.b	48
    134  44ad		       30		      .byte.b	48
    135  44ae		       00		      .byte.b	0
    136  44af		       00		      .byte.b	0
      0  44b0					      OPTIONAL_PAGEBREAK	"RIGHT_1", 32
     10  44b0					      LIST	ON
    138  44b0				   RIGHT_1
    139  44b0		       00		      .byte.b	0
    140  44b1		       00		      .byte.b	0
    141  44b2		       00		      .byte.b	0
    142  44b3		       0c		      .byte.b	12
    143  44b4		       0c		      .byte.b	12
    144  44b5		       0c		      .byte.b	12
    145  44b6		       0c		      .byte.b	12
    146  44b7		       0c		      .byte.b	12
    147  44b8		       0c		      .byte.b	12
    148  44b9		       0c		      .byte.b	12
    149  44ba		       0c		      .byte.b	12
    150  44bb		       0c		      .byte.b	12
    151  44bc		       0c		      .byte.b	12
    152  44bd		       0c		      .byte.b	12
    153  44be		       0c		      .byte.b	12
    154  44bf		       0c		      .byte.b	12
    155  44c0		       0c		      .byte.b	12
    156  44c1		       0c		      .byte.b	12
    157  44c2		       0c		      .byte.b	12
    158  44c3		       0c		      .byte.b	12
    159  44c4		       0c		      .byte.b	12
    160  44c5		       0c		      .byte.b	12
    161  44c6		       0c		      .byte.b	12
    162  44c7		       8c		      .byte.b	140
    163  44c8		       8c		      .byte.b	140
    164  44c9		       8c		      .byte.b	140
    165  44ca		       8c		      .byte.b	140
    166  44cb		       8c		      .byte.b	140
    167  44cc		       0c		      .byte.b	12
    168  44cd		       0c		      .byte.b	12
    169  44ce		       00		      .byte.b	0
    170  44cf		       00		      .byte.b	0
      0  44d0					      OPTIONAL_PAGEBREAK	"HUNDPF1_1", 32
     10  44d0					      LIST	ON
    172  44d0				   HUNDPF1_1
    173  44d0		       00		      .byte.b	0
    174  44d1		       00		      .byte.b	0
    175  44d2		       00		      .byte.b	0
    176  44d3		       0c		      .byte.b	12
    177  44d4		       0c		      .byte.b	12
    178  44d5		       0c		      .byte.b	12
    179  44d6		       0c		      .byte.b	12
    180  44d7		       0c		      .byte.b	12
    181  44d8		       0c		      .byte.b	12
    182  44d9		       0c		      .byte.b	12
    183  44da		       0c		      .byte.b	12
    184  44db		       0c		      .byte.b	12
    185  44dc		       0c		      .byte.b	12
    186  44dd		       0c		      .byte.b	12
    187  44de		       0c		      .byte.b	12
    188  44df		       0c		      .byte.b	12
    189  44e0		       0c		      .byte.b	12
    190  44e1		       0c		      .byte.b	12
    191  44e2		       0c		      .byte.b	12
    192  44e3		       0c		      .byte.b	12
    193  44e4		       0c		      .byte.b	12
    194  44e5		       0c		      .byte.b	12
    195  44e6		       0c		      .byte.b	12
    196  44e7		       1c		      .byte.b	28
    197  44e8		       1c		      .byte.b	28
    198  44e9		       1c		      .byte.b	28
    199  44ea		       1c		      .byte.b	28
    200  44eb		       1c		      .byte.b	28
    201  44ec		       0c		      .byte.b	12
    202  44ed		       0c		      .byte.b	12
    203  44ee		       00		      .byte.b	0
    204  44ef		       00		      .byte.b	0
      0  44f0					      OPTIONAL_PAGEBREAK	"LEFT_2", 32
 PAGE BREAK INSERTED FOR  LEFT_2
 REQUESTED SIZE =  $20
 WASTED SPACE =  $10
 PAGEBREAK LOCATION =  $f500
     10  4500					      LIST	ON
    206  4500				   LEFT_2
    207  4500		       00		      .byte.b	0
    208  4501		       00		      .byte.b	0
    209  4502		       00		      .byte.b	0
    210  4503		       fe		      .byte.b	254
    211  4504		       fe		      .byte.b	254
    212  4505		       fe		      .byte.b	254
    213  4506		       fe		      .byte.b	254
    214  4507		       c6		      .byte.b	198
    215  4508		       06		      .byte.b	6
    216  4509		       06		      .byte.b	6
    217  450a		       06		      .byte.b	6
    218  450b		       0e		      .byte.b	14
    219  450c		       0e		      .byte.b	14
    220  450d		       1c		      .byte.b	28
    221  450e		       3c		      .byte.b	60
    222  450f		       78		      .byte.b	120
    223  4510		       70		      .byte.b	112
    224  4511		       e0		      .byte.b	224
    225  4512		       e0		      .byte.b	224
    226  4513		       c0		      .byte.b	192
    227  4514		       c0		      .byte.b	192
    228  4515		       c0		      .byte.b	192
    229  4516		       c6		      .byte.b	198
    230  4517		       c6		      .byte.b	198
    231  4518		       c6		      .byte.b	198
    232  4519		       ee		      .byte.b	238
    233  451a		       fe		      .byte.b	254
    234  451b		       7c		      .byte.b	124
    235  451c		       7c		      .byte.b	124
    236  451d		       38		      .byte.b	56
    237  451e		       00		      .byte.b	0
    238  451f		       00		      .byte.b	0
      0  4520					      OPTIONAL_PAGEBREAK	"RIGHT_2", 32
     10  4520					      LIST	ON
    240  4520				   RIGHT_2
    241  4520		       00		      .byte.b	0
    242  4521		       00		      .byte.b	0
    243  4522		       00		      .byte.b	0
    244  4523		       ef		      .byte.b	239
    245  4524		       ef		      .byte.b	239
    246  4525		       ef		      .byte.b	239
    247  4526		       ef		      .byte.b	239
    248  4527		       63		      .byte.b	99
    249  4528		       60		      .byte.b	96
    250  4529		       60		      .byte.b	96
    251  452a		       60		      .byte.b	96
    252  452b		       e0		      .byte.b	224
    253  452c		       e0		      .byte.b	224
    254  452d		       c8		      .byte.b	200
    255  452e		       cc		      .byte.b	204
    256  452f		       8e		      .byte.b	142
    257  4530		       0e		      .byte.b	14
    258  4531		       07		      .byte.b	7
    259  4532		       07		      .byte.b	7
    260  4533		       03		      .byte.b	3
    261  4534		       03		      .byte.b	3
    262  4535		       03		      .byte.b	3
    263  4536		       63		      .byte.b	99
    264  4537		       63		      .byte.b	99
    265  4538		       63		      .byte.b	99
    266  4539		       e7		      .byte.b	231
    267  453a		       ef		      .byte.b	239
    268  453b		       ce		      .byte.b	206
    269  453c		       ce		      .byte.b	206
    270  453d		       8c		      .byte.b	140
    271  453e		       00		      .byte.b	0
    272  453f		       00		      .byte.b	0
      0  4540					      OPTIONAL_PAGEBREAK	"HUNDPF1_2", 32
     10  4540					      LIST	ON
    274  4540				   HUNDPF1_2
    275  4540		       00		      .byte.b	0
    276  4541		       00		      .byte.b	0
    277  4542		       00		      .byte.b	0
    278  4543		       7f		      .byte.b	127
    279  4544		       7f		      .byte.b	127
    280  4545		       7f		      .byte.b	127
    281  4546		       7f		      .byte.b	127
    282  4547		       63		      .byte.b	99
    283  4548		       60		      .byte.b	96
    284  4549		       60		      .byte.b	96
    285  454a		       60		      .byte.b	96
    286  454b		       70		      .byte.b	112
    287  454c		       70		      .byte.b	112
    288  454d		       38		      .byte.b	56
    289  454e		       3c		      .byte.b	60
    290  454f		       1e		      .byte.b	30
    291  4550		       0e		      .byte.b	14
    292  4551		       07		      .byte.b	7
    293  4552		       07		      .byte.b	7
    294  4553		       03		      .byte.b	3
    295  4554		       03		      .byte.b	3
    296  4555		       03		      .byte.b	3
    297  4556		       63		      .byte.b	99
    298  4557		       63		      .byte.b	99
    299  4558		       63		      .byte.b	99
    300  4559		       77		      .byte.b	119
    301  455a		       7f		      .byte.b	127
    302  455b		       3e		      .byte.b	62
    303  455c		       3e		      .byte.b	62
    304  455d		       1c		      .byte.b	28
    305  455e		       00		      .byte.b	0
    306  455f		       00		      .byte.b	0
      0  4560					      OPTIONAL_PAGEBREAK	"LEFT_3", 32
     10  4560					      LIST	ON
    308  4560				   LEFT_3
    309  4560		       00		      .byte.b	0
    310  4561		       00		      .byte.b	0
    311  4562		       00		      .byte.b	0
    312  4563		       38		      .byte.b	56
    313  4564		       7c		      .byte.b	124
    314  4565		       7c		      .byte.b	124
    315  4566		       fe		      .byte.b	254
    316  4567		       ee		      .byte.b	238
    317  4568		       c6		      .byte.b	198
    318  4569		       c6		      .byte.b	198
    319  456a		       c6		      .byte.b	198
    320  456b		       c0		      .byte.b	192
    321  456c		       c0		      .byte.b	192
    322  456d		       c0		      .byte.b	192
    323  456e		       e0		      .byte.b	224
    324  456f		       f8		      .byte.b	248
    325  4570		       78		      .byte.b	120
    326  4571		       78		      .byte.b	120
    327  4572		       f8		      .byte.b	248
    328  4573		       e0		      .byte.b	224
    329  4574		       c0		      .byte.b	192
    330  4575		       c0		      .byte.b	192
    331  4576		       c6		      .byte.b	198
    332  4577		       c6		      .byte.b	198
    333  4578		       c6		      .byte.b	198
    334  4579		       ee		      .byte.b	238
    335  457a		       fe		      .byte.b	254
    336  457b		       7c		      .byte.b	124
    337  457c		       7c		      .byte.b	124
    338  457d		       38		      .byte.b	56
    339  457e		       00		      .byte.b	0
    340  457f		       00		      .byte.b	0
      0  4580					      OPTIONAL_PAGEBREAK	"RIGHT_3", 32
     10  4580					      LIST	ON
    342  4580				   RIGHT_3
    343  4580		       00		      .byte.b	0
    344  4581		       00		      .byte.b	0
    345  4582		       00		      .byte.b	0
    346  4583		       8c		      .byte.b	140
    347  4584		       ce		      .byte.b	206
    348  4585		       ce		      .byte.b	206
    349  4586		       ef		      .byte.b	239
    350  4587		       e7		      .byte.b	231
    351  4588		       63		      .byte.b	99
    352  4589		       63		      .byte.b	99
    353  458a		       63		      .byte.b	99
    354  458b		       03		      .byte.b	3
    355  458c		       03		      .byte.b	3
    356  458d		       03		      .byte.b	3
    357  458e		       07		      .byte.b	7
    358  458f		       8f		      .byte.b	143
    359  4590		       8e		      .byte.b	142
    360  4591		       8e		      .byte.b	142
    361  4592		       8f		      .byte.b	143
    362  4593		       07		      .byte.b	7
    363  4594		       03		      .byte.b	3
    364  4595		       03		      .byte.b	3
    365  4596		       63		      .byte.b	99
    366  4597		       63		      .byte.b	99
    367  4598		       63		      .byte.b	99
    368  4599		       e7		      .byte.b	231
    369  459a		       ef		      .byte.b	239
    370  459b		       ce		      .byte.b	206
    371  459c		       ce		      .byte.b	206
    372  459d		       8c		      .byte.b	140
    373  459e		       00		      .byte.b	0
    374  459f		       00		      .byte.b	0
      0  45a0					      OPTIONAL_PAGEBREAK	"HUNDPF1_3", 32
     10  45a0					      LIST	ON
    376  45a0				   HUNDPF1_3
    377  45a0		       00		      .byte.b	0
    378  45a1		       00		      .byte.b	0
    379  45a2		       00		      .byte.b	0
    380  45a3		       1c		      .byte.b	28
    381  45a4		       3e		      .byte.b	62
    382  45a5		       3e		      .byte.b	62
    383  45a6		       7f		      .byte.b	127
    384  45a7		       77		      .byte.b	119
    385  45a8		       63		      .byte.b	99
    386  45a9		       63		      .byte.b	99
    387  45aa		       63		      .byte.b	99
    388  45ab		       03		      .byte.b	3
    389  45ac		       03		      .byte.b	3
    390  45ad		       03		      .byte.b	3
    391  45ae		       07		      .byte.b	7
    392  45af		       1f		      .byte.b	31
    393  45b0		       1e		      .byte.b	30
    394  45b1		       1e		      .byte.b	30
    395  45b2		       1f		      .byte.b	31
    396  45b3		       07		      .byte.b	7
    397  45b4		       03		      .byte.b	3
    398  45b5		       03		      .byte.b	3
    399  45b6		       63		      .byte.b	99
    400  45b7		       63		      .byte.b	99
    401  45b8		       63		      .byte.b	99
    402  45b9		       77		      .byte.b	119
    403  45ba		       7f		      .byte.b	127
    404  45bb		       3e		      .byte.b	62
    405  45bc		       3e		      .byte.b	62
    406  45bd		       1c		      .byte.b	28
    407  45be		       00		      .byte.b	0
    408  45bf		       00		      .byte.b	0
      0  45c0					      OPTIONAL_PAGEBREAK	"LEFT_4", 32
     10  45c0					      LIST	ON
    410  45c0				   LEFT_4
    411  45c0		       00		      .byte.b	0
    412  45c1		       00		      .byte.b	0
    413  45c2		       00		      .byte.b	0
    414  45c3		       60		      .byte.b	96
    415  45c4		       60		      .byte.b	96
    416  45c5		       60		      .byte.b	96
    417  45c6		       60		      .byte.b	96
    418  45c7		       60		      .byte.b	96
    419  45c8		       fe		      .byte.b	254
    420  45c9		       fe		      .byte.b	254
    421  45ca		       fe		      .byte.b	254
    422  45cb		       fe		      .byte.b	254
    423  45cc		       66		      .byte.b	102
    424  45cd		       66		      .byte.b	102
    425  45ce		       66		      .byte.b	102
    426  45cf		       66		      .byte.b	102
    427  45d0		       6c		      .byte.b	108
    428  45d1		       6c		      .byte.b	108
    429  45d2		       6c		      .byte.b	108
    430  45d3		       6c		      .byte.b	108
    431  45d4		       78		      .byte.b	120
    432  45d5		       78		      .byte.b	120
    433  45d6		       78		      .byte.b	120
    434  45d7		       78		      .byte.b	120
    435  45d8		       70		      .byte.b	112
    436  45d9		       70		      .byte.b	112
    437  45da		       70		      .byte.b	112
    438  45db		       70		      .byte.b	112
    439  45dc		       60		      .byte.b	96
    440  45dd		       60		      .byte.b	96
    441  45de		       00		      .byte.b	0
    442  45df		       00		      .byte.b	0
      0  45e0					      OPTIONAL_PAGEBREAK	"RIGHT_4", 32
     10  45e0					      LIST	ON
    444  45e0				   RIGHT_4
    445  45e0		       00		      .byte.b	0
    446  45e1		       00		      .byte.b	0
    447  45e2		       00		      .byte.b	0
    448  45e3		       06		      .byte.b	6
    449  45e4		       06		      .byte.b	6
    450  45e5		       06		      .byte.b	6
    451  45e6		       06		      .byte.b	6
    452  45e7		       06		      .byte.b	6
    453  45e8		       ef		      .byte.b	239
    454  45e9		       ef		      .byte.b	239
    455  45ea		       ef		      .byte.b	239
    456  45eb		       ef		      .byte.b	239
    457  45ec		       66		      .byte.b	102
    458  45ed		       66		      .byte.b	102
    459  45ee		       66		      .byte.b	102
    460  45ef		       66		      .byte.b	102
    461  45f0		       c6		      .byte.b	198
    462  45f1		       c6		      .byte.b	198
    463  45f2		       c6		      .byte.b	198
    464  45f3		       c6		      .byte.b	198
    465  45f4		       8e		      .byte.b	142
    466  45f5		       8e		      .byte.b	142
    467  45f6		       8e		      .byte.b	142
    468  45f7		       8e		      .byte.b	142
    469  45f8		       0e		      .byte.b	14
    470  45f9		       0e		      .byte.b	14
    471  45fa		       0e		      .byte.b	14
    472  45fb		       0e		      .byte.b	14
    473  45fc		       06		      .byte.b	6
    474  45fd		       06		      .byte.b	6
    475  45fe		       00		      .byte.b	0
    476  45ff		       00		      .byte.b	0
      0  4600					      OPTIONAL_PAGEBREAK	"HUNDPF1_4", 32
     10  4600					      LIST	ON
    478  4600				   HUNDPF1_4
    479  4600		       00		      .byte.b	0
    480  4601		       00		      .byte.b	0
    481  4602		       00		      .byte.b	0
    482  4603		       06		      .byte.b	6
    483  4604		       06		      .byte.b	6
    484  4605		       06		      .byte.b	6
    485  4606		       06		      .byte.b	6
    486  4607		       06		      .byte.b	6
    487  4608		       7f		      .byte.b	127
    488  4609		       7f		      .byte.b	127
    489  460a		       7f		      .byte.b	127
    490  460b		       7f		      .byte.b	127
    491  460c		       66		      .byte.b	102
    492  460d		       66		      .byte.b	102
    493  460e		       66		      .byte.b	102
    494  460f		       66		      .byte.b	102
    495  4610		       36		      .byte.b	54
    496  4611		       36		      .byte.b	54
    497  4612		       36		      .byte.b	54
    498  4613		       36		      .byte.b	54
    499  4614		       1e		      .byte.b	30
    500  4615		       1e		      .byte.b	30
    501  4616		       1e		      .byte.b	30
    502  4617		       1e		      .byte.b	30
    503  4618		       0e		      .byte.b	14
    504  4619		       0e		      .byte.b	14
    505  461a		       0e		      .byte.b	14
    506  461b		       0e		      .byte.b	14
    507  461c		       06		      .byte.b	6
    508  461d		       06		      .byte.b	6
    509  461e		       00		      .byte.b	0
    510  461f		       00		      .byte.b	0
      0  4620					      OPTIONAL_PAGEBREAK	"LEFT_5", 32
     10  4620					      LIST	ON
    512  4620				   LEFT_5
    513  4620		       00		      .byte.b	0
    514  4621		       00		      .byte.b	0
    515  4622		       00		      .byte.b	0
    516  4623		       38		      .byte.b	56
    517  4624		       7c		      .byte.b	124
    518  4625		       7c		      .byte.b	124
    519  4626		       fe		      .byte.b	254
    520  4627		       ee		      .byte.b	238
    521  4628		       c6		      .byte.b	198
    522  4629		       c6		      .byte.b	198
    523  462a		       c6		      .byte.b	198
    524  462b		       c0		      .byte.b	192
    525  462c		       c0		      .byte.b	192
    526  462d		       c0		      .byte.b	192
    527  462e		       c0		      .byte.b	192
    528  462f		       c0		      .byte.b	192
    529  4630		       c0		      .byte.b	192
    530  4631		       e6		      .byte.b	230
    531  4632		       fe		      .byte.b	254
    532  4633		       7e		      .byte.b	126
    533  4634		       7e		      .byte.b	126
    534  4635		       36		      .byte.b	54
    535  4636		       06		      .byte.b	6
    536  4637		       06		      .byte.b	6
    537  4638		       06		      .byte.b	6
    538  4639		       c6		      .byte.b	198
    539  463a		       fe		      .byte.b	254
    540  463b		       fe		      .byte.b	254
    541  463c		       fe		      .byte.b	254
    542  463d		       fe		      .byte.b	254
    543  463e		       00		      .byte.b	0
    544  463f		       00		      .byte.b	0
      0  4640					      OPTIONAL_PAGEBREAK	"RIGHT_5", 32
     10  4640					      LIST	ON
    546  4640				   RIGHT_5
    547  4640		       00		      .byte.b	0
    548  4641		       00		      .byte.b	0
    549  4642		       00		      .byte.b	0
    550  4643		       8c		      .byte.b	140
    551  4644		       ce		      .byte.b	206
    552  4645		       ce		      .byte.b	206
    553  4646		       ef		      .byte.b	239
    554  4647		       e7		      .byte.b	231
    555  4648		       63		      .byte.b	99
    556  4649		       63		      .byte.b	99
    557  464a		       63		      .byte.b	99
    558  464b		       03		      .byte.b	3
    559  464c		       03		      .byte.b	3
    560  464d		       03		      .byte.b	3
    561  464e		       03		      .byte.b	3
    562  464f		       03		      .byte.b	3
    563  4650		       03		      .byte.b	3
    564  4651		       67		      .byte.b	103
    565  4652		       ef		      .byte.b	239
    566  4653		       ee		      .byte.b	238
    567  4654		       ee		      .byte.b	238
    568  4655		       6c		      .byte.b	108
    569  4656		       60		      .byte.b	96
    570  4657		       60		      .byte.b	96
    571  4658		       60		      .byte.b	96
    572  4659		       63		      .byte.b	99
    573  465a		       ef		      .byte.b	239
    574  465b		       ef		      .byte.b	239
    575  465c		       ef		      .byte.b	239
    576  465d		       ef		      .byte.b	239
    577  465e		       00		      .byte.b	0
    578  465f		       00		      .byte.b	0
      0  4660					      OPTIONAL_PAGEBREAK	"HUNDPF1_5", 32
     10  4660					      LIST	ON
    580  4660				   HUNDPF1_5
      0  4660					      OPTIONAL_PAGEBREAK	"LEFT_6", 32
     10  4660					      LIST	ON
    582  4660				   LEFT_6
    583  4660		       00		      .byte.b	0
    584  4661		       00		      .byte.b	0
    585  4662		       00		      .byte.b	0
    586  4663		       38		      .byte.b	56
    587  4664		       7c		      .byte.b	124
    588  4665		       7c		      .byte.b	124
    589  4666		       fe		      .byte.b	254
    590  4667		       ee		      .byte.b	238
    591  4668		       c6		      .byte.b	198
    592  4669		       c6		      .byte.b	198
    593  466a		       c6		      .byte.b	198
    594  466b		       c6		      .byte.b	198
    595  466c		       c6		      .byte.b	198
    596  466d		       c6		      .byte.b	198
    597  466e		       ee		      .byte.b	238
    598  466f		       fe		      .byte.b	254
    599  4670		       7e		      .byte.b	126
    600  4671		       7e		      .byte.b	126
    601  4672		       36		      .byte.b	54
    602  4673		       06		      .byte.b	6
    603  4674		       06		      .byte.b	6
    604  4675		       0e		      .byte.b	14
    605  4676		       0c		      .byte.b	12
    606  4677		       0c		      .byte.b	12
    607  4678		       1c		      .byte.b	28
    608  4679		       1c		      .byte.b	28
    609  467a		       78		      .byte.b	120
    610  467b		       78		      .byte.b	120
    611  467c		       70		      .byte.b	112
    612  467d		       60		      .byte.b	96
    613  467e		       00		      .byte.b	0
    614  467f		       00		      .byte.b	0
      0  4680					      OPTIONAL_PAGEBREAK	"RIGHT_6", 32
     10  4680					      LIST	ON
    616  4680				   RIGHT_6
    617  4680		       00		      .byte.b	0
    618  4681		       00		      .byte.b	0
    619  4682		       00		      .byte.b	0
    620  4683		       8c		      .byte.b	140
    621  4684		       ce		      .byte.b	206
    622  4685		       ce		      .byte.b	206
    623  4686		       ef		      .byte.b	239
    624  4687		       e7		      .byte.b	231
    625  4688		       63		      .byte.b	99
    626  4689		       63		      .byte.b	99
    627  468a		       63		      .byte.b	99
    628  468b		       63		      .byte.b	99
    629  468c		       63		      .byte.b	99
    630  468d		       63		      .byte.b	99
    631  468e		       e7		      .byte.b	231
    632  468f		       ef		      .byte.b	239
    633  4690		       ee		      .byte.b	238
    634  4691		       ee		      .byte.b	238
    635  4692		       6c		      .byte.b	108
    636  4693		       60		      .byte.b	96
    637  4694		       60		      .byte.b	96
    638  4695		       e0		      .byte.b	224
    639  4696		       c0		      .byte.b	192
    640  4697		       c0		      .byte.b	192
    641  4698		       c8		      .byte.b	200
    642  4699		       c8		      .byte.b	200
    643  469a		       8e		      .byte.b	142
    644  469b		       8e		      .byte.b	142
    645  469c		       0e		      .byte.b	14
    646  469d		       06		      .byte.b	6
    647  469e		       00		      .byte.b	0
    648  469f		       00		      .byte.b	0
      0  46a0					      OPTIONAL_PAGEBREAK	"HUNDPF1_6", 32
     10  46a0					      LIST	ON
    650  46a0				   HUNDPF1_6
      0  46a0					      OPTIONAL_PAGEBREAK	"LEFT_7", 32
     10  46a0					      LIST	ON
    652  46a0				   LEFT_7
    653  46a0		       00		      .byte.b	0
    654  46a1		       00		      .byte.b	0
    655  46a2		       00		      .byte.b	0
    656  46a3		       18		      .byte.b	24
    657  46a4		       18		      .byte.b	24
    658  46a5		       18		      .byte.b	24
    659  46a6		       18		      .byte.b	24
    660  46a7		       18		      .byte.b	24
    661  46a8		       18		      .byte.b	24
    662  46a9		       18		      .byte.b	24
    663  46aa		       18		      .byte.b	24
    664  46ab		       18		      .byte.b	24
    665  46ac		       18		      .byte.b	24
    666  46ad		       18		      .byte.b	24
    667  46ae		       30		      .byte.b	48
    668  46af		       30		      .byte.b	48
    669  46b0		       30		      .byte.b	48
    670  46b1		       30		      .byte.b	48
    671  46b2		       60		      .byte.b	96
    672  46b3		       60		      .byte.b	96
    673  46b4		       60		      .byte.b	96
    674  46b5		       60		      .byte.b	96
    675  46b6		       c0		      .byte.b	192
    676  46b7		       c0		      .byte.b	192
    677  46b8		       c0		      .byte.b	192
    678  46b9		       c6		      .byte.b	198
    679  46ba		       fe		      .byte.b	254
    680  46bb		       fe		      .byte.b	254
    681  46bc		       fe		      .byte.b	254
    682  46bd		       fe		      .byte.b	254
    683  46be		       00		      .byte.b	0
    684  46bf		       00		      .byte.b	0
      0  46c0					      OPTIONAL_PAGEBREAK	"RIGHT_7", 32
     10  46c0					      LIST	ON
    686  46c0				   RIGHT_7
    687  46c0		       00		      .byte.b	0
    688  46c1		       00		      .byte.b	0
    689  46c2		       00		      .byte.b	0
    690  46c3		       88		      .byte.b	136
    691  46c4		       88		      .byte.b	136
    692  46c5		       88		      .byte.b	136
    693  46c6		       88		      .byte.b	136
    694  46c7		       88		      .byte.b	136
    695  46c8		       88		      .byte.b	136
    696  46c9		       88		      .byte.b	136
    697  46ca		       88		      .byte.b	136
    698  46cb		       88		      .byte.b	136
    699  46cc		       88		      .byte.b	136
    700  46cd		       88		      .byte.b	136
    701  46ce		       0c		      .byte.b	12
    702  46cf		       0c		      .byte.b	12
    703  46d0		       0c		      .byte.b	12
    704  46d1		       0c		      .byte.b	12
    705  46d2		       06		      .byte.b	6
    706  46d3		       06		      .byte.b	6
    707  46d4		       06		      .byte.b	6
    708  46d5		       06		      .byte.b	6
    709  46d6		       03		      .byte.b	3
    710  46d7		       03		      .byte.b	3
    711  46d8		       03		      .byte.b	3
    712  46d9		       63		      .byte.b	99
    713  46da		       ef		      .byte.b	239
    714  46db		       ef		      .byte.b	239
    715  46dc		       ef		      .byte.b	239
    716  46dd		       ef		      .byte.b	239
    717  46de		       00		      .byte.b	0
    718  46df		       00		      .byte.b	0
      0  46e0					      OPTIONAL_PAGEBREAK	"HUNDPF1_7", 32
     10  46e0					      LIST	ON
    720  46e0				   HUNDPF1_7
      0  46e0					      OPTIONAL_PAGEBREAK	"LEFT_8", 32
     10  46e0					      LIST	ON
    722  46e0				   LEFT_8
    723  46e0		       00		      .byte.b	0
    724  46e1		       00		      .byte.b	0
    725  46e2		       00		      .byte.b	0
    726  46e3		       38		      .byte.b	56
    727  46e4		       7c		      .byte.b	124
    728  46e5		       7c		      .byte.b	124
    729  46e6		       fe		      .byte.b	254
    730  46e7		       ee		      .byte.b	238
    731  46e8		       c6		      .byte.b	198
    732  46e9		       c6		      .byte.b	198
    733  46ea		       c6		      .byte.b	198
    734  46eb		       c6		      .byte.b	198
    735  46ec		       c6		      .byte.b	198
    736  46ed		       c6		      .byte.b	198
    737  46ee		       ee		      .byte.b	238
    738  46ef		       fc		      .byte.b	252
    739  46f0		       7c		      .byte.b	124
    740  46f1		       7e		      .byte.b	126
    741  46f2		       ee		      .byte.b	238
    742  46f3		       c6		      .byte.b	198
    743  46f4		       c6		      .byte.b	198
    744  46f5		       c6		      .byte.b	198
    745  46f6		       c6		      .byte.b	198
    746  46f7		       c6		      .byte.b	198
    747  46f8		       c6		      .byte.b	198
    748  46f9		       ee		      .byte.b	238
    749  46fa		       fe		      .byte.b	254
    750  46fb		       7c		      .byte.b	124
    751  46fc		       7c		      .byte.b	124
    752  46fd		       38		      .byte.b	56
    753  46fe		       00		      .byte.b	0
    754  46ff		       00		      .byte.b	0
      0  4700					      OPTIONAL_PAGEBREAK	"RIGHT_8", 32
     10  4700					      LIST	ON
    756  4700				   RIGHT_8
    757  4700		       00		      .byte.b	0
    758  4701		       00		      .byte.b	0
    759  4702		       00		      .byte.b	0
    760  4703		       8c		      .byte.b	140
    761  4704		       ce		      .byte.b	206
    762  4705		       ce		      .byte.b	206
    763  4706		       ef		      .byte.b	239
    764  4707		       e7		      .byte.b	231
    765  4708		       63		      .byte.b	99
    766  4709		       63		      .byte.b	99
    767  470a		       63		      .byte.b	99
    768  470b		       63		      .byte.b	99
    769  470c		       63		      .byte.b	99
    770  470d		       63		      .byte.b	99
    771  470e		       e7		      .byte.b	231
    772  470f		       cf		      .byte.b	207
    773  4710		       ce		      .byte.b	206
    774  4711		       ee		      .byte.b	238
    775  4712		       e7		      .byte.b	231
    776  4713		       63		      .byte.b	99
    777  4714		       63		      .byte.b	99
    778  4715		       63		      .byte.b	99
    779  4716		       63		      .byte.b	99
    780  4717		       63		      .byte.b	99
    781  4718		       63		      .byte.b	99
    782  4719		       e7		      .byte.b	231
    783  471a		       ef		      .byte.b	239
    784  471b		       ce		      .byte.b	206
    785  471c		       ce		      .byte.b	206
    786  471d		       8c		      .byte.b	140
    787  471e		       00		      .byte.b	0
    788  471f		       00		      .byte.b	0
      0  4720					      OPTIONAL_PAGEBREAK	"HUNDPF1_8", 32
     10  4720					      LIST	ON
    790  4720				   HUNDPF1_8
      0  4720					      OPTIONAL_PAGEBREAK	"LEFT_9", 32
     10  4720					      LIST	ON
    792  4720				   LEFT_9
    793  4720		       00		      .byte.b	0
    794  4721		       00		      .byte.b	0
    795  4722		       00		      .byte.b	0
    796  4723		       0c		      .byte.b	12
    797  4724		       1c		      .byte.b	28
    798  4725		       3c		      .byte.b	60
    799  4726		       3c		      .byte.b	60
    800  4727		       70		      .byte.b	112
    801  4728		       70		      .byte.b	112
    802  4729		       60		      .byte.b	96
    803  472a		       e0		      .byte.b	224
    804  472b		       e0		      .byte.b	224
    805  472c		       c0		      .byte.b	192
    806  472d		       c0		      .byte.b	192
    807  472e		       d8		      .byte.b	216
    808  472f		       fc		      .byte.b	252
    809  4730		       fc		      .byte.b	252
    810  4731		       fe		      .byte.b	254
    811  4732		       ee		      .byte.b	238
    812  4733		       c6		      .byte.b	198
    813  4734		       c6		      .byte.b	198
    814  4735		       c6		      .byte.b	198
    815  4736		       c6		      .byte.b	198
    816  4737		       c6		      .byte.b	198
    817  4738		       c6		      .byte.b	198
    818  4739		       ee		      .byte.b	238
    819  473a		       fe		      .byte.b	254
    820  473b		       7c		      .byte.b	124
    821  473c		       7c		      .byte.b	124
    822  473d		       38		      .byte.b	56
    823  473e		       00		      .byte.b	0
    824  473f		       00		      .byte.b	0
      0  4740					      OPTIONAL_PAGEBREAK	"RIGHT_9", 32
     10  4740					      LIST	ON
    826  4740				   RIGHT_9
    827  4740		       00		      .byte.b	0
    828  4741		       00		      .byte.b	0
    829  4742		       00		      .byte.b	0
    830  4743		       c0		      .byte.b	192
    831  4744		       c8		      .byte.b	200
    832  4745		       cc		      .byte.b	204
    833  4746		       cc		      .byte.b	204
    834  4747		       0e		      .byte.b	14
    835  4748		       0e		      .byte.b	14
    836  4749		       06		      .byte.b	6
    837  474a		       07		      .byte.b	7
    838  474b		       07		      .byte.b	7
    839  474c		       03		      .byte.b	3
    840  474d		       03		      .byte.b	3
    841  474e		       8b		      .byte.b	139
    842  474f		       cf		      .byte.b	207
    843  4750		       cf		      .byte.b	207
    844  4751		       ef		      .byte.b	239
    845  4752		       e7		      .byte.b	231
    846  4753		       63		      .byte.b	99
    847  4754		       63		      .byte.b	99
    848  4755		       63		      .byte.b	99
    849  4756		       63		      .byte.b	99
    850  4757		       63		      .byte.b	99
    851  4758		       63		      .byte.b	99
    852  4759		       e7		      .byte.b	231
    853  475a		       ef		      .byte.b	239
    854  475b		       ce		      .byte.b	206
    855  475c		       ce		      .byte.b	206
    856  475d		       8c		      .byte.b	140
    857  475e		       00		      .byte.b	0
    858  475f		       00		      .byte.b	0
      0  4760					      OPTIONAL_PAGEBREAK	"HUNDPF1_9", 32
     10  4760					      LIST	ON
    860  4760				   HUNDPF1_9
      0  4760					      OPTIONAL_PAGEBREAK	"LEFT_star0", 32
     10  4760					      LIST	ON
    862  4760				   LEFT_star0
    863  4760		       2c		      .byte.b	44
    864  4761		       00		      .byte.b	0
    865  4762		       28		      .byte.b	40
    866  4763		       28		      .byte.b	40
    867  4764		       28		      .byte.b	40
    868  4765		       28		      .byte.b	40
    869  4766		       38		      .byte.b	56
    870  4767		       38		      .byte.b	56
    871  4768		       28		      .byte.b	40
    872  4769		       38		      .byte.b	56
    873  476a		       38		      .byte.b	56
    874  476b		       38		      .byte.b	56
    875  476c		       38		      .byte.b	56
    876  476d		       fe		      .byte.b	254
    877  476e		       fe		      .byte.b	254
    878  476f		       b2		      .byte.b	178
    879  4770		       ba		      .byte.b	186
    880  4771		       b2		      .byte.b	178
    881  4772		       30		      .byte.b	48
    882  4773		       18		      .byte.b	24
    883  4774		       14		      .byte.b	20
    884  4775		       08		      .byte.b	8
    885  4776		       3c		      .byte.b	60
    886  4777		       3a		      .byte.b	58
    887  4778		       00		      .byte.b	0
    888  4779		       00		      .byte.b	0
    889  477a		       00		      .byte.b	0
    890  477b		       00		      .byte.b	0
    891  477c		       00		      .byte.b	0
    892  477d		       00		      .byte.b	0
    893  477e		       00		      .byte.b	0
    894  477f		       00		      .byte.b	0
      0  4780					      OPTIONAL_PAGEBREAK	"LEFT_star1", 32
     10  4780					      LIST	ON
    896  4780				   LEFT_star1
    897  4780		       46		      .byte.b	70
    898  4781		       80		      .byte.b	128
    899  4782		       64		      .byte.b	100
    900  4783		       62		      .byte.b	98
    901  4784		       1e		      .byte.b	30
    902  4785		       3c		      .byte.b	60
    903  4786		       28		      .byte.b	40
    904  4787		       30		      .byte.b	48
    905  4788		       38		      .byte.b	56
    906  4789		       38		      .byte.b	56
    907  478a		       38		      .byte.b	56
    908  478b		       3c		      .byte.b	60
    909  478c		       3e		      .byte.b	62
    910  478d		       3f		      .byte.b	63
    911  478e		       19		      .byte.b	25
    912  478f		       19		      .byte.b	25
    913  4790		       1d		      .byte.b	29
    914  4791		       18		      .byte.b	24
    915  4792		       0c		      .byte.b	12
    916  4793		       0a		      .byte.b	10
    917  4794		       04		      .byte.b	4
    918  4795		       1e		      .byte.b	30
    919  4796		       1d		      .byte.b	29
    920  4797		       00		      .byte.b	0
    921  4798		       00		      .byte.b	0
    922  4799		       00		      .byte.b	0
    923  479a		       00		      .byte.b	0
    924  479b		       00		      .byte.b	0
    925  479c		       00		      .byte.b	0
    926  479d		       00		      .byte.b	0
    927  479e		       00		      .byte.b	0
    928  479f		       00		      .byte.b	0
      0  47a0					      OPTIONAL_PAGEBREAK	"LEFT_star2", 32
     10  47a0					      LIST	ON
    930  47a0				   LEFT_star2
    931  47a0		       26		      .byte.b	38
    932  47a1		       40		      .byte.b	64
    933  47a2		       34		      .byte.b	52
    934  47a3		       14		      .byte.b	20
    935  47a4		       14		      .byte.b	20
    936  47a5		       3c		      .byte.b	60
    937  47a6		       3c		      .byte.b	60
    938  47a7		       28		      .byte.b	40
    939  47a8		       30		      .byte.b	48
    940  47a9		       38		      .byte.b	56
    941  47aa		       38		      .byte.b	56
    942  47ab		       38		      .byte.b	56
    943  47ac		       3c		      .byte.b	60
    944  47ad		       3e		      .byte.b	62
    945  47ae		       3f		      .byte.b	63
    946  47af		       19		      .byte.b	25
    947  47b0		       19		      .byte.b	25
    948  47b1		       1d		      .byte.b	29
    949  47b2		       18		      .byte.b	24
    950  47b3		       0c		      .byte.b	12
    951  47b4		       0a		      .byte.b	10
    952  47b5		       04		      .byte.b	4
    953  47b6		       1e		      .byte.b	30
    954  47b7		       1d		      .byte.b	29
    955  47b8		       00		      .byte.b	0
    956  47b9		       00		      .byte.b	0
    957  47ba		       00		      .byte.b	0
    958  47bb		       00		      .byte.b	0
    959  47bc		       00		      .byte.b	0
    960  47bd		       00		      .byte.b	0
    961  47be		       00		      .byte.b	0
    962  47bf		       00		      .byte.b	0
      0  47c0					      OPTIONAL_PAGEBREAK	"LEFT_star3", 32
     10  47c0					      LIST	ON
    964  47c0				   LEFT_star3
    965  47c0		       46		      .byte.b	70
    966  47c1		       80		      .byte.b	128
    967  47c2		       64		      .byte.b	100
    968  47c3		       72		      .byte.b	114
    969  47c4		       3e		      .byte.b	62
    970  47c5		       3c		      .byte.b	60
    971  47c6		       18		      .byte.b	24
    972  47c7		       30		      .byte.b	48
    973  47c8		       38		      .byte.b	56
    974  47c9		       38		      .byte.b	56
    975  47ca		       38		      .byte.b	56
    976  47cb		       3c		      .byte.b	60
    977  47cc		       3e		      .byte.b	62
    978  47cd		       3f		      .byte.b	63
    979  47ce		       19		      .byte.b	25
    980  47cf		       19		      .byte.b	25
    981  47d0		       1d		      .byte.b	29
    982  47d1		       18		      .byte.b	24
    983  47d2		       0c		      .byte.b	12
    984  47d3		       0a		      .byte.b	10
    985  47d4		       04		      .byte.b	4
    986  47d5		       1e		      .byte.b	30
    987  47d6		       1d		      .byte.b	29
    988  47d7		       00		      .byte.b	0
    989  47d8		       00		      .byte.b	0
    990  47d9		       00		      .byte.b	0
    991  47da		       00		      .byte.b	0
    992  47db		       00		      .byte.b	0
    993  47dc		       00		      .byte.b	0
    994  47dd		       00		      .byte.b	0
    995  47de		       00		      .byte.b	0
    996  47df		       00		      .byte.b	0
------- FILE levelScreen.asm
    843  47e0
      0  47e0					      CHECK_BANK_SIZE	"LEVELSCREEN"
      1  47e0		       07 e0	   .TEMP      =	* - BANK_START
 LEVELSCREEN (2K) SIZE =  $7e0 , FREE= $20
      2  47e0					      ECHO	"LEVELSCREEN", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  47e0				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  47e0				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  47e0				  -	      ERR
      6  47e0					      endif
------- FILE ./sokoboo.asm
------- FILE coder.asm LEVEL 2 PASS 3
      0  47e0					      include	"coder.asm"
      0  47e0					      NEWBANK	CODER
      1  4fbd ????				      SEG	CODER
      2  4800					      ORG	ORIGIN
      3  4800					      RORG	$F000
      4  4800				   BANK_START SET	*
      5  4800				   CODER      SET	ORIGIN / 2048
      6  4800				   ORIGIN     SET	ORIGIN + 2048
      7  4800				   _CURRENT_BANK SET	CODER
      2  4800
      3  4800
      0  4800					      DEFINE_SUBROUTINE	xdigitBlock
      1  4800		       00 09	   BANK_xdigitBlock =	_CURRENT_BANK
      2  4800					      SUBROUTINE
      3  4800				   xdigitBlock
      5  4800
      6  4800		       a0 1a		      ldy	#26	; #lines in characters-1
      7  4802
      8  4802		       a2 00		      ldx	#0	; used as a generic "0" during the kernel
      9  4804		       85 42		      sta	WSYNC
     10  4806
      0  4806					      SLEEP	72
      1  4806				   .CYCLES    SET	72
      2  4806
      3  4806				  -	      IF	.CYCLES < 2
      4  4806				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4806				  -	      ERR
      6  4806					      ENDIF
      7  4806
      8  4806				  -	      IF	.CYCLES & 1
      9  4806				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  4806				  -	      nop	0
     11  4806				  -	      ELSE
     12  4806				  -	      bit	VSYNC
     13  4806				  -	      ENDIF
     14  4806				  -.CYCLES    SET	.CYCLES - 3
     15  4806					      ENDIF
     16  4806
     17  4806					      REPEAT	.CYCLES / 2
     18  4806		       ea		      nop
     17  4806					      REPEND
     18  4807		       ea		      nop
     17  4807					      REPEND
     18  4808		       ea		      nop
     17  4808					      REPEND
     18  4809		       ea		      nop
     17  4809					      REPEND
     18  480a		       ea		      nop
     17  480a					      REPEND
     18  480b		       ea		      nop
     17  480b					      REPEND
     18  480c		       ea		      nop
     17  480c					      REPEND
     18  480d		       ea		      nop
     17  480d					      REPEND
     18  480e		       ea		      nop
     17  480e					      REPEND
     18  480f		       ea		      nop
     17  480f					      REPEND
     18  4810		       ea		      nop
     17  4810					      REPEND
     18  4811		       ea		      nop
     17  4811					      REPEND
     18  4812		       ea		      nop
     17  4812					      REPEND
     18  4813		       ea		      nop
     17  4813					      REPEND
     18  4814		       ea		      nop
     17  4814					      REPEND
     18  4815		       ea		      nop
     17  4815					      REPEND
     18  4816		       ea		      nop
     17  4816					      REPEND
     18  4817		       ea		      nop
     17  4817					      REPEND
     18  4818		       ea		      nop
     17  4818					      REPEND
     18  4819		       ea		      nop
     17  4819					      REPEND
     18  481a		       ea		      nop
     17  481a					      REPEND
     18  481b		       ea		      nop
     17  481b					      REPEND
     18  481c		       ea		      nop
     17  481c					      REPEND
     18  481d		       ea		      nop
     17  481d					      REPEND
     18  481e		       ea		      nop
     17  481e					      REPEND
     18  481f		       ea		      nop
     17  481f					      REPEND
     18  4820		       ea		      nop
     17  4820					      REPEND
     18  4821		       ea		      nop
     17  4821					      REPEND
     18  4822		       ea		      nop
     17  4822					      REPEND
     18  4823		       ea		      nop
     17  4823					      REPEND
     18  4824		       ea		      nop
     17  4824					      REPEND
     18  4825		       ea		      nop
     17  4825					      REPEND
     18  4826		       ea		      nop
     17  4826					      REPEND
     18  4827		       ea		      nop
     17  4827					      REPEND
     18  4828		       ea		      nop
     17  4828					      REPEND
     18  4829		       ea		      nop
     19  482a					      REPEND
     12  482a
     13  482a				   .LOOPCC    SET	0
     14  482a				   blockLine
     15  482a
     16  482a					      REPEAT	2
     17  482a
     18  482a		       86 4d		      stx	PF0	; 3
     19  482c
     20  482c		       b1 e7		      lda	(bigdigit0),y	; 5
     21  482e		       85 4e		      sta	PF1	; 3 = 8 @11
     22  4830
     23  4830		       b1 e9		      lda	(bigdigit1),y	; 5
     24  4832		       85 4f		      sta	PF2	; 3 = 8 @19
     25  4834
     26  4834
     27  4834							; RHS
     28  4834
     29  4834
     30  4834		       b1 eb		      lda	(bigdigit2),y	; 5
     31  4836		       85 4d		      sta	PF0	; 3 = 8 @27	   D7D6D5D4 <--- mirrored
     32  4838
     33  4838		       0a		      asl		; 2
     34  4839		       0a		      asl		; 2
     35  483a		       0a		      asl		; 2
     36  483b		       0a		      asl		; 2 = 8 @35
     37  483c
     38  483c		       85 ef		      sta	codeTemp	; 3
     39  483e		       b1 ed		      lda	(bigdigit3),y	; 5
     40  4840		       29 0f		      and	#$f	; 2
     41  4842		       05 ef		      ora	codeTemp	; 3
     42  4844		       85 4e		      sta	PF1	; 3 = 16 @ 51	      NOT MIRRORED, D7D6D5D4 -->
     43  4846
     44  4846		       b1 ed		      lda	(bigdigit3),y	; 5
     45  4848		       4a		      lsr		; 2
     46  4849		       4a		      lsr		; 2
     47  484a		       4a		      lsr		; 2
     48  484b		       4a		      lsr		; 2
     49  484c		       85 4f		      sta	PF2	; 3 = 16 @67
     50  484e
      0  484e					      SLEEP	2
      1  484e				   .CYCLES    SET	2
      2  484e
      3  484e				  -	      IF	.CYCLES < 2
      4  484e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  484e				  -	      ERR
      6  484e					      ENDIF
      7  484e
      8  484e				  -	      IF	.CYCLES & 1
      9  484e				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  484e				  -	      nop	0
     11  484e				  -	      ELSE
     12  484e				  -	      bit	VSYNC
     13  484e				  -	      ENDIF
     14  484e				  -.CYCLES    SET	.CYCLES - 3
     15  484e					      ENDIF
     16  484e
     17  484e					      REPEAT	.CYCLES / 2
     18  484e		       ea		      nop
     19  484f					      REPEND
      0  484f					      SLEEP	2	; @71
      1  484f				   .CYCLES    SET	2
      2  484f
      3  484f				  -	      IF	.CYCLES < 2
      4  484f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  484f				  -	      ERR
      6  484f					      ENDIF
      7  484f
      8  484f				  -	      IF	.CYCLES & 1
      9  484f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  484f				  -	      nop	0
     11  484f				  -	      ELSE
     12  484f				  -	      bit	VSYNC
     13  484f				  -	      ENDIF
     14  484f				  -.CYCLES    SET	.CYCLES - 3
     15  484f					      ENDIF
     16  484f
     17  484f					      REPEAT	.CYCLES / 2
     18  484f		       ea		      nop
     19  4850					      REPEND
     53  4850
     54  4850
     55  4850					      IF	.LOOPCC = 0
      0  4850					      SLEEP	5
      1  4850				   .CYCLES    SET	5
      2  4850
      3  4850				  -	      IF	.CYCLES < 2
      4  4850				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4850				  -	      ERR
      6  4850					      ENDIF
      7  4850
      8  4850					      IF	.CYCLES & 1
      9  4850					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4850		       04 00		      nop	0
     11  4852				  -	      ELSE
     12  4852				  -	      bit	VSYNC
     13  4852					      ENDIF
     14  4852				   .CYCLES    SET	.CYCLES - 3
     15  4852					      ENDIF
     16  4852
     17  4852					      REPEAT	.CYCLES / 2
     18  4852		       ea		      nop
     19  4853					      REPEND
     57  4853					      ENDIF
     58  4853				   .LOOPCC    SET	.LOOPCC + 1
     59  4853
     60  4853
     16  4853					      REPEND
     17  4853
     18  4853		       86 4d		      stx	PF0	; 3
     19  4855
     20  4855		       b1 e7		      lda	(bigdigit0),y	; 5
     21  4857		       85 4e		      sta	PF1	; 3 = 8 @11
     22  4859
     23  4859		       b1 e9		      lda	(bigdigit1),y	; 5
     24  485b		       85 4f		      sta	PF2	; 3 = 8 @19
     25  485d
     26  485d
     27  485d							; RHS
     28  485d
     29  485d
     30  485d		       b1 eb		      lda	(bigdigit2),y	; 5
     31  485f		       85 4d		      sta	PF0	; 3 = 8 @27	   D7D6D5D4 <--- mirrored
     32  4861
     33  4861		       0a		      asl		; 2
     34  4862		       0a		      asl		; 2
     35  4863		       0a		      asl		; 2
     36  4864		       0a		      asl		; 2 = 8 @35
     37  4865
     38  4865		       85 ef		      sta	codeTemp	; 3
     39  4867		       b1 ed		      lda	(bigdigit3),y	; 5
     40  4869		       29 0f		      and	#$f	; 2
     41  486b		       05 ef		      ora	codeTemp	; 3
     42  486d		       85 4e		      sta	PF1	; 3 = 16 @ 51	      NOT MIRRORED, D7D6D5D4 -->
     43  486f
     44  486f		       b1 ed		      lda	(bigdigit3),y	; 5
     45  4871		       4a		      lsr		; 2
     46  4872		       4a		      lsr		; 2
     47  4873		       4a		      lsr		; 2
     48  4874		       4a		      lsr		; 2
     49  4875		       85 4f		      sta	PF2	; 3 = 16 @67
     50  4877
      0  4877					      SLEEP	2
      1  4877				   .CYCLES    SET	2
      2  4877
      3  4877				  -	      IF	.CYCLES < 2
      4  4877				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4877				  -	      ERR
      6  4877					      ENDIF
      7  4877
      8  4877				  -	      IF	.CYCLES & 1
      9  4877				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  4877				  -	      nop	0
     11  4877				  -	      ELSE
     12  4877				  -	      bit	VSYNC
     13  4877				  -	      ENDIF
     14  4877				  -.CYCLES    SET	.CYCLES - 3
     15  4877					      ENDIF
     16  4877
     17  4877					      REPEAT	.CYCLES / 2
     18  4877		       ea		      nop
     19  4878					      REPEND
      0  4878					      SLEEP	2	; @71
      1  4878				   .CYCLES    SET	2
      2  4878
      3  4878				  -	      IF	.CYCLES < 2
      4  4878				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4878				  -	      ERR
      6  4878					      ENDIF
      7  4878
      8  4878				  -	      IF	.CYCLES & 1
      9  4878				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  4878				  -	      nop	0
     11  4878				  -	      ELSE
     12  4878				  -	      bit	VSYNC
     13  4878				  -	      ENDIF
     14  4878				  -.CYCLES    SET	.CYCLES - 3
     15  4878					      ENDIF
     16  4878
     17  4878					      REPEAT	.CYCLES / 2
     18  4878		       ea		      nop
     19  4879					      REPEND
     53  4879
     54  4879
     55  4879				  -	      IF	.LOOPCC = 0
     56  4879				  -	      SLEEP	5
     57  4879					      ENDIF
     58  4879				   .LOOPCC    SET	.LOOPCC + 1
     59  4879
     60  4879
     61  4879					      REPEND
     62  4879
     63  4879		       88		      dey		; 2
     64  487a		       10 ae		      bpl	blockLine	; 3/2
     65  487c
      0  487c					      CHECKPAGEX	blockLine, "blockLine crosses page"
      9  487c					      LIST	ON
     67  487c
     68  487c
     69  487c
     70  487c		       a9 00		      lda	#0
     71  487e		       85 4d		      sta	PF0
     72  4880		       85 4e		      sta	PF1
     73  4882		       85 4f		      sta	PF2
     74  4884
     75  4884		       85 42		      sta	WSYNC
     76  4886		       85 42		      sta	WSYNC
     77  4888		       85 42		      sta	WSYNC
     78  488a		       85 42		      sta	WSYNC
     79  488c		       85 42		      sta	WSYNC
     80  488e
     81  488e		       60		      rts
     82  488f
     83  488f
     84  488f
      0  488f					      DEFINE_SUBROUTINE	setCodeDigits
      1  488f		       00 09	   BANK_setCodeDigits =	_CURRENT_BANK
      2  488f					      SUBROUTINE
      3  488f				   setCodeDigits
     86  488f
     87  488f		       b9 db 00 	      lda	codeDigit,y
     88  4892		       4a		      lsr
     89  4893		       90 08		      bcc	correct0
     90  4895
     91  4895		       a5 f0		      lda	codeDelay
     92  4897		       4a		      lsr
     93  4898		       4a		      lsr
     94  4899		       4a		      lsr
     95  489a		       4c a0 f0 	      jmp	correct0a
     96  489d
     97  489d		       b9 db 00    correct0   lda	codeDigit,y
     98  48a0		       29 fe	   correct0a  and	#%11111110
     99  48a2		       aa		      tax
    100  48a3		       bd 7f f2 	      lda	CODE_DIGIT0,x
    101  48a6		       85 e7		      sta	bigdigit0
    102  48a8		       bd 80 f2 	      lda	CODE_DIGIT0+1,x
    103  48ab		       85 e8		      sta	bigdigit0+1
    104  48ad
    105  48ad		       b9 dc 00 	      lda	codeDigit+1,y
    106  48b0		       4a		      lsr
    107  48b1		       90 08		      bcc	correct1
    108  48b3
    109  48b3		       a5 f0		      lda	codeDelay
    110  48b5		       4a		      lsr
    111  48b6		       4a		      lsr
    112  48b7		       4a		      lsr
    113  48b8		       4c be f0 	      jmp	correct1a
    114  48bb
    115  48bb		       b9 dc 00    correct1   lda	codeDigit+1,y
    116  48be		       29 fe	   correct1a  and	#%11111110
    117  48c0		       aa		      tax
    118  48c1		       bd 93 f2 	      lda	CODE_DIGIT1,x
    119  48c4		       85 e9		      sta	bigdigit1
    120  48c6		       bd 94 f2 	      lda	CODE_DIGIT1+1,x
    121  48c9		       85 ea		      sta	bigdigit1+1
    122  48cb
    123  48cb		       b9 dd 00 	      lda	codeDigit+2,y
    124  48ce		       4a		      lsr
    125  48cf		       90 08		      bcc	correct2
    126  48d1
    127  48d1		       a5 f0		      lda	codeDelay
    128  48d3		       4a		      lsr
    129  48d4		       4a		      lsr
    130  48d5		       4a		      lsr
    131  48d6		       4c dc f0 	      jmp	correct2a
    132  48d9
    133  48d9		       b9 dd 00    correct2   lda	codeDigit+2,y
    134  48dc		       29 fe	   correct2a  and	#%11111110
    135  48de		       aa		      tax
    136  48df		       bd a7 f2 	      lda	CODE_DIGIT2,x
    137  48e2		       85 eb		      sta	bigdigit2
    138  48e4		       bd a8 f2 	      lda	CODE_DIGIT2+1,x
    139  48e7		       85 ec		      sta	bigdigit2+1
    140  48e9
    141  48e9		       b9 de 00 	      lda	codeDigit+3,y
    142  48ec		       4a		      lsr
    143  48ed		       90 08		      bcc	correct3
    144  48ef
    145  48ef		       a5 f0		      lda	codeDelay
    146  48f1		       4a		      lsr
    147  48f2		       4a		      lsr
    148  48f3		       4a		      lsr
    149  48f4		       4c fa f0 	      jmp	correct3a
    150  48f7
    151  48f7		       b9 de 00    correct3   lda	codeDigit+3,y
    152  48fa		       29 fe	   correct3a  and	#%11111110
    153  48fc		       aa		      tax
    154  48fd		       bd bb f2 	      lda	CODE_DIGIT3,x
    155  4900		       85 ed		      sta	bigdigit3
    156  4902		       bd bc f2 	      lda	CODE_DIGIT3+1,x
    157  4905		       85 ee		      sta	bigdigit3+1
    158  4907
    159  4907		       60		      rts
    160  4908
    161  4908
      0  4908					      DEFINE_SUBROUTINE	xSelectionScreenInit
      1  4908		       00 09	   BANK_xSelectionScreenInit =	_CURRENT_BANK
      2  4908					      SUBROUTINE
      3  4908				   xSelectionScreenInit
    163  4908
    164  4908		       a9 00		      lda	#%0
    165  490a							;		  sta NUSIZ1
    166  490a		       85 65		      sta	VDELP0
    167  490c		       85 66		      sta	VDELP1
    168  490e		       85 4b		      sta	REFP0
    169  4910		       85 4c		      sta	REFP1
    170  4912							;		  sta COLUBK
    171  4912		       85 59		      sta	AUDV0
    172  4914		       85 5a		      sta	AUDV1	; turn off music while levels init
    173  4916
    174  4916
    175  4916		       a9 f0		      lda	#%11110000
    176  4918		       85 60		      sta	HMP0
    177  491a
    178  491a		       a9 d0		      lda	#%11010000
    179  491c		       85 61		      sta	HMP1
    180  491e		       a9 07		      lda	#%111
    181  4920		       85 44		      sta	NUSIZ0
    182  4922		       85 45		      sta	NUSIZ1
    183  4924
    184  4924		       a9 00		      lda	#%0
    185  4926		       85 4a		      sta	CTRLPF
    186  4928		       85 f0		      sta	codeDelay
    187  492a		       a9 05		      lda	#5	;1
    188  492c		       85 f1		      sta	codeDelay+1
    189  492e
    190  492e		       a2 0b		      ldx	#11
    191  4930		       b5 db	   xferdigits lda	codeDigit,x	; == decimal,x
    192  4932		       0a		      asl
    193  4933		       09 01		      ora	#1	; NOT locked
    194  4935		       95 db		      sta	codeDigit,x
    195  4937		       ca		      dex
    196  4938		       10 f6		      bpl	xferdigits
    197  493a
    198  493a							;		  ldx #11
    199  493a							;randomdig	  jsr Random
    200  493a							;		  and #15
    201  493a							;		  cmp #10
    202  493a							;		  bcs randomdig
    203  493a							;		  asl
    204  493a							;		  ora #1		  ; NOT locked!
    205  493a							;		  sta codeDigit,x
    206  493a							;		  dex
    207  493a							;		  bpl randomdig
    208  493a
    209  493a		       60		      rts
    210  493b
    211  493b							;xPlatformxwallColour
    212  493b							;    .byte $F0, $F0, $22, $22
    213  493b							;xPlatformxadjustColour
    214  493b							;    .byte 0,0, $c0, $c0
    215  493b
    216  493b
    217  493b
    218  493b
      0  493b					      DEFINE_SUBROUTINE	xLevelScreen
      1  493b		       00 09	   BANK_xLevelScreen =	_CURRENT_BANK
      2  493b					      SUBROUTINE
      3  493b				   xLevelScreen
    220  493b
    221  493b		       20 08 f1 	      jsr	xSelectionScreenInit
    222  493e
    223  493e		       20 52 fd 	      jsr	Random
    224  4941		       29 f0		      and	#%11110000
    225  4943		       85 ef		      sta	codeTemp
    226  4945		       09 02		      ora	#2
    227  4947		       85 49		      sta	COLUBK
    228  4949		       85 46		      sta	COLUP0
    229  494b		       85 47		      sta	COLUP1
    230  494d
    231  494d		       20 52 fd    sameFix    jsr	Random
    232  4950		       29 f0		      and	#%11110000
    233  4952		       c5 ef		      cmp	codeTemp
    234  4954		       f0 f7		      beq	sameFix
    235  4956		       09 08		      ora	#8
    236  4958		       85 48		      sta	COLUPF
    237  495a
    238  495a
    239  495a
      0  495a					      RESYNC		; uses overlay
      1  495a
      2  495a		       a9 02		      lda	#%10
      3  495c		       85 41		      sta	VBLANK
      4  495e
      5  495e		       a2 08		      ldx	#8
      6  4960				   .loopResync
      0  4960					      VERTICAL_SYNC
      1  4960		       a9 0e		      lda	#%1110
      2  4962		       85 42	   .VSLP1     sta	WSYNC
      3  4964		       85 40		      sta	VSYNC
      4  4966		       4a		      lsr
      5  4967		       d0 f9		      bne	.VSLP1
      8  4969
      9  4969		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  496b		       a5 80		      lda	Platform
     11  496d		       49 02		      eor	#PAL_50
     12  496f		       d0 02		      bne	.ntsc
     13  4971		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  4973				   .ntsc
     15  4973				   .loopWait
     16  4973		       85 42		      sta	WSYNC
     17  4975		       85 42		      sta	WSYNC
     18  4977		       88		      dey
     19  4978		       d0 f9		      bne	.loopWait
     20  497a		       ca		      dex
     21  497b		       d0 e3		      bne	.loopResync
    241  497d
    242  497d				   xRestartFrameX
    243  497d
    244  497d		       a9 0e		      lda	#%1110	; VSYNC ON
    245  497f		       85 42	   .xloopVSync3 sta	WSYNC
    246  4981		       85 40		      sta	VSYNC
    247  4983		       4a		      lsr
    248  4984		       d0 f9		      bne	.xloopVSync3	; branch until VYSNC has been reset
    249  4986
    250  4986		       a6 80		      ldx	Platform
    251  4988		       bd 73 f2 	      lda	xVBlankTime2x,x
    252  498b		       8d 96 02 	      sta	TIM64T
    253  498e
    254  498e		       a9 02		      lda	#2
    255  4990		       85 41		      sta	VBLANK
    256  4992		       a2 25		      ldx	#37
    257  4994		       85 42	   xtoplines  sta	WSYNC
    258  4996		       ca		      dex
    259  4997		       d0 fb		      bne	xtoplines
    260  4999		       86 41		      stx	VBLANK
    261  499b
    262  499b		       a0 00		      ldy	#0
    263  499d		       20 8f f0 	      jsr	setCodeDigits
    264  49a0
    265  49a0							;------------------------------------------------------------------
    266  49a0
    267  49a0
    268  49a0				   VerticalBlankX		;
    269  49a0		       ad 84 02 	      lda	INTIM
    270  49a3		       d0 fb		      bne	VerticalBlankX
    271  49a5
    272  49a5
    273  49a5		       a9 00		      lda	#0
    274  49a7		       85 4d		      sta	PF0
    275  49a9		       85 4e		      sta	PF1
    276  49ab		       85 4f		      sta	PF2
    277  49ad
    278  49ad							; position the sprites for the box walls
    279  49ad
    280  49ad		       85 42		      sta	WSYNC
    281  49af
      0  49af					      SLEEP	10	;21
      1  49af				   .CYCLES    SET	10
      2  49af
      3  49af				  -	      IF	.CYCLES < 2
      4  49af				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  49af				  -	      ERR
      6  49af					      ENDIF
      7  49af
      8  49af				  -	      IF	.CYCLES & 1
      9  49af				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  49af				  -	      nop	0
     11  49af				  -	      ELSE
     12  49af				  -	      bit	VSYNC
     13  49af				  -	      ENDIF
     14  49af				  -.CYCLES    SET	.CYCLES - 3
     15  49af					      ENDIF
     16  49af
     17  49af					      REPEAT	.CYCLES / 2
     18  49af		       ea		      nop
     17  49af					      REPEND
     18  49b0		       ea		      nop
     17  49b0					      REPEND
     18  49b1		       ea		      nop
     17  49b1					      REPEND
     18  49b2		       ea		      nop
     17  49b2					      REPEND
     18  49b3		       ea		      nop
     19  49b4					      REPEND
    283  49b4		       85 50		      sta	RESP0
      0  49b6					      SLEEP	54
      1  49b6				   .CYCLES    SET	54
      2  49b6
      3  49b6				  -	      IF	.CYCLES < 2
      4  49b6				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  49b6				  -	      ERR
      6  49b6					      ENDIF
      7  49b6
      8  49b6				  -	      IF	.CYCLES & 1
      9  49b6				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  49b6				  -	      nop	0
     11  49b6				  -	      ELSE
     12  49b6				  -	      bit	VSYNC
     13  49b6				  -	      ENDIF
     14  49b6				  -.CYCLES    SET	.CYCLES - 3
     15  49b6					      ENDIF
     16  49b6
     17  49b6					      REPEAT	.CYCLES / 2
     18  49b6		       ea		      nop
     17  49b6					      REPEND
     18  49b7		       ea		      nop
     17  49b7					      REPEND
     18  49b8		       ea		      nop
     17  49b8					      REPEND
     18  49b9		       ea		      nop
     17  49b9					      REPEND
     18  49ba		       ea		      nop
     17  49ba					      REPEND
     18  49bb		       ea		      nop
     17  49bb					      REPEND
     18  49bc		       ea		      nop
     17  49bc					      REPEND
     18  49bd		       ea		      nop
     17  49bd					      REPEND
     18  49be		       ea		      nop
     17  49be					      REPEND
     18  49bf		       ea		      nop
     17  49bf					      REPEND
     18  49c0		       ea		      nop
     17  49c0					      REPEND
     18  49c1		       ea		      nop
     17  49c1					      REPEND
     18  49c2		       ea		      nop
     17  49c2					      REPEND
     18  49c3		       ea		      nop
     17  49c3					      REPEND
     18  49c4		       ea		      nop
     17  49c4					      REPEND
     18  49c5		       ea		      nop
     17  49c5					      REPEND
     18  49c6		       ea		      nop
     17  49c6					      REPEND
     18  49c7		       ea		      nop
     17  49c7					      REPEND
     18  49c8		       ea		      nop
     17  49c8					      REPEND
     18  49c9		       ea		      nop
     17  49c9					      REPEND
     18  49ca		       ea		      nop
     17  49ca					      REPEND
     18  49cb		       ea		      nop
     17  49cb					      REPEND
     18  49cc		       ea		      nop
     17  49cc					      REPEND
     18  49cd		       ea		      nop
     17  49cd					      REPEND
     18  49ce		       ea		      nop
     17  49ce					      REPEND
     18  49cf		       ea		      nop
     17  49cf					      REPEND
     18  49d0		       ea		      nop
     19  49d1					      REPEND
    285  49d1		       85 51		      sta	RESP1
    286  49d3
    287  49d3		       85 42		      sta	WSYNC
    288  49d5
      0  49d5					      SLEEP	66
      1  49d5				   .CYCLES    SET	66
      2  49d5
      3  49d5				  -	      IF	.CYCLES < 2
      4  49d5				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  49d5				  -	      ERR
      6  49d5					      ENDIF
      7  49d5
      8  49d5				  -	      IF	.CYCLES & 1
      9  49d5				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  49d5				  -	      nop	0
     11  49d5				  -	      ELSE
     12  49d5				  -	      bit	VSYNC
     13  49d5				  -	      ENDIF
     14  49d5				  -.CYCLES    SET	.CYCLES - 3
     15  49d5					      ENDIF
     16  49d5
     17  49d5					      REPEAT	.CYCLES / 2
     18  49d5		       ea		      nop
     17  49d5					      REPEND
     18  49d6		       ea		      nop
     17  49d6					      REPEND
     18  49d7		       ea		      nop
     17  49d7					      REPEND
     18  49d8		       ea		      nop
     17  49d8					      REPEND
     18  49d9		       ea		      nop
     17  49d9					      REPEND
     18  49da		       ea		      nop
     17  49da					      REPEND
     18  49db		       ea		      nop
     17  49db					      REPEND
     18  49dc		       ea		      nop
     17  49dc					      REPEND
     18  49dd		       ea		      nop
     17  49dd					      REPEND
     18  49de		       ea		      nop
     17  49de					      REPEND
     18  49df		       ea		      nop
     17  49df					      REPEND
     18  49e0		       ea		      nop
     17  49e0					      REPEND
     18  49e1		       ea		      nop
     17  49e1					      REPEND
     18  49e2		       ea		      nop
     17  49e2					      REPEND
     18  49e3		       ea		      nop
     17  49e3					      REPEND
     18  49e4		       ea		      nop
     17  49e4					      REPEND
     18  49e5		       ea		      nop
     17  49e5					      REPEND
     18  49e6		       ea		      nop
     17  49e6					      REPEND
     18  49e7		       ea		      nop
     17  49e7					      REPEND
     18  49e8		       ea		      nop
     17  49e8					      REPEND
     18  49e9		       ea		      nop
     17  49e9					      REPEND
     18  49ea		       ea		      nop
     17  49ea					      REPEND
     18  49eb		       ea		      nop
     17  49eb					      REPEND
     18  49ec		       ea		      nop
     17  49ec					      REPEND
     18  49ed		       ea		      nop
     17  49ed					      REPEND
     18  49ee		       ea		      nop
     17  49ee					      REPEND
     18  49ef		       ea		      nop
     17  49ef					      REPEND
     18  49f0		       ea		      nop
     17  49f0					      REPEND
     18  49f1		       ea		      nop
     17  49f1					      REPEND
     18  49f2		       ea		      nop
     17  49f2					      REPEND
     18  49f3		       ea		      nop
     17  49f3					      REPEND
     18  49f4		       ea		      nop
     17  49f4					      REPEND
     18  49f5		       ea		      nop
     19  49f6					      REPEND
    290  49f6		       85 6a		      sta	HMOVE
    291  49f8
    292  49f8		       a9 00		      lda	#0
    293  49fa		       85 4d		      sta	PF0
    294  49fc		       85 4e		      sta	PF1
    295  49fe		       85 4f		      sta	PF2
    296  4a00		       85 5c		      sta	GRP1
    297  4a02
    298  4a02		       a9 f0		      lda	#%11110000
    299  4a04		       85 5b		      sta	GRP0
    300  4a06
    301  4a06							;		  sta WSYNC
    302  4a06
    303  4a06							;------------------------------------------------------------------
    304  4a06
    305  4a06							; Do X scanlines of color-changing (our picture)
    306  4a06
    307  4a06		       a2 00		      ldx	#0	; used as a generic "0" during the kernel
    308  4a08		       85 42		      sta	WSYNC
    309  4a0a		       20 00 f0 	      jsr	xdigitBlock
    310  4a0d
    311  4a0d		       a0 04		      ldy	#4
    312  4a0f		       20 8f f0 	      jsr	setCodeDigits
    313  4a12		       20 00 f0 	      jsr	xdigitBlock
    314  4a15
    315  4a15		       a0 08		      ldy	#8
    316  4a17		       20 8f f0 	      jsr	setCodeDigits
    317  4a1a		       20 00 f0 	      jsr	xdigitBlock
    318  4a1d
    319  4a1d		       a4 80		      ldy	Platform
    320  4a1f		       b9 77 f2 	      lda	xOverscanTime2X,y
    321  4a22		       8d 96 02 	      sta	TIM64T
    322  4a25
    323  4a25		       85 42		      sta	WSYNC
    324  4a27
    325  4a27
    326  4a27
    327  4a27
    328  4a27		       a5 f0		      lda	codeDelay
    329  4a29		       18		      clc
    330  4a2a		       69 10		      adc	#16
    331  4a2c		       c9 a0		      cmp	#$A0
    332  4a2e		       90 08		      bcc	cDOK
    333  4a30
    334  4a30		       a5 f1		      lda	codeDelay+1
    335  4a32		       f0 04		      beq	cDOK
    336  4a34		       c6 f1		      dec	codeDelay+1
    337  4a36		       a9 00		      lda	#0
    338  4a38		       85 f0	   cDOK       sta	codeDelay
    339  4a3a
    340  4a3a		       4a		      lsr
    341  4a3b		       4a		      lsr
    342  4a3c		       4a		      lsr
    343  4a3d		       4a		      lsr
    344  4a3e		       85 ef		      sta	codeTemp	; digit currently shown
    345  4a40
    346  4a40		       a5 f1		      lda	codeDelay+1
    347  4a42		       d0 1a		      bne	onepass
    348  4a44
    349  4a44		       a2 00		      ldx	#0
    350  4a46		       b5 db	   lockDigits lda	codeDigit,x
    351  4a48		       4a		      lsr
    352  4a49		       90 0e		      bcc	nochange2
    353  4a4b
    354  4a4b		       c5 ef		      cmp	codeTemp
    355  4a4d		       d0 0f		      bne	onepass
    356  4a4f
    357  4a4f		       0a		      asl
    358  4a50		       95 db		      sta	codeDigit,x
    359  4a52
    360  4a52		       a9 03		      lda	#3
    361  4a54		       85 f1		      sta	codeDelay+1
    362  4a56		       4c 5e f2 	      jmp	onepass
    363  4a59
    364  4a59		       e8	   nochange2  inx
    365  4a5a		       e0 0c		      cpx	#12
    366  4a5c		       90 e8		      bcc	lockDigits
    367  4a5e
    368  4a5e							; none found so it's staic
    369  4a5e
    370  4a5e				   onepass
    371  4a5e
    372  4a5e
    373  4a5e							;--------------------------------------------------------------------------
    374  4a5e
    375  4a5e		       ad 84 02    xoscanX    lda	INTIM
    376  4a61		       d0 fb		      bne	xoscanX
    377  4a63
    378  4a63							;sta COLUBK
    379  4a63		       a9 42		      lda	#%01000010	; bit6 is not required
    380  4a65		       85 41		      sta	VBLANK	; end of screen - enter blanking
    381  4a67
    382  4a67		       a9 00		      lda	#0
    383  4a69		       85 40		      sta	VSYNC
    384  4a6b
    385  4a6b		       a5 4c	   xwaitbutton lda	INPT4
    386  4a6d		       10 03		      bpl	xretX
    387  4a6f
    388  4a6f		       4c 7d f1 	      jmp	xRestartFrameX
    389  4a72
    390  4a72		       60	   xretX      rts
    391  4a73
    392  4a73
    393  4a73				   xVBlankTime2x
    394  4a73		       38 38		      .byte.b	56,56
    395  4a75		       4e 4e		      .byte.b	78,78
    396  4a77				   xOverscanTime2X
    397  4a77		       2a 2a		      .byte.b	42, 42
    398  4a79		       40 40		      .byte.b	64, 64
    399  4a7b
    400  4a7b		       00 20	   xCOLOUR_LINES =	32
    401  4a7b				   xcolvecX
    402  4a7b		       00 00 20 20	      .byte.b	0, 0, xCOLOUR_LINES, xCOLOUR_LINES
    403  4a7f
    404  4a7f
    405  4a7f				   CODE_DIGIT0
    406  4a7f		       cf f2		      .word.w	CODE_DIGIT0_0
    407  4a81		       51 f3		      .word.w	CODE_DIGIT0_1
    408  4a83		       bd f3		      .word.w	CODE_DIGIT0_2
    409  4a85		       36 f4		      .word.w	CODE_DIGIT0_3
    410  4a87		       a2 f4		      .word.w	CODE_DIGIT0_4
    411  4a89		       1b f5		      .word.w	CODE_DIGIT0_5
    412  4a8b		       87 f5		      .word.w	CODE_DIGIT0_6
    413  4a8d		       00 f6		      .word.w	CODE_DIGIT0_7
    414  4a8f		       6c f6		      .word.w	CODE_DIGIT0_8
    415  4a91		       d8 f6		      .word.w	CODE_DIGIT0_9
    416  4a93
    417  4a93				   CODE_DIGIT1
    418  4a93		       00 f3		      .word.w	CODE_DIGIT1_0
    419  4a95		       6c f3		      .word.w	CODE_DIGIT1_1
    420  4a97		       d8 f3		      .word.w	CODE_DIGIT1_2
    421  4a99		       51 f4		      .word.w	CODE_DIGIT1_3
    422  4a9b		       bd f4		      .word.w	CODE_DIGIT1_4
    423  4a9d		       36 f5		      .word.w	CODE_DIGIT1_5
    424  4a9f		       a2 f5		      .word.w	CODE_DIGIT1_6
    425  4aa1		       1b f6		      .word.w	CODE_DIGIT1_7
    426  4aa3		       87 f6		      .word.w	CODE_DIGIT1_8
    427  4aa5		       00 f7		      .word.w	CODE_DIGIT1_9
    428  4aa7
    429  4aa7				   CODE_DIGIT2
    430  4aa7		       1b f3		      .word.w	CODE_DIGIT2_0
    431  4aa9		       87 f3		      .word.w	CODE_DIGIT2_1
    432  4aab		       00 f4		      .word.w	CODE_DIGIT2_2
    433  4aad		       6c f4		      .word.w	CODE_DIGIT2_3
    434  4aaf		       d8 f4		      .word.w	CODE_DIGIT2_4
    435  4ab1		       51 f5		      .word.w	CODE_DIGIT2_5
    436  4ab3		       bd f5		      .word.w	CODE_DIGIT2_6
    437  4ab5		       36 f6		      .word.w	CODE_DIGIT2_7
    438  4ab7		       a2 f6		      .word.w	CODE_DIGIT2_8
    439  4ab9		       1b f7		      .word.w	CODE_DIGIT2_9
    440  4abb
    441  4abb
    442  4abb				   CODE_DIGIT3
    443  4abb		       36 f3		      .word.w	CODE_DIGIT3_0
    444  4abd		       a2 f3		      .word.w	CODE_DIGIT3_1
    445  4abf		       1b f4		      .word.w	CODE_DIGIT3_2
    446  4ac1		       87 f4		      .word.w	CODE_DIGIT3_3
    447  4ac3		       00 f5		      .word.w	CODE_DIGIT3_4
    448  4ac5		       6c f5		      .word.w	CODE_DIGIT3_5
    449  4ac7		       d8 f5		      .word.w	CODE_DIGIT3_6
    450  4ac9		       51 f6		      .word.w	CODE_DIGIT3_7
    451  4acb		       bd f6		      .word.w	CODE_DIGIT3_8
    452  4acd		       36 f7		      .word.w	CODE_DIGIT3_9
    453  4acf
------- FILE bigDigits3.asm LEVEL 3 PASS 3
      0  4acf					      include	"bigDigits3.asm"
      0  4acf					      OPTIONAL_PAGEBREAK	"CODE_DIGIT0_0", 27
     10  4acf					      LIST	ON
      2  4acf				   CODE_DIGIT0_0
      3  4acf		       1c		      .byte.b	28
      4  4ad0		       3e		      .byte.b	62
      5  4ad1		       3e		      .byte.b	62
      6  4ad2		       3e		      .byte.b	62
      7  4ad3		       77		      .byte.b	119
      8  4ad4		       63		      .byte.b	99
      9  4ad5		       63		      .byte.b	99
     10  4ad6		       63		      .byte.b	99
     11  4ad7		       63		      .byte.b	99
     12  4ad8		       63		      .byte.b	99
     13  4ad9		       63		      .byte.b	99
     14  4ada		       63		      .byte.b	99
     15  4adb		       63		      .byte.b	99
     16  4adc		       63		      .byte.b	99
     17  4add		       63		      .byte.b	99
     18  4ade		       63		      .byte.b	99
     19  4adf		       63		      .byte.b	99
     20  4ae0		       63		      .byte.b	99
     21  4ae1		       63		      .byte.b	99
     22  4ae2		       63		      .byte.b	99
     23  4ae3		       63		      .byte.b	99
     24  4ae4		       63		      .byte.b	99
     25  4ae5		       77		      .byte.b	119
     26  4ae6		       3e		      .byte.b	62
     27  4ae7		       3e		      .byte.b	62
     28  4ae8		       3e		      .byte.b	62
     29  4ae9		       1c		      .byte.b	28
      0  4aea					      OPTIONAL_PAGEBREAK	"CODE_DIGIT1_0", 27
 PAGE BREAK INSERTED FOR  CODE_DIGIT1_0
 REQUESTED SIZE =  $1b
 WASTED SPACE =  $16
 PAGEBREAK LOCATION =  $f300
     10  4b00					      LIST	ON
     31  4b00				   CODE_DIGIT1_0
     32  4b00		       38		      .byte.b	56
     33  4b01		       7c		      .byte.b	124
     34  4b02		       7c		      .byte.b	124
     35  4b03		       7c		      .byte.b	124
     36  4b04		       ee		      .byte.b	238
     37  4b05		       c6		      .byte.b	198
     38  4b06		       c6		      .byte.b	198
     39  4b07		       c6		      .byte.b	198
     40  4b08		       c6		      .byte.b	198
     41  4b09		       c6		      .byte.b	198
     42  4b0a		       c6		      .byte.b	198
     43  4b0b		       c6		      .byte.b	198
     44  4b0c		       c6		      .byte.b	198
     45  4b0d		       c6		      .byte.b	198
     46  4b0e		       c6		      .byte.b	198
     47  4b0f		       c6		      .byte.b	198
     48  4b10		       c6		      .byte.b	198
     49  4b11		       c6		      .byte.b	198
     50  4b12		       c6		      .byte.b	198
     51  4b13		       c6		      .byte.b	198
     52  4b14		       c6		      .byte.b	198
     53  4b15		       c6		      .byte.b	198
     54  4b16		       ee		      .byte.b	238
     55  4b17		       7c		      .byte.b	124
     56  4b18		       7c		      .byte.b	124
     57  4b19		       7c		      .byte.b	124
     58  4b1a		       38		      .byte.b	56
      0  4b1b					      OPTIONAL_PAGEBREAK	"CODE_DIGIT2_0", 27
     10  4b1b					      LIST	ON
     60  4b1b				   CODE_DIGIT2_0
     61  4b1b		       8c		      .byte.b	140
     62  4b1c		       ce		      .byte.b	206
     63  4b1d		       ce		      .byte.b	206
     64  4b1e		       ce		      .byte.b	206
     65  4b1f		       e7		      .byte.b	231
     66  4b20		       63		      .byte.b	99
     67  4b21		       63		      .byte.b	99
     68  4b22		       63		      .byte.b	99
     69  4b23		       63		      .byte.b	99
     70  4b24		       63		      .byte.b	99
     71  4b25		       63		      .byte.b	99
     72  4b26		       63		      .byte.b	99
     73  4b27		       63		      .byte.b	99
     74  4b28		       63		      .byte.b	99
     75  4b29		       63		      .byte.b	99
     76  4b2a		       63		      .byte.b	99
     77  4b2b		       63		      .byte.b	99
     78  4b2c		       63		      .byte.b	99
     79  4b2d		       63		      .byte.b	99
     80  4b2e		       63		      .byte.b	99
     81  4b2f		       63		      .byte.b	99
     82  4b30		       63		      .byte.b	99
     83  4b31		       e7		      .byte.b	231
     84  4b32		       ce		      .byte.b	206
     85  4b33		       ce		      .byte.b	206
     86  4b34		       ce		      .byte.b	206
     87  4b35		       8c		      .byte.b	140
      0  4b36					      OPTIONAL_PAGEBREAK	"CODE_DIGIT3_0", 27
     10  4b36					      LIST	ON
     89  4b36				   CODE_DIGIT3_0
     90  4b36		       31		      .byte.b	49
     91  4b37		       73		      .byte.b	115
     92  4b38		       73		      .byte.b	115
     93  4b39		       73		      .byte.b	115
     94  4b3a		       e7		      .byte.b	231
     95  4b3b		       c6		      .byte.b	198
     96  4b3c		       c6		      .byte.b	198
     97  4b3d		       c6		      .byte.b	198
     98  4b3e		       c6		      .byte.b	198
     99  4b3f		       c6		      .byte.b	198
    100  4b40		       c6		      .byte.b	198
    101  4b41		       c6		      .byte.b	198
    102  4b42		       c6		      .byte.b	198
    103  4b43		       c6		      .byte.b	198
    104  4b44		       c6		      .byte.b	198
    105  4b45		       c6		      .byte.b	198
    106  4b46		       c6		      .byte.b	198
    107  4b47		       c6		      .byte.b	198
    108  4b48		       c6		      .byte.b	198
    109  4b49		       c6		      .byte.b	198
    110  4b4a		       c6		      .byte.b	198
    111  4b4b		       c6		      .byte.b	198
    112  4b4c		       e7		      .byte.b	231
    113  4b4d		       73		      .byte.b	115
    114  4b4e		       73		      .byte.b	115
    115  4b4f		       73		      .byte.b	115
    116  4b50		       31		      .byte.b	49
      0  4b51					      OPTIONAL_PAGEBREAK	"CODE_DIGIT0_1", 27
     10  4b51					      LIST	ON
    118  4b51				   CODE_DIGIT0_1
    119  4b51		       0c		      .byte.b	12
    120  4b52		       0c		      .byte.b	12
    121  4b53		       0c		      .byte.b	12
    122  4b54		       0c		      .byte.b	12
    123  4b55		       0c		      .byte.b	12
    124  4b56		       0c		      .byte.b	12
    125  4b57		       0c		      .byte.b	12
    126  4b58		       0c		      .byte.b	12
    127  4b59		       0c		      .byte.b	12
    128  4b5a		       0c		      .byte.b	12
    129  4b5b		       0c		      .byte.b	12
    130  4b5c		       0c		      .byte.b	12
    131  4b5d		       0c		      .byte.b	12
    132  4b5e		       0c		      .byte.b	12
    133  4b5f		       0c		      .byte.b	12
    134  4b60		       0c		      .byte.b	12
    135  4b61		       0c		      .byte.b	12
    136  4b62		       0c		      .byte.b	12
    137  4b63		       0c		      .byte.b	12
    138  4b64		       0c		      .byte.b	12
    139  4b65		       1c		      .byte.b	28
    140  4b66		       1c		      .byte.b	28
    141  4b67		       1c		      .byte.b	28
    142  4b68		       1c		      .byte.b	28
    143  4b69		       1c		      .byte.b	28
    144  4b6a		       0c		      .byte.b	12
    145  4b6b		       0c		      .byte.b	12
      0  4b6c					      OPTIONAL_PAGEBREAK	"CODE_DIGIT1_1", 27
     10  4b6c					      LIST	ON
    147  4b6c				   CODE_DIGIT1_1
    148  4b6c		       30		      .byte.b	48
    149  4b6d		       30		      .byte.b	48
    150  4b6e		       30		      .byte.b	48
    151  4b6f		       30		      .byte.b	48
    152  4b70		       30		      .byte.b	48
    153  4b71		       30		      .byte.b	48
    154  4b72		       30		      .byte.b	48
    155  4b73		       30		      .byte.b	48
    156  4b74		       30		      .byte.b	48
    157  4b75		       30		      .byte.b	48
    158  4b76		       30		      .byte.b	48
    159  4b77		       30		      .byte.b	48
    160  4b78		       30		      .byte.b	48
    161  4b79		       30		      .byte.b	48
    162  4b7a		       30		      .byte.b	48
    163  4b7b		       30		      .byte.b	48
    164  4b7c		       30		      .byte.b	48
    165  4b7d		       30		      .byte.b	48
    166  4b7e		       30		      .byte.b	48
    167  4b7f		       30		      .byte.b	48
    168  4b80		       38		      .byte.b	56
    169  4b81		       38		      .byte.b	56
    170  4b82		       38		      .byte.b	56
    171  4b83		       38		      .byte.b	56
    172  4b84		       38		      .byte.b	56
    173  4b85		       30		      .byte.b	48
    174  4b86		       30		      .byte.b	48
      0  4b87					      OPTIONAL_PAGEBREAK	"CODE_DIGIT2_1", 27
     10  4b87					      LIST	ON
    176  4b87				   CODE_DIGIT2_1
    177  4b87		       0c		      .byte.b	12
    178  4b88		       0c		      .byte.b	12
    179  4b89		       0c		      .byte.b	12
    180  4b8a		       0c		      .byte.b	12
    181  4b8b		       0c		      .byte.b	12
    182  4b8c		       0c		      .byte.b	12
    183  4b8d		       0c		      .byte.b	12
    184  4b8e		       0c		      .byte.b	12
    185  4b8f		       0c		      .byte.b	12
    186  4b90		       0c		      .byte.b	12
    187  4b91		       0c		      .byte.b	12
    188  4b92		       0c		      .byte.b	12
    189  4b93		       0c		      .byte.b	12
    190  4b94		       0c		      .byte.b	12
    191  4b95		       0c		      .byte.b	12
    192  4b96		       0c		      .byte.b	12
    193  4b97		       0c		      .byte.b	12
    194  4b98		       0c		      .byte.b	12
    195  4b99		       0c		      .byte.b	12
    196  4b9a		       0c		      .byte.b	12
    197  4b9b		       8c		      .byte.b	140
    198  4b9c		       8c		      .byte.b	140
    199  4b9d		       8c		      .byte.b	140
    200  4b9e		       8c		      .byte.b	140
    201  4b9f		       8c		      .byte.b	140
    202  4ba0		       0c		      .byte.b	12
    203  4ba1		       0c		      .byte.b	12
      0  4ba2					      OPTIONAL_PAGEBREAK	"CODE_DIGIT3_1", 27
     10  4ba2					      LIST	ON
    205  4ba2				   CODE_DIGIT3_1
    206  4ba2		       30		      .byte.b	48
    207  4ba3		       30		      .byte.b	48
    208  4ba4		       30		      .byte.b	48
    209  4ba5		       30		      .byte.b	48
    210  4ba6		       30		      .byte.b	48
    211  4ba7		       30		      .byte.b	48
    212  4ba8		       30		      .byte.b	48
    213  4ba9		       30		      .byte.b	48
    214  4baa		       30		      .byte.b	48
    215  4bab		       30		      .byte.b	48
    216  4bac		       30		      .byte.b	48
    217  4bad		       30		      .byte.b	48
    218  4bae		       30		      .byte.b	48
    219  4baf		       30		      .byte.b	48
    220  4bb0		       30		      .byte.b	48
    221  4bb1		       30		      .byte.b	48
    222  4bb2		       30		      .byte.b	48
    223  4bb3		       30		      .byte.b	48
    224  4bb4		       30		      .byte.b	48
    225  4bb5		       30		      .byte.b	48
    226  4bb6		       31		      .byte.b	49
    227  4bb7		       31		      .byte.b	49
    228  4bb8		       31		      .byte.b	49
    229  4bb9		       31		      .byte.b	49
    230  4bba		       31		      .byte.b	49
    231  4bbb		       30		      .byte.b	48
    232  4bbc		       30		      .byte.b	48
      0  4bbd					      OPTIONAL_PAGEBREAK	"CODE_DIGIT0_2", 27
     10  4bbd					      LIST	ON
    234  4bbd				   CODE_DIGIT0_2
    235  4bbd		       7f		      .byte.b	127
    236  4bbe		       7f		      .byte.b	127
    237  4bbf		       7f		      .byte.b	127
    238  4bc0		       7f		      .byte.b	127
    239  4bc1		       63		      .byte.b	99
    240  4bc2		       60		      .byte.b	96
    241  4bc3		       60		      .byte.b	96
    242  4bc4		       60		      .byte.b	96
    243  4bc5		       70		      .byte.b	112
    244  4bc6		       70		      .byte.b	112
    245  4bc7		       38		      .byte.b	56
    246  4bc8		       3c		      .byte.b	60
    247  4bc9		       1e		      .byte.b	30
    248  4bca		       0e		      .byte.b	14
    249  4bcb		       07		      .byte.b	7
    250  4bcc		       07		      .byte.b	7
    251  4bcd		       03		      .byte.b	3
    252  4bce		       03		      .byte.b	3
    253  4bcf		       03		      .byte.b	3
    254  4bd0		       63		      .byte.b	99
    255  4bd1		       63		      .byte.b	99
    256  4bd2		       63		      .byte.b	99
    257  4bd3		       77		      .byte.b	119
    258  4bd4		       7f		      .byte.b	127
    259  4bd5		       3e		      .byte.b	62
    260  4bd6		       3e		      .byte.b	62
    261  4bd7		       1c		      .byte.b	28
      0  4bd8					      OPTIONAL_PAGEBREAK	"CODE_DIGIT1_2", 27
     10  4bd8					      LIST	ON
    263  4bd8				   CODE_DIGIT1_2
    264  4bd8		       fe		      .byte.b	254
    265  4bd9		       fe		      .byte.b	254
    266  4bda		       fe		      .byte.b	254
    267  4bdb		       fe		      .byte.b	254
    268  4bdc		       c6		      .byte.b	198
    269  4bdd		       06		      .byte.b	6
    270  4bde		       06		      .byte.b	6
    271  4bdf		       06		      .byte.b	6
    272  4be0		       0e		      .byte.b	14
    273  4be1		       0e		      .byte.b	14
    274  4be2		       1c		      .byte.b	28
    275  4be3		       3c		      .byte.b	60
    276  4be4		       78		      .byte.b	120
    277  4be5		       70		      .byte.b	112
    278  4be6		       e0		      .byte.b	224
    279  4be7		       e0		      .byte.b	224
    280  4be8		       c0		      .byte.b	192
    281  4be9		       c0		      .byte.b	192
    282  4bea		       c0		      .byte.b	192
    283  4beb		       c6		      .byte.b	198
    284  4bec		       c6		      .byte.b	198
    285  4bed		       c6		      .byte.b	198
    286  4bee		       ee		      .byte.b	238
    287  4bef		       fe		      .byte.b	254
    288  4bf0		       7c		      .byte.b	124
    289  4bf1		       7c		      .byte.b	124
    290  4bf2		       38		      .byte.b	56
      0  4bf3					      OPTIONAL_PAGEBREAK	"CODE_DIGIT2_2", 27
 PAGE BREAK INSERTED FOR  CODE_DIGIT2_2
 REQUESTED SIZE =  $1b
 WASTED SPACE =  $d
 PAGEBREAK LOCATION =  $f400
     10  4c00					      LIST	ON
    292  4c00				   CODE_DIGIT2_2
    293  4c00		       ef		      .byte.b	239
    294  4c01		       ef		      .byte.b	239
    295  4c02		       ef		      .byte.b	239
    296  4c03		       ef		      .byte.b	239
    297  4c04		       63		      .byte.b	99
    298  4c05		       60		      .byte.b	96
    299  4c06		       60		      .byte.b	96
    300  4c07		       60		      .byte.b	96
    301  4c08		       e0		      .byte.b	224
    302  4c09		       e0		      .byte.b	224
    303  4c0a		       c8		      .byte.b	200
    304  4c0b		       cc		      .byte.b	204
    305  4c0c		       8e		      .byte.b	142
    306  4c0d		       0e		      .byte.b	14
    307  4c0e		       07		      .byte.b	7
    308  4c0f		       07		      .byte.b	7
    309  4c10		       03		      .byte.b	3
    310  4c11		       03		      .byte.b	3
    311  4c12		       03		      .byte.b	3
    312  4c13		       63		      .byte.b	99
    313  4c14		       63		      .byte.b	99
    314  4c15		       63		      .byte.b	99
    315  4c16		       e7		      .byte.b	231
    316  4c17		       ef		      .byte.b	239
    317  4c18		       ce		      .byte.b	206
    318  4c19		       ce		      .byte.b	206
    319  4c1a		       8c		      .byte.b	140
      0  4c1b					      OPTIONAL_PAGEBREAK	"CODE_DIGIT3_2", 27
     10  4c1b					      LIST	ON
    321  4c1b				   CODE_DIGIT3_2
    322  4c1b		       f7		      .byte.b	247
    323  4c1c		       f7		      .byte.b	247
    324  4c1d		       f7		      .byte.b	247
    325  4c1e		       f7		      .byte.b	247
    326  4c1f		       c6		      .byte.b	198
    327  4c20		       06		      .byte.b	6
    328  4c21		       06		      .byte.b	6
    329  4c22		       06		      .byte.b	6
    330  4c23		       07		      .byte.b	7
    331  4c24		       07		      .byte.b	7
    332  4c25		       13		      .byte.b	19
    333  4c26		       33		      .byte.b	51
    334  4c27		       71		      .byte.b	113
    335  4c28		       70		      .byte.b	112
    336  4c29		       e0		      .byte.b	224
    337  4c2a		       e0		      .byte.b	224
    338  4c2b		       c0		      .byte.b	192
    339  4c2c		       c0		      .byte.b	192
    340  4c2d		       c0		      .byte.b	192
    341  4c2e		       c6		      .byte.b	198
    342  4c2f		       c6		      .byte.b	198
    343  4c30		       c6		      .byte.b	198
    344  4c31		       e7		      .byte.b	231
    345  4c32		       f7		      .byte.b	247
    346  4c33		       73		      .byte.b	115
    347  4c34		       73		      .byte.b	115
    348  4c35		       31		      .byte.b	49
      0  4c36					      OPTIONAL_PAGEBREAK	"CODE_DIGIT0_3", 27
     10  4c36					      LIST	ON
    350  4c36				   CODE_DIGIT0_3
    351  4c36		       1c		      .byte.b	28
    352  4c37		       3e		      .byte.b	62
    353  4c38		       3e		      .byte.b	62
    354  4c39		       7f		      .byte.b	127
    355  4c3a		       77		      .byte.b	119
    356  4c3b		       63		      .byte.b	99
    357  4c3c		       63		      .byte.b	99
    358  4c3d		       63		      .byte.b	99
    359  4c3e		       03		      .byte.b	3
    360  4c3f		       03		      .byte.b	3
    361  4c40		       03		      .byte.b	3
    362  4c41		       07		      .byte.b	7
    363  4c42		       1f		      .byte.b	31
    364  4c43		       1e		      .byte.b	30
    365  4c44		       1e		      .byte.b	30
    366  4c45		       1f		      .byte.b	31
    367  4c46		       07		      .byte.b	7
    368  4c47		       03		      .byte.b	3
    369  4c48		       03		      .byte.b	3
    370  4c49		       63		      .byte.b	99
    371  4c4a		       63		      .byte.b	99
    372  4c4b		       63		      .byte.b	99
    373  4c4c		       77		      .byte.b	119
    374  4c4d		       7f		      .byte.b	127
    375  4c4e		       3e		      .byte.b	62
    376  4c4f		       3e		      .byte.b	62
    377  4c50		       1c		      .byte.b	28
      0  4c51					      OPTIONAL_PAGEBREAK	"CODE_DIGIT1_3", 27
     10  4c51					      LIST	ON
    379  4c51				   CODE_DIGIT1_3
    380  4c51		       38		      .byte.b	56
    381  4c52		       7c		      .byte.b	124
    382  4c53		       7c		      .byte.b	124
    383  4c54		       fe		      .byte.b	254
    384  4c55		       ee		      .byte.b	238
    385  4c56		       c6		      .byte.b	198
    386  4c57		       c6		      .byte.b	198
    387  4c58		       c6		      .byte.b	198
    388  4c59		       c0		      .byte.b	192
    389  4c5a		       c0		      .byte.b	192
    390  4c5b		       c0		      .byte.b	192
    391  4c5c		       e0		      .byte.b	224
    392  4c5d		       f8		      .byte.b	248
    393  4c5e		       78		      .byte.b	120
    394  4c5f		       78		      .byte.b	120
    395  4c60		       f8		      .byte.b	248
    396  4c61		       e0		      .byte.b	224
    397  4c62		       c0		      .byte.b	192
    398  4c63		       c0		      .byte.b	192
    399  4c64		       c6		      .byte.b	198
    400  4c65		       c6		      .byte.b	198
    401  4c66		       c6		      .byte.b	198
    402  4c67		       ee		      .byte.b	238
    403  4c68		       fe		      .byte.b	254
    404  4c69		       7c		      .byte.b	124
    405  4c6a		       7c		      .byte.b	124
    406  4c6b		       38		      .byte.b	56
      0  4c6c					      OPTIONAL_PAGEBREAK	"CODE_DIGIT2_3", 27
     10  4c6c					      LIST	ON
    408  4c6c				   CODE_DIGIT2_3
    409  4c6c		       8c		      .byte.b	140
    410  4c6d		       ce		      .byte.b	206
    411  4c6e		       ce		      .byte.b	206
    412  4c6f		       ef		      .byte.b	239
    413  4c70		       e7		      .byte.b	231
    414  4c71		       63		      .byte.b	99
    415  4c72		       63		      .byte.b	99
    416  4c73		       63		      .byte.b	99
    417  4c74		       03		      .byte.b	3
    418  4c75		       03		      .byte.b	3
    419  4c76		       03		      .byte.b	3
    420  4c77		       07		      .byte.b	7
    421  4c78		       8f		      .byte.b	143
    422  4c79		       8e		      .byte.b	142
    423  4c7a		       8e		      .byte.b	142
    424  4c7b		       8f		      .byte.b	143
    425  4c7c		       07		      .byte.b	7
    426  4c7d		       03		      .byte.b	3
    427  4c7e		       03		      .byte.b	3
    428  4c7f		       63		      .byte.b	99
    429  4c80		       63		      .byte.b	99
    430  4c81		       63		      .byte.b	99
    431  4c82		       e7		      .byte.b	231
    432  4c83		       ef		      .byte.b	239
    433  4c84		       ce		      .byte.b	206
    434  4c85		       ce		      .byte.b	206
    435  4c86		       8c		      .byte.b	140
      0  4c87					      OPTIONAL_PAGEBREAK	"CODE_DIGIT3_3", 27
     10  4c87					      LIST	ON
    437  4c87				   CODE_DIGIT3_3
    438  4c87		       31		      .byte.b	49
    439  4c88		       73		      .byte.b	115
    440  4c89		       73		      .byte.b	115
    441  4c8a		       f7		      .byte.b	247
    442  4c8b		       e7		      .byte.b	231
    443  4c8c		       c6		      .byte.b	198
    444  4c8d		       c6		      .byte.b	198
    445  4c8e		       c6		      .byte.b	198
    446  4c8f		       c0		      .byte.b	192
    447  4c90		       c0		      .byte.b	192
    448  4c91		       c0		      .byte.b	192
    449  4c92		       e0		      .byte.b	224
    450  4c93		       f1		      .byte.b	241
    451  4c94		       71		      .byte.b	113
    452  4c95		       71		      .byte.b	113
    453  4c96		       f1		      .byte.b	241
    454  4c97		       e0		      .byte.b	224
    455  4c98		       c0		      .byte.b	192
    456  4c99		       c0		      .byte.b	192
    457  4c9a		       c6		      .byte.b	198
    458  4c9b		       c6		      .byte.b	198
    459  4c9c		       c6		      .byte.b	198
    460  4c9d		       e7		      .byte.b	231
    461  4c9e		       f7		      .byte.b	247
    462  4c9f		       73		      .byte.b	115
    463  4ca0		       73		      .byte.b	115
    464  4ca1		       31		      .byte.b	49
      0  4ca2					      OPTIONAL_PAGEBREAK	"CODE_DIGIT0_4", 27
     10  4ca2					      LIST	ON
    466  4ca2				   CODE_DIGIT0_4
    467  4ca2		       06		      .byte.b	6
    468  4ca3		       06		      .byte.b	6
    469  4ca4		       06		      .byte.b	6
    470  4ca5		       06		      .byte.b	6
    471  4ca6		       06		      .byte.b	6
    472  4ca7		       7f		      .byte.b	127
    473  4ca8		       7f		      .byte.b	127
    474  4ca9		       7f		      .byte.b	127
    475  4caa		       7f		      .byte.b	127
    476  4cab		       66		      .byte.b	102
    477  4cac		       66		      .byte.b	102
    478  4cad		       66		      .byte.b	102
    479  4cae		       66		      .byte.b	102
    480  4caf		       36		      .byte.b	54
    481  4cb0		       36		      .byte.b	54
    482  4cb1		       36		      .byte.b	54
    483  4cb2		       36		      .byte.b	54
    484  4cb3		       1e		      .byte.b	30
    485  4cb4		       1e		      .byte.b	30
    486  4cb5		       1e		      .byte.b	30
    487  4cb6		       1e		      .byte.b	30
    488  4cb7		       0e		      .byte.b	14
    489  4cb8		       0e		      .byte.b	14
    490  4cb9		       0e		      .byte.b	14
    491  4cba		       0e		      .byte.b	14
    492  4cbb		       06		      .byte.b	6
    493  4cbc		       06		      .byte.b	6
      0  4cbd					      OPTIONAL_PAGEBREAK	"CODE_DIGIT1_4", 27
     10  4cbd					      LIST	ON
    495  4cbd				   CODE_DIGIT1_4
    496  4cbd		       60		      .byte.b	96
    497  4cbe		       60		      .byte.b	96
    498  4cbf		       60		      .byte.b	96
    499  4cc0		       60		      .byte.b	96
    500  4cc1		       60		      .byte.b	96
    501  4cc2		       fe		      .byte.b	254
    502  4cc3		       fe		      .byte.b	254
    503  4cc4		       fe		      .byte.b	254
    504  4cc5		       fe		      .byte.b	254
    505  4cc6		       66		      .byte.b	102
    506  4cc7		       66		      .byte.b	102
    507  4cc8		       66		      .byte.b	102
    508  4cc9		       66		      .byte.b	102
    509  4cca		       6c		      .byte.b	108
    510  4ccb		       6c		      .byte.b	108
    511  4ccc		       6c		      .byte.b	108
    512  4ccd		       6c		      .byte.b	108
    513  4cce		       78		      .byte.b	120
    514  4ccf		       78		      .byte.b	120
    515  4cd0		       78		      .byte.b	120
    516  4cd1		       78		      .byte.b	120
    517  4cd2		       70		      .byte.b	112
    518  4cd3		       70		      .byte.b	112
    519  4cd4		       70		      .byte.b	112
    520  4cd5		       70		      .byte.b	112
    521  4cd6		       60		      .byte.b	96
    522  4cd7		       60		      .byte.b	96
      0  4cd8					      OPTIONAL_PAGEBREAK	"CODE_DIGIT2_4", 27
     10  4cd8					      LIST	ON
    524  4cd8				   CODE_DIGIT2_4
    525  4cd8		       06		      .byte.b	6
    526  4cd9		       06		      .byte.b	6
    527  4cda		       06		      .byte.b	6
    528  4cdb		       06		      .byte.b	6
    529  4cdc		       06		      .byte.b	6
    530  4cdd		       ef		      .byte.b	239
    531  4cde		       ef		      .byte.b	239
    532  4cdf		       ef		      .byte.b	239
    533  4ce0		       ef		      .byte.b	239
    534  4ce1		       66		      .byte.b	102
    535  4ce2		       66		      .byte.b	102
    536  4ce3		       66		      .byte.b	102
    537  4ce4		       66		      .byte.b	102
    538  4ce5		       c6		      .byte.b	198
    539  4ce6		       c6		      .byte.b	198
    540  4ce7		       c6		      .byte.b	198
    541  4ce8		       c6		      .byte.b	198
    542  4ce9		       8e		      .byte.b	142
    543  4cea		       8e		      .byte.b	142
    544  4ceb		       8e		      .byte.b	142
    545  4cec		       8e		      .byte.b	142
    546  4ced		       0e		      .byte.b	14
    547  4cee		       0e		      .byte.b	14
    548  4cef		       0e		      .byte.b	14
    549  4cf0		       0e		      .byte.b	14
    550  4cf1		       06		      .byte.b	6
    551  4cf2		       06		      .byte.b	6
      0  4cf3					      OPTIONAL_PAGEBREAK	"CODE_DIGIT3_4", 27
 PAGE BREAK INSERTED FOR  CODE_DIGIT3_4
 REQUESTED SIZE =  $1b
 WASTED SPACE =  $d
 PAGEBREAK LOCATION =  $f500
     10  4d00					      LIST	ON
    553  4d00				   CODE_DIGIT3_4
    554  4d00		       60		      .byte.b	96
    555  4d01		       60		      .byte.b	96
    556  4d02		       60		      .byte.b	96
    557  4d03		       60		      .byte.b	96
    558  4d04		       60		      .byte.b	96
    559  4d05		       f7		      .byte.b	247
    560  4d06		       f7		      .byte.b	247
    561  4d07		       f7		      .byte.b	247
    562  4d08		       f7		      .byte.b	247
    563  4d09		       66		      .byte.b	102
    564  4d0a		       66		      .byte.b	102
    565  4d0b		       66		      .byte.b	102
    566  4d0c		       66		      .byte.b	102
    567  4d0d		       63		      .byte.b	99
    568  4d0e		       63		      .byte.b	99
    569  4d0f		       63		      .byte.b	99
    570  4d10		       63		      .byte.b	99
    571  4d11		       71		      .byte.b	113
    572  4d12		       71		      .byte.b	113
    573  4d13		       71		      .byte.b	113
    574  4d14		       71		      .byte.b	113
    575  4d15		       70		      .byte.b	112
    576  4d16		       70		      .byte.b	112
    577  4d17		       70		      .byte.b	112
    578  4d18		       70		      .byte.b	112
    579  4d19		       60		      .byte.b	96
    580  4d1a		       60		      .byte.b	96
      0  4d1b					      OPTIONAL_PAGEBREAK	"CODE_DIGIT0_5", 27
     10  4d1b					      LIST	ON
    582  4d1b				   CODE_DIGIT0_5
    583  4d1b		       1c		      .byte.b	28
    584  4d1c		       3e		      .byte.b	62
    585  4d1d		       3e		      .byte.b	62
    586  4d1e		       7f		      .byte.b	127
    587  4d1f		       77		      .byte.b	119
    588  4d20		       63		      .byte.b	99
    589  4d21		       63		      .byte.b	99
    590  4d22		       63		      .byte.b	99
    591  4d23		       03		      .byte.b	3
    592  4d24		       03		      .byte.b	3
    593  4d25		       03		      .byte.b	3
    594  4d26		       03		      .byte.b	3
    595  4d27		       03		      .byte.b	3
    596  4d28		       03		      .byte.b	3
    597  4d29		       67		      .byte.b	103
    598  4d2a		       7f		      .byte.b	127
    599  4d2b		       7e		      .byte.b	126
    600  4d2c		       7e		      .byte.b	126
    601  4d2d		       6c		      .byte.b	108
    602  4d2e		       60		      .byte.b	96
    603  4d2f		       60		      .byte.b	96
    604  4d30		       60		      .byte.b	96
    605  4d31		       63		      .byte.b	99
    606  4d32		       7f		      .byte.b	127
    607  4d33		       7f		      .byte.b	127
    608  4d34		       7f		      .byte.b	127
    609  4d35		       7f		      .byte.b	127
      0  4d36					      OPTIONAL_PAGEBREAK	"CODE_DIGIT1_5", 27
     10  4d36					      LIST	ON
    611  4d36				   CODE_DIGIT1_5
    612  4d36		       38		      .byte.b	56
    613  4d37		       7c		      .byte.b	124
    614  4d38		       7c		      .byte.b	124
    615  4d39		       fe		      .byte.b	254
    616  4d3a		       ee		      .byte.b	238
    617  4d3b		       c6		      .byte.b	198
    618  4d3c		       c6		      .byte.b	198
    619  4d3d		       c6		      .byte.b	198
    620  4d3e		       c0		      .byte.b	192
    621  4d3f		       c0		      .byte.b	192
    622  4d40		       c0		      .byte.b	192
    623  4d41		       c0		      .byte.b	192
    624  4d42		       c0		      .byte.b	192
    625  4d43		       c0		      .byte.b	192
    626  4d44		       e6		      .byte.b	230
    627  4d45		       fe		      .byte.b	254
    628  4d46		       7e		      .byte.b	126
    629  4d47		       7e		      .byte.b	126
    630  4d48		       36		      .byte.b	54
    631  4d49		       06		      .byte.b	6
    632  4d4a		       06		      .byte.b	6
    633  4d4b		       06		      .byte.b	6
    634  4d4c		       c6		      .byte.b	198
    635  4d4d		       fe		      .byte.b	254
    636  4d4e		       fe		      .byte.b	254
    637  4d4f		       fe		      .byte.b	254
    638  4d50		       fe		      .byte.b	254
      0  4d51					      OPTIONAL_PAGEBREAK	"CODE_DIGIT2_5", 27
     10  4d51					      LIST	ON
    640  4d51				   CODE_DIGIT2_5
    641  4d51		       8c		      .byte.b	140
    642  4d52		       ce		      .byte.b	206
    643  4d53		       ce		      .byte.b	206
    644  4d54		       ef		      .byte.b	239
    645  4d55		       e7		      .byte.b	231
    646  4d56		       63		      .byte.b	99
    647  4d57		       63		      .byte.b	99
    648  4d58		       63		      .byte.b	99
    649  4d59		       03		      .byte.b	3
    650  4d5a		       03		      .byte.b	3
    651  4d5b		       03		      .byte.b	3
    652  4d5c		       03		      .byte.b	3
    653  4d5d		       03		      .byte.b	3
    654  4d5e		       03		      .byte.b	3
    655  4d5f		       67		      .byte.b	103
    656  4d60		       ef		      .byte.b	239
    657  4d61		       ee		      .byte.b	238
    658  4d62		       ee		      .byte.b	238
    659  4d63		       6c		      .byte.b	108
    660  4d64		       60		      .byte.b	96
    661  4d65		       60		      .byte.b	96
    662  4d66		       60		      .byte.b	96
    663  4d67		       63		      .byte.b	99
    664  4d68		       ef		      .byte.b	239
    665  4d69		       ef		      .byte.b	239
    666  4d6a		       ef		      .byte.b	239
    667  4d6b		       ef		      .byte.b	239
      0  4d6c					      OPTIONAL_PAGEBREAK	"CODE_DIGIT3_5", 27
     10  4d6c					      LIST	ON
    669  4d6c				   CODE_DIGIT3_5
    670  4d6c		       31		      .byte.b	49
    671  4d6d		       73		      .byte.b	115
    672  4d6e		       73		      .byte.b	115
    673  4d6f		       f7		      .byte.b	247
    674  4d70		       e7		      .byte.b	231
    675  4d71		       c6		      .byte.b	198
    676  4d72		       c6		      .byte.b	198
    677  4d73		       c6		      .byte.b	198
    678  4d74		       c0		      .byte.b	192
    679  4d75		       c0		      .byte.b	192
    680  4d76		       c0		      .byte.b	192
    681  4d77		       c0		      .byte.b	192
    682  4d78		       c0		      .byte.b	192
    683  4d79		       c0		      .byte.b	192
    684  4d7a		       e6		      .byte.b	230
    685  4d7b		       f7		      .byte.b	247
    686  4d7c		       77		      .byte.b	119
    687  4d7d		       77		      .byte.b	119
    688  4d7e		       36		      .byte.b	54
    689  4d7f		       06		      .byte.b	6
    690  4d80		       06		      .byte.b	6
    691  4d81		       06		      .byte.b	6
    692  4d82		       c6		      .byte.b	198
    693  4d83		       f7		      .byte.b	247
    694  4d84		       f7		      .byte.b	247
    695  4d85		       f7		      .byte.b	247
    696  4d86		       f7		      .byte.b	247
      0  4d87					      OPTIONAL_PAGEBREAK	"CODE_DIGIT0_6", 27
     10  4d87					      LIST	ON
    698  4d87				   CODE_DIGIT0_6
    699  4d87		       1c		      .byte.b	28
    700  4d88		       3e		      .byte.b	62
    701  4d89		       3e		      .byte.b	62
    702  4d8a		       7f		      .byte.b	127
    703  4d8b		       77		      .byte.b	119
    704  4d8c		       63		      .byte.b	99
    705  4d8d		       63		      .byte.b	99
    706  4d8e		       63		      .byte.b	99
    707  4d8f		       63		      .byte.b	99
    708  4d90		       63		      .byte.b	99
    709  4d91		       63		      .byte.b	99
    710  4d92		       77		      .byte.b	119
    711  4d93		       7f		      .byte.b	127
    712  4d94		       7e		      .byte.b	126
    713  4d95		       7e		      .byte.b	126
    714  4d96		       6c		      .byte.b	108
    715  4d97		       60		      .byte.b	96
    716  4d98		       60		      .byte.b	96
    717  4d99		       70		      .byte.b	112
    718  4d9a		       30		      .byte.b	48
    719  4d9b		       30		      .byte.b	48
    720  4d9c		       38		      .byte.b	56
    721  4d9d		       38		      .byte.b	56
    722  4d9e		       1e		      .byte.b	30
    723  4d9f		       1e		      .byte.b	30
    724  4da0		       0e		      .byte.b	14
    725  4da1		       06		      .byte.b	6
      0  4da2					      OPTIONAL_PAGEBREAK	"CODE_DIGIT1_6", 27
     10  4da2					      LIST	ON
    727  4da2				   CODE_DIGIT1_6
    728  4da2		       38		      .byte.b	56
    729  4da3		       7c		      .byte.b	124
    730  4da4		       7c		      .byte.b	124
    731  4da5		       fe		      .byte.b	254
    732  4da6		       ee		      .byte.b	238
    733  4da7		       c6		      .byte.b	198
    734  4da8		       c6		      .byte.b	198
    735  4da9		       c6		      .byte.b	198
    736  4daa		       c6		      .byte.b	198
    737  4dab		       c6		      .byte.b	198
    738  4dac		       c6		      .byte.b	198
    739  4dad		       ee		      .byte.b	238
    740  4dae		       fe		      .byte.b	254
    741  4daf		       7e		      .byte.b	126
    742  4db0		       7e		      .byte.b	126
    743  4db1		       36		      .byte.b	54
    744  4db2		       06		      .byte.b	6
    745  4db3		       06		      .byte.b	6
    746  4db4		       0e		      .byte.b	14
    747  4db5		       0c		      .byte.b	12
    748  4db6		       0c		      .byte.b	12
    749  4db7		       1c		      .byte.b	28
    750  4db8		       1c		      .byte.b	28
    751  4db9		       78		      .byte.b	120
    752  4dba		       78		      .byte.b	120
    753  4dbb		       70		      .byte.b	112
    754  4dbc		       60		      .byte.b	96
      0  4dbd					      OPTIONAL_PAGEBREAK	"CODE_DIGIT2_6", 27
     10  4dbd					      LIST	ON
    756  4dbd				   CODE_DIGIT2_6
    757  4dbd		       8c		      .byte.b	140
    758  4dbe		       ce		      .byte.b	206
    759  4dbf		       ce		      .byte.b	206
    760  4dc0		       ef		      .byte.b	239
    761  4dc1		       e7		      .byte.b	231
    762  4dc2		       63		      .byte.b	99
    763  4dc3		       63		      .byte.b	99
    764  4dc4		       63		      .byte.b	99
    765  4dc5		       63		      .byte.b	99
    766  4dc6		       63		      .byte.b	99
    767  4dc7		       63		      .byte.b	99
    768  4dc8		       e7		      .byte.b	231
    769  4dc9		       ef		      .byte.b	239
    770  4dca		       ee		      .byte.b	238
    771  4dcb		       ee		      .byte.b	238
    772  4dcc		       6c		      .byte.b	108
    773  4dcd		       60		      .byte.b	96
    774  4dce		       60		      .byte.b	96
    775  4dcf		       e0		      .byte.b	224
    776  4dd0		       c0		      .byte.b	192
    777  4dd1		       c0		      .byte.b	192
    778  4dd2		       c8		      .byte.b	200
    779  4dd3		       c8		      .byte.b	200
    780  4dd4		       8e		      .byte.b	142
    781  4dd5		       8e		      .byte.b	142
    782  4dd6		       0e		      .byte.b	14
    783  4dd7		       06		      .byte.b	6
      0  4dd8					      OPTIONAL_PAGEBREAK	"CODE_DIGIT3_6", 27
     10  4dd8					      LIST	ON
    785  4dd8				   CODE_DIGIT3_6
    786  4dd8		       31		      .byte.b	49
    787  4dd9		       73		      .byte.b	115
    788  4dda		       73		      .byte.b	115
    789  4ddb		       f7		      .byte.b	247
    790  4ddc		       e7		      .byte.b	231
    791  4ddd		       c6		      .byte.b	198
    792  4dde		       c6		      .byte.b	198
    793  4ddf		       c6		      .byte.b	198
    794  4de0		       c6		      .byte.b	198
    795  4de1		       c6		      .byte.b	198
    796  4de2		       c6		      .byte.b	198
    797  4de3		       e7		      .byte.b	231
    798  4de4		       f7		      .byte.b	247
    799  4de5		       77		      .byte.b	119
    800  4de6		       77		      .byte.b	119
    801  4de7		       36		      .byte.b	54
    802  4de8		       06		      .byte.b	6
    803  4de9		       06		      .byte.b	6
    804  4dea		       07		      .byte.b	7
    805  4deb		       03		      .byte.b	3
    806  4dec		       03		      .byte.b	3
    807  4ded		       13		      .byte.b	19
    808  4dee		       13		      .byte.b	19
    809  4def		       71		      .byte.b	113
    810  4df0		       71		      .byte.b	113
    811  4df1		       70		      .byte.b	112
    812  4df2		       60		      .byte.b	96
      0  4df3					      OPTIONAL_PAGEBREAK	"CODE_DIGIT0_7", 27
 PAGE BREAK INSERTED FOR  CODE_DIGIT0_7
 REQUESTED SIZE =  $1b
 WASTED SPACE =  $d
 PAGEBREAK LOCATION =  $f600
     10  4e00					      LIST	ON
    814  4e00				   CODE_DIGIT0_7
    815  4e00		       18		      .byte.b	24
    816  4e01		       18		      .byte.b	24
    817  4e02		       18		      .byte.b	24
    818  4e03		       18		      .byte.b	24
    819  4e04		       18		      .byte.b	24
    820  4e05		       18		      .byte.b	24
    821  4e06		       18		      .byte.b	24
    822  4e07		       18		      .byte.b	24
    823  4e08		       18		      .byte.b	24
    824  4e09		       18		      .byte.b	24
    825  4e0a		       18		      .byte.b	24
    826  4e0b		       0c		      .byte.b	12
    827  4e0c		       0c		      .byte.b	12
    828  4e0d		       0c		      .byte.b	12
    829  4e0e		       0c		      .byte.b	12
    830  4e0f		       06		      .byte.b	6
    831  4e10		       06		      .byte.b	6
    832  4e11		       06		      .byte.b	6
    833  4e12		       06		      .byte.b	6
    834  4e13		       03		      .byte.b	3
    835  4e14		       03		      .byte.b	3
    836  4e15		       03		      .byte.b	3
    837  4e16		       63		      .byte.b	99
    838  4e17		       7f		      .byte.b	127
    839  4e18		       7f		      .byte.b	127
    840  4e19		       7f		      .byte.b	127
    841  4e1a		       7f		      .byte.b	127
      0  4e1b					      OPTIONAL_PAGEBREAK	"CODE_DIGIT1_7", 27
     10  4e1b					      LIST	ON
    843  4e1b				   CODE_DIGIT1_7
    844  4e1b		       18		      .byte.b	24
    845  4e1c		       18		      .byte.b	24
    846  4e1d		       18		      .byte.b	24
    847  4e1e		       18		      .byte.b	24
    848  4e1f		       18		      .byte.b	24
    849  4e20		       18		      .byte.b	24
    850  4e21		       18		      .byte.b	24
    851  4e22		       18		      .byte.b	24
    852  4e23		       18		      .byte.b	24
    853  4e24		       18		      .byte.b	24
    854  4e25		       18		      .byte.b	24
    855  4e26		       30		      .byte.b	48
    856  4e27		       30		      .byte.b	48
    857  4e28		       30		      .byte.b	48
    858  4e29		       30		      .byte.b	48
    859  4e2a		       60		      .byte.b	96
    860  4e2b		       60		      .byte.b	96
    861  4e2c		       60		      .byte.b	96
    862  4e2d		       60		      .byte.b	96
    863  4e2e		       c0		      .byte.b	192
    864  4e2f		       c0		      .byte.b	192
    865  4e30		       c0		      .byte.b	192
    866  4e31		       c6		      .byte.b	198
    867  4e32		       fe		      .byte.b	254
    868  4e33		       fe		      .byte.b	254
    869  4e34		       fe		      .byte.b	254
    870  4e35		       fe		      .byte.b	254
      0  4e36					      OPTIONAL_PAGEBREAK	"CODE_DIGIT2_7", 27
     10  4e36					      LIST	ON
    872  4e36				   CODE_DIGIT2_7
    873  4e36		       88		      .byte.b	136
    874  4e37		       88		      .byte.b	136
    875  4e38		       88		      .byte.b	136
    876  4e39		       88		      .byte.b	136
    877  4e3a		       88		      .byte.b	136
    878  4e3b		       88		      .byte.b	136
    879  4e3c		       88		      .byte.b	136
    880  4e3d		       88		      .byte.b	136
    881  4e3e		       88		      .byte.b	136
    882  4e3f		       88		      .byte.b	136
    883  4e40		       88		      .byte.b	136
    884  4e41		       0c		      .byte.b	12
    885  4e42		       0c		      .byte.b	12
    886  4e43		       0c		      .byte.b	12
    887  4e44		       0c		      .byte.b	12
    888  4e45		       06		      .byte.b	6
    889  4e46		       06		      .byte.b	6
    890  4e47		       06		      .byte.b	6
    891  4e48		       06		      .byte.b	6
    892  4e49		       03		      .byte.b	3
    893  4e4a		       03		      .byte.b	3
    894  4e4b		       03		      .byte.b	3
    895  4e4c		       63		      .byte.b	99
    896  4e4d		       ef		      .byte.b	239
    897  4e4e		       ef		      .byte.b	239
    898  4e4f		       ef		      .byte.b	239
    899  4e50		       ef		      .byte.b	239
      0  4e51					      OPTIONAL_PAGEBREAK	"CODE_DIGIT3_7", 27
     10  4e51					      LIST	ON
    901  4e51				   CODE_DIGIT3_7
    902  4e51		       11		      .byte.b	17
    903  4e52		       11		      .byte.b	17
    904  4e53		       11		      .byte.b	17
    905  4e54		       11		      .byte.b	17
    906  4e55		       11		      .byte.b	17
    907  4e56		       11		      .byte.b	17
    908  4e57		       11		      .byte.b	17
    909  4e58		       11		      .byte.b	17
    910  4e59		       11		      .byte.b	17
    911  4e5a		       11		      .byte.b	17
    912  4e5b		       11		      .byte.b	17
    913  4e5c		       30		      .byte.b	48
    914  4e5d		       30		      .byte.b	48
    915  4e5e		       30		      .byte.b	48
    916  4e5f		       30		      .byte.b	48
    917  4e60		       60		      .byte.b	96
    918  4e61		       60		      .byte.b	96
    919  4e62		       60		      .byte.b	96
    920  4e63		       60		      .byte.b	96
    921  4e64		       c0		      .byte.b	192
    922  4e65		       c0		      .byte.b	192
    923  4e66		       c0		      .byte.b	192
    924  4e67		       c6		      .byte.b	198
    925  4e68		       f7		      .byte.b	247
    926  4e69		       f7		      .byte.b	247
    927  4e6a		       f7		      .byte.b	247
    928  4e6b		       f7		      .byte.b	247
      0  4e6c					      OPTIONAL_PAGEBREAK	"CODE_DIGIT0_8", 27
     10  4e6c					      LIST	ON
    930  4e6c				   CODE_DIGIT0_8
    931  4e6c		       1c		      .byte.b	28
    932  4e6d		       3e		      .byte.b	62
    933  4e6e		       3e		      .byte.b	62
    934  4e6f		       7f		      .byte.b	127
    935  4e70		       77		      .byte.b	119
    936  4e71		       63		      .byte.b	99
    937  4e72		       63		      .byte.b	99
    938  4e73		       63		      .byte.b	99
    939  4e74		       63		      .byte.b	99
    940  4e75		       63		      .byte.b	99
    941  4e76		       63		      .byte.b	99
    942  4e77		       77		      .byte.b	119
    943  4e78		       3f		      .byte.b	63
    944  4e79		       3e		      .byte.b	62
    945  4e7a		       7e		      .byte.b	126
    946  4e7b		       77		      .byte.b	119
    947  4e7c		       63		      .byte.b	99
    948  4e7d		       63		      .byte.b	99
    949  4e7e		       63		      .byte.b	99
    950  4e7f		       63		      .byte.b	99
    951  4e80		       63		      .byte.b	99
    952  4e81		       63		      .byte.b	99
    953  4e82		       77		      .byte.b	119
    954  4e83		       7f		      .byte.b	127
    955  4e84		       3e		      .byte.b	62
    956  4e85		       3e		      .byte.b	62
    957  4e86		       1c		      .byte.b	28
      0  4e87					      OPTIONAL_PAGEBREAK	"CODE_DIGIT1_8", 27
     10  4e87					      LIST	ON
    959  4e87				   CODE_DIGIT1_8
    960  4e87		       38		      .byte.b	56
    961  4e88		       7c		      .byte.b	124
    962  4e89		       7c		      .byte.b	124
    963  4e8a		       fe		      .byte.b	254
    964  4e8b		       ee		      .byte.b	238
    965  4e8c		       c6		      .byte.b	198
    966  4e8d		       c6		      .byte.b	198
    967  4e8e		       c6		      .byte.b	198
    968  4e8f		       c6		      .byte.b	198
    969  4e90		       c6		      .byte.b	198
    970  4e91		       c6		      .byte.b	198
    971  4e92		       ee		      .byte.b	238
    972  4e93		       fc		      .byte.b	252
    973  4e94		       7c		      .byte.b	124
    974  4e95		       7e		      .byte.b	126
    975  4e96		       ee		      .byte.b	238
    976  4e97		       c6		      .byte.b	198
    977  4e98		       c6		      .byte.b	198
    978  4e99		       c6		      .byte.b	198
    979  4e9a		       c6		      .byte.b	198
    980  4e9b		       c6		      .byte.b	198
    981  4e9c		       c6		      .byte.b	198
    982  4e9d		       ee		      .byte.b	238
    983  4e9e		       fe		      .byte.b	254
    984  4e9f		       7c		      .byte.b	124
    985  4ea0		       7c		      .byte.b	124
    986  4ea1		       38		      .byte.b	56
      0  4ea2					      OPTIONAL_PAGEBREAK	"CODE_DIGIT2_8", 27
     10  4ea2					      LIST	ON
    988  4ea2				   CODE_DIGIT2_8
    989  4ea2		       8c		      .byte.b	140
    990  4ea3		       ce		      .byte.b	206
    991  4ea4		       ce		      .byte.b	206
    992  4ea5		       ef		      .byte.b	239
    993  4ea6		       e7		      .byte.b	231
    994  4ea7		       63		      .byte.b	99
    995  4ea8		       63		      .byte.b	99
    996  4ea9		       63		      .byte.b	99
    997  4eaa		       63		      .byte.b	99
    998  4eab		       63		      .byte.b	99
    999  4eac		       63		      .byte.b	99
   1000  4ead		       e7		      .byte.b	231
   1001  4eae		       cf		      .byte.b	207
   1002  4eaf		       ce		      .byte.b	206
   1003  4eb0		       ee		      .byte.b	238
   1004  4eb1		       e7		      .byte.b	231
   1005  4eb2		       63		      .byte.b	99
   1006  4eb3		       63		      .byte.b	99
   1007  4eb4		       63		      .byte.b	99
   1008  4eb5		       63		      .byte.b	99
   1009  4eb6		       63		      .byte.b	99
   1010  4eb7		       63		      .byte.b	99
   1011  4eb8		       e7		      .byte.b	231
   1012  4eb9		       ef		      .byte.b	239
   1013  4eba		       ce		      .byte.b	206
   1014  4ebb		       ce		      .byte.b	206
   1015  4ebc		       8c		      .byte.b	140
      0  4ebd					      OPTIONAL_PAGEBREAK	"CODE_DIGIT3_8", 27
     10  4ebd					      LIST	ON
   1017  4ebd				   CODE_DIGIT3_8
   1018  4ebd		       31		      .byte.b	49
   1019  4ebe		       73		      .byte.b	115
   1020  4ebf		       73		      .byte.b	115
   1021  4ec0		       f7		      .byte.b	247
   1022  4ec1		       e7		      .byte.b	231
   1023  4ec2		       c6		      .byte.b	198
   1024  4ec3		       c6		      .byte.b	198
   1025  4ec4		       c6		      .byte.b	198
   1026  4ec5		       c6		      .byte.b	198
   1027  4ec6		       c6		      .byte.b	198
   1028  4ec7		       c6		      .byte.b	198
   1029  4ec8		       e7		      .byte.b	231
   1030  4ec9		       f3		      .byte.b	243
   1031  4eca		       73		      .byte.b	115
   1032  4ecb		       77		      .byte.b	119
   1033  4ecc		       e7		      .byte.b	231
   1034  4ecd		       c6		      .byte.b	198
   1035  4ece		       c6		      .byte.b	198
   1036  4ecf		       c6		      .byte.b	198
   1037  4ed0		       c6		      .byte.b	198
   1038  4ed1		       c6		      .byte.b	198
   1039  4ed2		       c6		      .byte.b	198
   1040  4ed3		       e7		      .byte.b	231
   1041  4ed4		       f7		      .byte.b	247
   1042  4ed5		       73		      .byte.b	115
   1043  4ed6		       73		      .byte.b	115
   1044  4ed7		       31		      .byte.b	49
      0  4ed8					      OPTIONAL_PAGEBREAK	"CODE_DIGIT0_9", 27
     10  4ed8					      LIST	ON
   1046  4ed8				   CODE_DIGIT0_9
   1047  4ed8		       30		      .byte.b	48
   1048  4ed9		       38		      .byte.b	56
   1049  4eda		       3c		      .byte.b	60
   1050  4edb		       3c		      .byte.b	60
   1051  4edc		       0e		      .byte.b	14
   1052  4edd		       0e		      .byte.b	14
   1053  4ede		       06		      .byte.b	6
   1054  4edf		       07		      .byte.b	7
   1055  4ee0		       07		      .byte.b	7
   1056  4ee1		       03		      .byte.b	3
   1057  4ee2		       03		      .byte.b	3
   1058  4ee3		       1b		      .byte.b	27
   1059  4ee4		       3f		      .byte.b	63
   1060  4ee5		       3f		      .byte.b	63
   1061  4ee6		       7f		      .byte.b	127
   1062  4ee7		       77		      .byte.b	119
   1063  4ee8		       63		      .byte.b	99
   1064  4ee9		       63		      .byte.b	99
   1065  4eea		       63		      .byte.b	99
   1066  4eeb		       63		      .byte.b	99
   1067  4eec		       63		      .byte.b	99
   1068  4eed		       63		      .byte.b	99
   1069  4eee		       77		      .byte.b	119
   1070  4eef		       7f		      .byte.b	127
   1071  4ef0		       3e		      .byte.b	62
   1072  4ef1		       3e		      .byte.b	62
   1073  4ef2		       1c		      .byte.b	28
      0  4ef3					      OPTIONAL_PAGEBREAK	"CODE_DIGIT1_9", 27
 PAGE BREAK INSERTED FOR  CODE_DIGIT1_9
 REQUESTED SIZE =  $1b
 WASTED SPACE =  $d
 PAGEBREAK LOCATION =  $f700
     10  4f00					      LIST	ON
   1075  4f00				   CODE_DIGIT1_9
   1076  4f00		       0c		      .byte.b	12
   1077  4f01		       1c		      .byte.b	28
   1078  4f02		       3c		      .byte.b	60
   1079  4f03		       3c		      .byte.b	60
   1080  4f04		       70		      .byte.b	112
   1081  4f05		       70		      .byte.b	112
   1082  4f06		       60		      .byte.b	96
   1083  4f07		       e0		      .byte.b	224
   1084  4f08		       e0		      .byte.b	224
   1085  4f09		       c0		      .byte.b	192
   1086  4f0a		       c0		      .byte.b	192
   1087  4f0b		       d8		      .byte.b	216
   1088  4f0c		       fc		      .byte.b	252
   1089  4f0d		       fc		      .byte.b	252
   1090  4f0e		       fe		      .byte.b	254
   1091  4f0f		       ee		      .byte.b	238
   1092  4f10		       c6		      .byte.b	198
   1093  4f11		       c6		      .byte.b	198
   1094  4f12		       c6		      .byte.b	198
   1095  4f13		       c6		      .byte.b	198
   1096  4f14		       c6		      .byte.b	198
   1097  4f15		       c6		      .byte.b	198
   1098  4f16		       ee		      .byte.b	238
   1099  4f17		       fe		      .byte.b	254
   1100  4f18		       7c		      .byte.b	124
   1101  4f19		       7c		      .byte.b	124
   1102  4f1a		       38		      .byte.b	56
      0  4f1b					      OPTIONAL_PAGEBREAK	"CODE_DIGIT2_9", 27
     10  4f1b					      LIST	ON
   1104  4f1b				   CODE_DIGIT2_9
   1105  4f1b		       c0		      .byte.b	192
   1106  4f1c		       c8		      .byte.b	200
   1107  4f1d		       cc		      .byte.b	204
   1108  4f1e		       cc		      .byte.b	204
   1109  4f1f		       0e		      .byte.b	14
   1110  4f20		       0e		      .byte.b	14
   1111  4f21		       06		      .byte.b	6
   1112  4f22		       07		      .byte.b	7
   1113  4f23		       07		      .byte.b	7
   1114  4f24		       03		      .byte.b	3
   1115  4f25		       03		      .byte.b	3
   1116  4f26		       8b		      .byte.b	139
   1117  4f27		       cf		      .byte.b	207
   1118  4f28		       cf		      .byte.b	207
   1119  4f29		       ef		      .byte.b	239
   1120  4f2a		       e7		      .byte.b	231
   1121  4f2b		       63		      .byte.b	99
   1122  4f2c		       63		      .byte.b	99
   1123  4f2d		       63		      .byte.b	99
   1124  4f2e		       63		      .byte.b	99
   1125  4f2f		       63		      .byte.b	99
   1126  4f30		       63		      .byte.b	99
   1127  4f31		       e7		      .byte.b	231
   1128  4f32		       ef		      .byte.b	239
   1129  4f33		       ce		      .byte.b	206
   1130  4f34		       ce		      .byte.b	206
   1131  4f35		       8c		      .byte.b	140
      0  4f36					      OPTIONAL_PAGEBREAK	"CODE_DIGIT3_9", 27
     10  4f36					      LIST	ON
   1133  4f36				   CODE_DIGIT3_9
   1134  4f36		       03		      .byte.b	3
   1135  4f37		       13		      .byte.b	19
   1136  4f38		       33		      .byte.b	51
   1137  4f39		       33		      .byte.b	51
   1138  4f3a		       70		      .byte.b	112
   1139  4f3b		       70		      .byte.b	112
   1140  4f3c		       60		      .byte.b	96
   1141  4f3d		       e0		      .byte.b	224
   1142  4f3e		       e0		      .byte.b	224
   1143  4f3f		       c0		      .byte.b	192
   1144  4f40		       c0		      .byte.b	192
   1145  4f41		       d1		      .byte.b	209
   1146  4f42		       f3		      .byte.b	243
   1147  4f43		       f3		      .byte.b	243
   1148  4f44		       f7		      .byte.b	247
   1149  4f45		       e7		      .byte.b	231
   1150  4f46		       c6		      .byte.b	198
   1151  4f47		       c6		      .byte.b	198
   1152  4f48		       c6		      .byte.b	198
   1153  4f49		       c6		      .byte.b	198
   1154  4f4a		       c6		      .byte.b	198
   1155  4f4b		       c6		      .byte.b	198
   1156  4f4c		       e7		      .byte.b	231
   1157  4f4d		       f7		      .byte.b	247
   1158  4f4e		       73		      .byte.b	115
   1159  4f4f		       73		      .byte.b	115
   1160  4f50		       31		      .byte.b	49
      0  4f51					      OPTIONAL_PAGEBREAK	"CODE_DIGIT0_Q", 27
     10  4f51					      LIST	ON
   1162  4f51				   CODE_DIGIT0_Q
   1163  4f51		       18		      .byte.b	24
   1164  4f52		       18		      .byte.b	24
   1165  4f53		       18		      .byte.b	24
   1166  4f54		       18		      .byte.b	24
   1167  4f55		       00		      .byte.b	0
   1168  4f56		       00		      .byte.b	0
   1169  4f57		       18		      .byte.b	24
   1170  4f58		       18		      .byte.b	24
   1171  4f59		       18		      .byte.b	24
   1172  4f5a		       18		      .byte.b	24
   1173  4f5b		       1c		      .byte.b	28
   1174  4f5c		       0c		      .byte.b	12
   1175  4f5d		       0c		      .byte.b	12
   1176  4f5e		       0e		      .byte.b	14
   1177  4f5f		       06		      .byte.b	6
   1178  4f60		       07		      .byte.b	7
   1179  4f61		       03		      .byte.b	3
   1180  4f62		       03		      .byte.b	3
   1181  4f63		       03		      .byte.b	3
   1182  4f64		       03		      .byte.b	3
   1183  4f65		       63		      .byte.b	99
   1184  4f66		       63		      .byte.b	99
   1185  4f67		       77		      .byte.b	119
   1186  4f68		       3e		      .byte.b	62
   1187  4f69		       3e		      .byte.b	62
   1188  4f6a		       3e		      .byte.b	62
   1189  4f6b		       1c		      .byte.b	28
      0  4f6c					      OPTIONAL_PAGEBREAK	"CODE_DIGIT1_Q", 27
     10  4f6c					      LIST	ON
   1191  4f6c				   CODE_DIGIT1_Q
   1192  4f6c		       18		      .byte.b	24
   1193  4f6d		       18		      .byte.b	24
   1194  4f6e		       18		      .byte.b	24
   1195  4f6f		       18		      .byte.b	24
   1196  4f70		       00		      .byte.b	0
   1197  4f71		       00		      .byte.b	0
   1198  4f72		       18		      .byte.b	24
   1199  4f73		       18		      .byte.b	24
   1200  4f74		       18		      .byte.b	24
   1201  4f75		       18		      .byte.b	24
   1202  4f76		       38		      .byte.b	56
   1203  4f77		       30		      .byte.b	48
   1204  4f78		       30		      .byte.b	48
   1205  4f79		       70		      .byte.b	112
   1206  4f7a		       60		      .byte.b	96
   1207  4f7b		       e0		      .byte.b	224
   1208  4f7c		       c0		      .byte.b	192
   1209  4f7d		       c0		      .byte.b	192
   1210  4f7e		       c0		      .byte.b	192
   1211  4f7f		       c0		      .byte.b	192
   1212  4f80		       c6		      .byte.b	198
   1213  4f81		       c6		      .byte.b	198
   1214  4f82		       ee		      .byte.b	238
   1215  4f83		       7c		      .byte.b	124
   1216  4f84		       7c		      .byte.b	124
   1217  4f85		       7c		      .byte.b	124
   1218  4f86		       38		      .byte.b	56
      0  4f87					      OPTIONAL_PAGEBREAK	"CODE_DIGIT2_Q", 27
     10  4f87					      LIST	ON
   1220  4f87				   CODE_DIGIT2_Q
   1221  4f87		       88		      .byte.b	136
   1222  4f88		       88		      .byte.b	136
   1223  4f89		       88		      .byte.b	136
   1224  4f8a		       88		      .byte.b	136
   1225  4f8b		       00		      .byte.b	0
   1226  4f8c		       00		      .byte.b	0
   1227  4f8d		       88		      .byte.b	136
   1228  4f8e		       88		      .byte.b	136
   1229  4f8f		       88		      .byte.b	136
   1230  4f90		       88		      .byte.b	136
   1231  4f91		       8c		      .byte.b	140
   1232  4f92		       0c		      .byte.b	12
   1233  4f93		       0c		      .byte.b	12
   1234  4f94		       0e		      .byte.b	14
   1235  4f95		       06		      .byte.b	6
   1236  4f96		       07		      .byte.b	7
   1237  4f97		       03		      .byte.b	3
   1238  4f98		       03		      .byte.b	3
   1239  4f99		       03		      .byte.b	3
   1240  4f9a		       03		      .byte.b	3
   1241  4f9b		       63		      .byte.b	99
   1242  4f9c		       63		      .byte.b	99
   1243  4f9d		       e7		      .byte.b	231
   1244  4f9e		       ce		      .byte.b	206
   1245  4f9f		       ce		      .byte.b	206
   1246  4fa0		       ce		      .byte.b	206
   1247  4fa1		       8c		      .byte.b	140
      0  4fa2					      OPTIONAL_PAGEBREAK	"CODE_DIGIT3_Q", 27
     10  4fa2					      LIST	ON
   1249  4fa2				   CODE_DIGIT3_Q
   1250  4fa2		       11		      .byte.b	17
   1251  4fa3		       11		      .byte.b	17
   1252  4fa4		       11		      .byte.b	17
   1253  4fa5		       11		      .byte.b	17
   1254  4fa6		       00		      .byte.b	0
   1255  4fa7		       00		      .byte.b	0
   1256  4fa8		       11		      .byte.b	17
   1257  4fa9		       11		      .byte.b	17
   1258  4faa		       11		      .byte.b	17
   1259  4fab		       11		      .byte.b	17
   1260  4fac		       31		      .byte.b	49
   1261  4fad		       30		      .byte.b	48
   1262  4fae		       30		      .byte.b	48
   1263  4faf		       70		      .byte.b	112
   1264  4fb0		       60		      .byte.b	96
   1265  4fb1		       e0		      .byte.b	224
   1266  4fb2		       c0		      .byte.b	192
   1267  4fb3		       c0		      .byte.b	192
   1268  4fb4		       c0		      .byte.b	192
   1269  4fb5		       c0		      .byte.b	192
   1270  4fb6		       c6		      .byte.b	198
   1271  4fb7		       c6		      .byte.b	198
   1272  4fb8		       e7		      .byte.b	231
   1273  4fb9		       73		      .byte.b	115
   1274  4fba		       73		      .byte.b	115
   1275  4fbb		       73		      .byte.b	115
   1276  4fbc		       31		      .byte.b	49
------- FILE coder.asm
    455  4fbd
    456  4fbd
      0  4fbd					      CHECK_BANK_SIZE	"CODER"
      1  4fbd		       07 bd	   .TEMP      =	* - BANK_START
 CODER (2K) SIZE =  $7bd , FREE= $43
      2  4fbd					      ECHO	"CODER", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4fbd				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  4fbd				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4fbd				  -	      ERR
      6  4fbd					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_INITBANK.asm LEVEL 2 PASS 3
      0  4fbd					      include	"BANK_INITBANK.asm"	; MUST be after banks that include levels -- otherwise MAX_LEVELBANK is not calculated properly
      1  4fbd							;    Sokoboo - a Sokoban implementation
      2  4fbd							;    using a generic tile-based display engine for the Atari 2600
      3  4fbd							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  4fbd							;
      5  4fbd							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  4fbd							;
      7  4fbd							;    Code related to the generic tile-based display engine was developed by
      8  4fbd							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  4fbd							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  4fbd							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  4fbd							;
     12  4fbd							;    Code related to music and sound effects uses the TIATracker music player
     13  4fbd							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  4fbd							;    directory for Apache licensing details.
     15  4fbd							;
     16  4fbd							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  4fbd							;    See the copyright notices in the License directory for a list of level
     18  4fbd							;    contributors.
     19  4fbd							;
     20  4fbd							;    Except where otherwise indicated, this software is released under the
     21  4fbd							;    following licensing arrangement...
     22  4fbd							;
     23  4fbd							;    This program is free software: you can redistribute it and/or modify
     24  4fbd							;    it under the terms of the GNU General Public License as published by
     25  4fbd							;    the Free Software Foundation, either version 3 of the License, or
     26  4fbd							;    (at your option) any later version.
     27  4fbd							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  4fbd
     29  4fbd							;    This program is distributed in the hope that it will be useful,
     30  4fbd							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  4fbd							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  4fbd							;    GNU General Public License for more details.
     33  4fbd
      0  4fbd					      NEWBANK	INITBANK
      1  561c ????				      SEG	INITBANK
      2  5000					      ORG	ORIGIN
      3  5000					      RORG	$F000
      4  5000				   BANK_START SET	*
      5  5000				   INITBANK   SET	ORIGIN / 2048
      6  5000				   ORIGIN     SET	ORIGIN + 2048
      7  5000				   _CURRENT_BANK SET	INITBANK
     35  5000
     36  5000		       00		      .byte.b	0	; to avoid extra cycle when accessing via BoardLineStartLO-1,y
     37  5001
      0  5001					      DEFINE_SUBROUTINE	BoardLineStartLO
      1  5001		       00 0a	   BANK_BoardLineStartLO =	_CURRENT_BANK
      2  5001					      SUBROUTINE
      3  5001				   BoardLineStartLO
     39  5001
     40  5001							; Gives the start address (LO) of each board line
     41  5001					      if	1
     42  5001				   .BOARD_LOCATION SET	Board
     43  5001					      REPEAT	SIZE_BOARD_Y
     44  5001				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5001				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5001					      ENDIF
     47  5001		       00		      .byte.b	<.BOARD_LOCATION
     48  5001				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5001					      REPEND
     44  5002				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5002				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5002					      ENDIF
     47  5002		       20		      .byte.b	<.BOARD_LOCATION
     48  5002				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5002					      REPEND
     44  5003				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5003				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5003					      ENDIF
     47  5003		       40		      .byte.b	<.BOARD_LOCATION
     48  5003				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5003					      REPEND
     44  5004				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5004				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5004					      ENDIF
     47  5004		       60		      .byte.b	<.BOARD_LOCATION
     48  5004				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5004					      REPEND
     44  5005				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5005				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5005					      ENDIF
     47  5005		       80		      .byte.b	<.BOARD_LOCATION
     48  5005				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5005					      REPEND
     44  5006				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5006				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5006					      ENDIF
     47  5006		       a0		      .byte.b	<.BOARD_LOCATION
     48  5006				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5006					      REPEND
     44  5007				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5007				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5007					      ENDIF
     47  5007		       c0		      .byte.b	<.BOARD_LOCATION
     48  5007				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5007					      REPEND
     44  5008				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5008				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5008					      ENDIF
     47  5008		       e0		      .byte.b	<.BOARD_LOCATION
     48  5008				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5008					      REPEND
     44  5009				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5009				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5009					      ENDIF
     47  5009		       00		      .byte.b	<.BOARD_LOCATION
     48  5009				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5009					      REPEND
     44  500a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  500a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  500a					      ENDIF
     47  500a		       20		      .byte.b	<.BOARD_LOCATION
     48  500a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  500a					      REPEND
     44  500b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  500b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  500b					      ENDIF
     47  500b		       40		      .byte.b	<.BOARD_LOCATION
     48  500b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  500b					      REPEND
     44  500c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  500c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  500c					      ENDIF
     47  500c		       60		      .byte.b	<.BOARD_LOCATION
     48  500c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  500c					      REPEND
     44  500d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  500d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  500d					      ENDIF
     47  500d		       80		      .byte.b	<.BOARD_LOCATION
     48  500d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  500d					      REPEND
     44  500e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  500e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  500e					      ENDIF
     47  500e		       a0		      .byte.b	<.BOARD_LOCATION
     48  500e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  500e					      REPEND
     44  500f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  500f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  500f					      ENDIF
     47  500f		       c0		      .byte.b	<.BOARD_LOCATION
     48  500f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  500f					      REPEND
     44  5010				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5010				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5010					      ENDIF
     47  5010		       e0		      .byte.b	<.BOARD_LOCATION
     48  5010				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5010					      REPEND
     44  5011				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5011				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5011					      ENDIF
     47  5011		       00		      .byte.b	<.BOARD_LOCATION
     48  5011				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5011					      REPEND
     44  5012				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5012				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5012					      ENDIF
     47  5012		       20		      .byte.b	<.BOARD_LOCATION
     48  5012				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5012					      REPEND
     44  5013				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5013				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5013					      ENDIF
     47  5013		       40		      .byte.b	<.BOARD_LOCATION
     48  5013				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5013					      REPEND
     44  5014				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5014				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5014					      ENDIF
     47  5014		       60		      .byte.b	<.BOARD_LOCATION
     48  5014				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5014					      REPEND
     44  5015				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5015				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5015					      ENDIF
     47  5015		       80		      .byte.b	<.BOARD_LOCATION
     48  5015				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5015					      REPEND
     44  5016				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5016				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5016					      ENDIF
     47  5016		       a0		      .byte.b	<.BOARD_LOCATION
     48  5016				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5016					      REPEND
     44  5017				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5017				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5017					      ENDIF
     47  5017		       c0		      .byte.b	<.BOARD_LOCATION
     48  5017				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5017					      REPEND
     44  5018				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5018				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5018					      ENDIF
     47  5018		       e0		      .byte.b	<.BOARD_LOCATION
     48  5018				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5018					      REPEND
     44  5019				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5019				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5019					      ENDIF
     47  5019		       00		      .byte.b	<.BOARD_LOCATION
     48  5019				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5019					      REPEND
     44  501a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  501a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  501a					      ENDIF
     47  501a		       20		      .byte.b	<.BOARD_LOCATION
     48  501a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  501a					      REPEND
     44  501b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  501b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  501b					      ENDIF
     47  501b		       40		      .byte.b	<.BOARD_LOCATION
     48  501b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  501b					      REPEND
     44  501c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  501c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  501c					      ENDIF
     47  501c		       60		      .byte.b	<.BOARD_LOCATION
     48  501c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  501c					      REPEND
     44  501d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  501d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  501d					      ENDIF
     47  501d		       80		      .byte.b	<.BOARD_LOCATION
     48  501d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  501d					      REPEND
     44  501e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  501e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  501e					      ENDIF
     47  501e		       a0		      .byte.b	<.BOARD_LOCATION
     48  501e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  501e					      REPEND
     44  501f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  501f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  501f					      ENDIF
     47  501f		       c0		      .byte.b	<.BOARD_LOCATION
     48  501f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  501f					      REPEND
     44  5020				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5020				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5020					      ENDIF
     47  5020		       e0		      .byte.b	<.BOARD_LOCATION
     48  5020				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     49  5021					      REPEND
      0  5021					      CHECKPAGEX	BoardLineStartLO, "BoardLineStartLO in BANK_INITBANK.asm"
      9  5021					      LIST	ON
     51  5021
     52  5021		       04 00	   SIZE_BOARD =	.BOARD_LOCATION-Board	; verify calculated value
     53  5021					      endif
     54  5021
     55  5021							;------------------------------------------------------------------------------
     56  5021
     57  5021				   BoardLineStartHiR
     58  5021
     59  5021							; Gives the start address (HI) of each board line
     60  5021							; Note this caters for the memory wrapping when we go from bank to bank, as
     61  5021							; the board overlays multiple banks!
     62  5021
     63  5021				   .BOARD_LOCATION SET	Board
     64  5021					      REPEAT	SIZE_BOARD_Y
     65  5021				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5021				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5021					      ENDIF
     68  5021		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5021				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5021					      REPEND
     65  5022				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5022				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5022					      ENDIF
     68  5022		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5022				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5022					      REPEND
     65  5023				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5023				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5023					      ENDIF
     68  5023		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5023				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5023					      REPEND
     65  5024				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5024				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5024					      ENDIF
     68  5024		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5024				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5024					      REPEND
     65  5025				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5025				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5025					      ENDIF
     68  5025		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5025				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5025					      REPEND
     65  5026				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5026				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5026					      ENDIF
     68  5026		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5026				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5026					      REPEND
     65  5027				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5027				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5027					      ENDIF
     68  5027		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5027				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5027					      REPEND
     65  5028				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5028				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5028					      ENDIF
     68  5028		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5028				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5028					      REPEND
     65  5029				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5029				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5029					      ENDIF
     68  5029		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5029				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5029					      REPEND
     65  502a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  502a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  502a					      ENDIF
     68  502a		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  502a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  502a					      REPEND
     65  502b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  502b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  502b					      ENDIF
     68  502b		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  502b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  502b					      REPEND
     65  502c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  502c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  502c					      ENDIF
     68  502c		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  502c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  502c					      REPEND
     65  502d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  502d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  502d					      ENDIF
     68  502d		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  502d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  502d					      REPEND
     65  502e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  502e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  502e					      ENDIF
     68  502e		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  502e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  502e					      REPEND
     65  502f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  502f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  502f					      ENDIF
     68  502f		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  502f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  502f					      REPEND
     65  5030				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5030				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5030					      ENDIF
     68  5030		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5030				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5030					      REPEND
     65  5031				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5031				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5031					      ENDIF
     68  5031		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5031				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5031					      REPEND
     65  5032				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5032				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5032					      ENDIF
     68  5032		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5032				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5032					      REPEND
     65  5033				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5033				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5033					      ENDIF
     68  5033		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5033				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5033					      REPEND
     65  5034				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5034				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5034					      ENDIF
     68  5034		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5034				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5034					      REPEND
     65  5035				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5035				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5035					      ENDIF
     68  5035		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5035				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5035					      REPEND
     65  5036				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5036				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5036					      ENDIF
     68  5036		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5036				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5036					      REPEND
     65  5037				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5037				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5037					      ENDIF
     68  5037		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5037				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5037					      REPEND
     65  5038				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5038				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5038					      ENDIF
     68  5038		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5038				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5038					      REPEND
     65  5039				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5039				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5039					      ENDIF
     68  5039		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5039				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5039					      REPEND
     65  503a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  503a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  503a					      ENDIF
     68  503a		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  503a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  503a					      REPEND
     65  503b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  503b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  503b					      ENDIF
     68  503b		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  503b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  503b					      REPEND
     65  503c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  503c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  503c					      ENDIF
     68  503c		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  503c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  503c					      REPEND
     65  503d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  503d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  503d					      ENDIF
     68  503d		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  503d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  503d					      REPEND
     65  503e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  503e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  503e					      ENDIF
     68  503e		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  503e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  503e					      REPEND
     65  503f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  503f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  503f					      ENDIF
     68  503f		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  503f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  503f					      REPEND
     65  5040				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5040				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5040					      ENDIF
     68  5040		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5040				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     70  5041					      REPEND
      0  5041					      CHECKPAGEX	BoardLineStartHiR, "BoardLineStartHiR in BANK_INITBANK"
      9  5041					      LIST	ON
     72  5041							;------------------------------------------------------------------------------
     73  5041
     74  5041				   BoardLineStartHiW
     75  5041
     76  5041							; Gives the start address (HI) of each board line
     77  5041							; Note this caters for the memory wrapping when we go from bank to bank, as
     78  5041							; the board overlays multiple banks!
     79  5041
     80  5041				   .BOARD_LOCATION SET	Board
     81  5041					      REPEAT	SIZE_BOARD_Y
     82  5041				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5041				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5041					      ENDIF
     85  5041		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5041				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5041					      REPEND
     82  5042				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5042				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5042					      ENDIF
     85  5042		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5042				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5042					      REPEND
     82  5043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5043					      ENDIF
     85  5043		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5043					      REPEND
     82  5044				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5044				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5044					      ENDIF
     85  5044		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5044				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5044					      REPEND
     82  5045				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5045				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5045					      ENDIF
     85  5045		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5045				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5045					      REPEND
     82  5046				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5046				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5046					      ENDIF
     85  5046		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5046				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5046					      REPEND
     82  5047				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5047				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5047					      ENDIF
     85  5047		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5047				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5047					      REPEND
     82  5048				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5048				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5048					      ENDIF
     85  5048		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5048				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5048					      REPEND
     82  5049				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5049				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5049					      ENDIF
     85  5049		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5049				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5049					      REPEND
     82  504a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  504a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  504a					      ENDIF
     85  504a		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  504a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  504a					      REPEND
     82  504b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  504b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  504b					      ENDIF
     85  504b		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  504b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  504b					      REPEND
     82  504c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  504c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  504c					      ENDIF
     85  504c		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  504c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  504c					      REPEND
     82  504d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  504d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  504d					      ENDIF
     85  504d		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  504d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  504d					      REPEND
     82  504e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  504e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  504e					      ENDIF
     85  504e		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  504e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  504e					      REPEND
     82  504f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  504f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  504f					      ENDIF
     85  504f		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  504f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  504f					      REPEND
     82  5050				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5050				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5050					      ENDIF
     85  5050		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5050				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5050					      REPEND
     82  5051				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5051				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5051					      ENDIF
     85  5051		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5051				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5051					      REPEND
     82  5052				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5052				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5052					      ENDIF
     85  5052		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5052				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5052					      REPEND
     82  5053				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5053				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5053					      ENDIF
     85  5053		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5053				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5053					      REPEND
     82  5054				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5054				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5054					      ENDIF
     85  5054		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5054				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5054					      REPEND
     82  5055				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5055				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5055					      ENDIF
     85  5055		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5055				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5055					      REPEND
     82  5056				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5056				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5056					      ENDIF
     85  5056		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5056				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5056					      REPEND
     82  5057				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5057				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5057					      ENDIF
     85  5057		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5057				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5057					      REPEND
     82  5058				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5058				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5058					      ENDIF
     85  5058		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5058				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5058					      REPEND
     82  5059				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5059				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5059					      ENDIF
     85  5059		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5059				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5059					      REPEND
     82  505a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  505a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  505a					      ENDIF
     85  505a		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  505a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  505a					      REPEND
     82  505b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  505b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  505b					      ENDIF
     85  505b		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  505b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  505b					      REPEND
     82  505c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  505c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  505c					      ENDIF
     85  505c		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  505c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  505c					      REPEND
     82  505d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  505d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  505d					      ENDIF
     85  505d		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  505d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  505d					      REPEND
     82  505e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  505e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  505e					      ENDIF
     85  505e		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  505e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  505e					      REPEND
     82  505f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  505f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  505f					      ENDIF
     85  505f		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  505f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  505f					      REPEND
     82  5060				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5060				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5060					      ENDIF
     85  5060		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5060				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     87  5061					      REPEND
      0  5061					      CHECKPAGEX	BoardLineStartHiW, "BoardLineStartHiW in BANK_INITBANK"
      9  5061					      LIST	ON
     89  5061
     90  5061							;------------------------------------------------------------------------------
     91  5061							;    IF MULTI_BANK_BOARD = YES
     92  5061							;BoardBank
     93  5061							;    ENDIF
     94  5061							; Gives the RAM bank of the start of the board row for a given row.
     95  5061
     96  5061				   .BOARD_LOCATION SET	Board - RAM_3E
     97  5061					      REPEAT	SIZE_BOARD_Y
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5061					      REPEND
     98  5061				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5061				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5061					      ENDIF
    101  5061							;    IF MULTI_BANK_BOARD = YES
    102  5061							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  5061							;    ENDIF
    104  5061				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
    105  5061					      REPEND
    106  5061							;    IF MULTI_BANK_BOARD = YES
    107  5061							;    CHECKPAGEX BoardBank, "BoardBank in BANK_INITBANK.asm"
    108  5061							;    ENDIF
    109  5061
    110  5061
    111  5061							;------------------------------------------------------------------------------
    112  5061
    113  5061				   CopyROMShadowToRAM_F000
    114  5061		       a9 f0		      lda	#>$F000
    115  5063
      0  5063					      DEFINE_SUBROUTINE	CopyROMShadowToRAM	; in INITBANK
      1  5063		       00 0a	   BANK_CopyROMShadowToRAM =	_CURRENT_BANK
      2  5063					      SUBROUTINE
      3  5063				   CopyROMShadowToRAM
    117  5063
    118  5063							; Function copies a RAM prototype ROM bank into the destination RAM bank.  Typically
    119  5063							; the variable definitions are in the ROM shadow because this allows auto-initialisation
    120  5063							; of the variable contents from ROM declarations, but still allows access to them as
    121  5063							; variables when the correct RAM bank is switched in.	Code is also, of course, copied
    122  5063							; into the RAM destination so that code is callable whenever the ROM *or* RAM bank is
    123  5063							; switched in.  Further, if multiple copies are made to multiple RAM banks, then the
    124  5063							; code co-lives in all banks and may run even as bankswitching occurs between those
    125  5063							; banks -- by the very code itself.
    126  5063
    127  5063							; Note: Relies on ROM_Bank having being set via CALL mechanism to call this function
    128  5063		       85 bb		      sta	Board_AddressR+1
    129  5065		       86 dc		      stx	O_ROM_Source_Bank	; source bank
    130  5067		       84 bf		      sty	RAM_Bank	; destination bank
    131  5069
    132  5069		       a0 00		      ldy	#0
    133  506b		       84 ba		      sty	Board_AddressR
    134  506d		       84 bc		      sty	Board_AddressW
    135  506f		       a9 14		      lda	#>($1000+RAM_WRITE)
    136  5071		       85 bd		      sta	Board_AddressW+1
    137  5073
    138  5073							; Iterate 4 pages (1K) for complete bank copy
    139  5073
    140  5073		       a9 04		      lda	#4
    141  5075		       85 db		      sta	O_CopyCount
    142  5077
    143  5077		       84 dd	   CopyPage   sty	O_Index
    144  5079		       a5 dc		      lda	O_ROM_Source_Bank
    145  507b		       20 0f f8 	      jsr	GetROMByte	; get byte from ROM shadow bank
    146  507e							;tax
    147  507e		       a4 dd		      ldy	O_Index
    148  5080		       a6 bf		      ldx	RAM_Bank
    149  5082		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 write byte to RAM bank
    150  5085
    151  5085		       a4 dd		      ldy	O_Index
    152  5087		       c8		      iny
    153  5088		       d0 ed		      bne	CopyPage
    154  508a
    155  508a		       e6 bb		      inc	Board_AddressR+1
    156  508c		       e6 bd		      inc	Board_AddressW+1
    157  508e
    158  508e		       c6 db		      dec	O_CopyCount
    159  5090		       d0 e5		      bne	CopyPage
    160  5092
    161  5092		       a4 bf		      ldy	RAM_Bank	; TODO: remove!?
    162  5094		       60		      rts
    163  5095
    164  5095
    165  5095							;------------------------------------------------------------------------------
      0  5095					      DEFINE_SUBROUTINE	SetPlatformColours	; in INITBANK
      1  5095		       00 0a	   BANK_SetPlatformColours =	_CURRENT_BANK
      2  5095					      SUBROUTINE
      3  5095				   SetPlatformColours
    167  5095
    168  5095							; Now modify the hardwired colours so that we're correctly switched for NTSC/PAL
    169  5095							; The platform (0=NTSC, 1=PAL) is set from the right difficulty switch
    170  5095							; Note: This relies on DrawTheScreen starting on page boundary so that the (),y
    171  5095							; addressing will not violate the page-crossing restriction of 3E.
    172  5095
    173  5095							;		  sty RAM_Bank			  ; we assume we called CopyROMShadowToRAM before
    174  5095
    175  5095		       a9 00		      lda	#<DrawTheScreen	; = 0
    176  5097		       85 bc		      sta	Board_AddressW
    177  5099		       a9 f4		      lda	#>( DrawTheScreen + RAM_WRITE )
    178  509b		       85 bd		      sta	Board_AddressW+1
    179  509d
    180  509d							; first, set the x index (with last one being a RTS ($60))
    181  509d
    182  509d		       a6 bf		      ldx	RAM_Bank
    183  509f		       e0 07		      cpx	#SCREEN_LINES-1	; might become variable when vertical scrolling
    184  50a1		       d0 07		      bne	.skipPatch
    185  50a3		       a9 60		      lda	#$60	; rts
    186  50a5		       a0 41		      ldy	#<SELFMOD_X
    187  50a7		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 set index/rts
    188  50aa				   .skipPatch
    189  50aa
    190  50aa
    191  50aa							; randomise the rainbow band starting point. Technically we only need
    192  50aa							; to do this on the FIRST bank
    193  50aa
    194  50aa		       a9 f8		      lda	#<(BandOffset+RAM_WRITE)
    195  50ac		       85 bc		      sta	Board_AddressW
    196  50ae		       a9 f7		      lda	#>(BandOffset+RAM_WRITE)
    197  50b0		       85 bd		      sta	Board_AddressW+1
    198  50b2		       20 52 fd 	      jsr	Random
    199  50b5		       29 1f		      and	#31
    200  50b7		       a0 00		      ldy	#0	; offset from address
    201  50b9		       20 1d f8 	      jsr	PutBoardCharacter
    202  50bc
    203  50bc
    204  50bc
    205  50bc		       a4 bf		      ldy	RAM_Bank
    206  50be		       60		      rts
    207  50bf
    208  50bf				   SelfModColOfsTbl
    209  50bf		       53 86 1d 	      .byte.b	<(SELFMOD_BLUE+1), <(SELFMOD_GREEN+1), <(SELFMOD_RED+1)
    210  50c2
    211  50c2
    212  50c2
    213  50c2				   DrawLineStartLO
    214  50c2
    215  50c2							; Gives the start address of each line in the draw flags buffer
    216  50c2
    217  50c2				   .DRAW_LOCATION SET	DrawFlag
    218  50c2					      REPEAT	SCREEN_LINES
    219  50c2		       50		      .byte.b	<.DRAW_LOCATION
    220  50c2				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    218  50c2					      REPEND
    219  50c3		       5a		      .byte.b	<.DRAW_LOCATION
    220  50c3				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    218  50c3					      REPEND
    219  50c4		       64		      .byte.b	<.DRAW_LOCATION
    220  50c4				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    218  50c4					      REPEND
    219  50c5		       6e		      .byte.b	<.DRAW_LOCATION
    220  50c5				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    218  50c5					      REPEND
    219  50c6		       78		      .byte.b	<.DRAW_LOCATION
    220  50c6				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    218  50c6					      REPEND
    219  50c7		       82		      .byte.b	<.DRAW_LOCATION
    220  50c7				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    218  50c7					      REPEND
    219  50c8		       8c		      .byte.b	<.DRAW_LOCATION
    220  50c8				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    218  50c8					      REPEND
    219  50c9		       96		      .byte.b	<.DRAW_LOCATION
    220  50c9				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    221  50ca					      REPEND
    222  50ca
    223  50ca
    224  50ca							;------------------------------------------------------------------------------
    225  50ca
      0  50ca					      DEFINE_SUBROUTINE	GetBoardAddressRW	; in INITBANK
      1  50ca		       00 0a	   BANK_GetBoardAddressRW =	_CURRENT_BANK
      2  50ca					      SUBROUTINE
      3  50ca				   GetBoardAddressRW
    227  50ca							; Must share same bank as BoardLineStart tables
    228  50ca
    229  50ca		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    230  50cd		       85 ba		      sta	Board_AddressR	; 3
    231  50cf		       85 bc		      sta	Board_AddressW	; 3
    232  50d1		       b9 21 f0 	      lda	BoardLineStartHiR,y	; 4
    233  50d4		       85 bb		      sta	Board_AddressR+1	; 3	     READ address
    234  50d6		       09 04		      ora	#>RAM_WRITE	; 2
    235  50d8		       85 bd		      sta	Board_AddressW+1	; 3	     WRITE address
    236  50da							;    IF MULTI_BANK_BOARD = YES
    237  50da							;		  ldx BoardBank,y		  ; 4 = 26    switch this on return
    238  50da							;    ELSE
    239  50da		       a2 0d		      ldx	#BANK_BOARD	; 2
    240  50dc							;    ENDIF
    241  50dc		       60		      rts		; 6 = 32[-2]
    242  50dd
    243  50dd							;------------------------------------------------------------------------------
    244  50dd
      0  50dd					      DEFINE_SUBROUTINE	GetBoardAddressR	;=24[-2](A)
      1  50dd		       00 0a	   BANK_GetBoardAddressR =	_CURRENT_BANK
      2  50dd					      SUBROUTINE
      3  50dd				   GetBoardAddressR
    246  50dd
    247  50dd		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    248  50e0		       85 ba		      sta	Board_AddressR	; 3
    249  50e2		       b9 21 f0 	      lda	BoardLineStartHiR,y	; 4
    250  50e5		       85 bb		      sta	Board_AddressR+1	; 3	 READ address
    251  50e7							;    IF MULTI_BANK_BOARD = YES
    252  50e7							;		  lda BoardBank,y		  ; 4	  switch this on return
    253  50e7							;    ELSE
    254  50e7		       a9 0d		      lda	#BANK_BOARD	; 2
    255  50e9							;    ENDIF
    256  50e9		       60		      rts		; 6[-2]
    257  50ea
    258  50ea							;------------------------------------------------------------------------------
    259  50ea
      0  50ea					      DEFINE_SUBROUTINE	GetBoardAddressW	;=24[-2](A)
      1  50ea		       00 0a	   BANK_GetBoardAddressW =	_CURRENT_BANK
      2  50ea					      SUBROUTINE
      3  50ea				   GetBoardAddressW
    261  50ea
    262  50ea							; Must share same bank as BoardLineStart tables
    263  50ea
    264  50ea		       b9 01 f0 	      lda	BoardLineStartLO,y	;4
    265  50ed		       85 bc		      sta	Board_AddressW	;3
    266  50ef		       b9 41 f0 	      lda	BoardLineStartHiW,y	;4
    267  50f2		       85 bd		      sta	Board_AddressW+1	;3 WRITE address
    268  50f4							;    IF MULTI_BANK_BOARD = YES
    269  50f4							;		  ldx BoardBank,y		  ;4 switch this on return
    270  50f4							;    ELSE
    271  50f4		       a2 0d		      ldx	#BANK_BOARD	;2
    272  50f6							;    ENDIF
    273  50f6		       60	   QRet       rts		;6
    274  50f7
    275  50f7							;-------------------------------------------------------------------------------
    276  50f7
    277  50f7
    278  50f7							;------------------------------------------------------------------------------
    279  50f7
    280  50f7		       e6 a4	   cannotPush inc	ManPushCounter
    281  50f9		       60		      rts
    282  50fa
    283  50fa
    284  50fa				   AnimationPusher
    285  50fa		       00		      .byte.b	0
    286  50fb		       0c		      .byte.b	ANIMATION_PUSHUP_ID	;1 UP
    287  50fc		       08		      .byte.b	ANIMATION_PUSH_ID	;2 DOWN
    288  50fd		       00		      .byte.b	0
    289  50fe		       08		      .byte.b	ANIMATION_PUSH_ID	;4 LEFT
    290  50ff		       00		      .byte.b	0
    291  5100		       00		      .byte.b	0
    292  5101		       00		      .byte.b	0
    293  5102		       0c		      .byte.b	ANIMATION_PUSHUP_ID	;8 RIGHT
    294  5103		       00		      .byte.b	0
    295  5104		       00		      .byte.b	0
    296  5105		       00		      .byte.b	0
    297  5106		       00		      .byte.b	0
    298  5107		       00		      .byte.b	0
    299  5108		       00		      .byte.b	0
    300  5109		       00		      .byte.b	0
    301  510a
    302  510a		       a9 f0		      lda	#>Animation_PUSHUP
    303  510c
    304  510c				   AnimationPusherAddyLO
    305  510c		       00		      .byte.b	0
    306  510d		       ce		      .byte.b	<Animation_PUSH	;1 UP		   ; or PUSHUP or PUSHUP2
    307  510e		       e6		      .byte.b	<Animation_PUSHDOWN	;2 DOWN
    308  510f		       00		      .byte.b	0
    309  5110		       ce		      .byte.b	<Animation_PUSH	;4 LEFT
    310  5111		       00		      .byte.b	0
    311  5112		       00		      .byte.b	0
    312  5113		       00		      .byte.b	0
    313  5114		       ce		      .byte.b	<Animation_PUSH	;8 RIGHT
    314  5115		       00		      .byte.b	0
    315  5116		       00		      .byte.b	0
    316  5117		       00		      .byte.b	0
    317  5118		       00		      .byte.b	0
    318  5119		       00		      .byte.b	0
    319  511a		       00		      .byte.b	0
    320  511b		       00		      .byte.b	0
    321  511c
    322  511c				   AnimationPusherAddyHI
    323  511c		       00		      .byte.b	0
    324  511d		       f0		      .byte.b	>Animation_PUSHUP	;1 UP
    325  511e		       f0		      .byte.b	>Animation_PUSH	;2 DOWN
    326  511f		       00		      .byte.b	0
    327  5120		       f0		      .byte.b	>Animation_PUSH	;4 LEFT
    328  5121		       00		      .byte.b	0
    329  5122		       00		      .byte.b	0
    330  5123		       00		      .byte.b	0
    331  5124		       f0		      .byte.b	>Animation_PUSH	;8 RIGHT
    332  5125		       00		      .byte.b	0
    333  5126		       00		      .byte.b	0
    334  5127		       00		      .byte.b	0
    335  5128		       00		      .byte.b	0
    336  5129		       00		      .byte.b	0
    337  512a		       00		      .byte.b	0
    338  512b		       00		      .byte.b	0
    339  512c
    340  512c
    341  512c
      0  512c					      DEFINE_SUBROUTINE	PushBox
      1  512c		       00 0a	   BANK_PushBox =	_CURRENT_BANK
      2  512c					      SUBROUTINE
      3  512c				   PushBox
    343  512c
    344  512c							; X = restoration character for square we are moving TO
    345  512c							; so, if X = CHARACTER_TARGET AND we move, THEN we are pushing a box off a target
    346  512c							; A = this bank!
    347  512c
    348  512c		       85 be		      sta	ROM_Bank
    349  512e
    350  512e		       a5 93		      lda	PreviousJoystick
    351  5130		       49 ff		      eor	#$FF
    352  5132		       4a		      lsr
    353  5133		       4a		      lsr
    354  5134		       4a		      lsr
    355  5135		       4a		      lsr
    356  5136		       a8		      tay
    357  5137		       b9 fa f0 	      lda	AnimationPusher,y
    358  513a		       f0 14		      beq	alreadyAnimPush	; well, hopefully
    359  513c		       c5 a6		      cmp	ManAnimationID
    360  513e		       f0 10		      beq	alreadyAnimPush
    361  5140
    362  5140		       85 a6		      sta	ManAnimationID
    363  5142
    364  5142							;		 D7	   right	  P0  D4
    365  5142							;		 D6	   left      P0  D3
    366  5142							;		 D5	   down      P0  D2
    367  5142							;		 D4	   up	     P0  D1
    368  5142
    369  5142
    370  5142		       b9 0c f1 	      lda	AnimationPusherAddyLO,y
    371  5145		       85 9a		      sta	animation
    372  5147		       b9 1c f1 	      lda	AnimationPusherAddyHI,y
    373  514a		       85 9b		      sta	animation+1
    374  514c		       a9 00		      lda	#0
    375  514e		       85 9c		      sta	animation_delay
    376  5150
    377  5150							;LOAD_ANIMATION PUSHUP
    378  5150
    379  5150							;lda #0
    380  5150							;sta idleCount
    381  5150
    382  5150				   alreadyAnimPush
    383  5150
    384  5150
    385  5150		       a5 a4		      lda	ManPushCounter
    386  5152		       c9 06		      cmp	#PUSH_LIMIT
    387  5154		       90 a1		      bcc	cannotPush
    388  5156
    389  5156		       86 dd		      stx	restorationCharacter	; players new location's restore
    390  5158
    391  5158							; Determine if the box is pushable
    392  5158							; we use the joystick to calculate the subsequent square
    393  5158
    394  5158		       a5 93		      lda	PreviousJoystick
    395  515a		       4a		      lsr
    396  515b		       4a		      lsr
    397  515c		       4a		      lsr
    398  515d		       4a		      lsr
    399  515e		       a8		      tay
    400  515f
    401  515f		       b9 31 f3 	      lda	JoyMoveX,y
    402  5162		       f0 05		      beq	x0
    403  5164		       b9 41 f3 	      lda	JoyMoveY,y
    404  5167		       d0 8e		      bne	cannotPush	; avoid diagonal pushes!
    405  5169
    406  5169		       98	   x0	      tya
    407  516a		       48		      pha
    408  516b
    409  516b		       18		      clc
    410  516c		       a5 8a		      lda	POS_Y_NEW
    411  516e		       79 41 f3 	      adc	JoyMoveY,y
    412  5171		       85 88		      sta	POS_Y	; the box's pushed-to square
    413  5173		       a8		      tay
    414  5174		       20 ca f0 	      jsr	GetBoardAddressRW
    415  5177
    416  5177		       68		      pla
    417  5178		       a8		      tay
    418  5179
    419  5179		       18		      clc
    420  517a		       a5 89		      lda	POS_X_NEW
    421  517c		       79 31 f3 	      adc	JoyMoveX,y
    422  517f		       85 87		      sta	POS_X	; the box's pushed-to square
    423  5181		       48		      pha
    424  5182		       a8		      tay
    425  5183
    426  5183							;    IF MULTI_BANK_BOARD = YES
    427  5183							;		  lda RAM_Bank
    428  5183							;    ELSE
    429  5183		       a9 0d		      lda	#BANK_BOARD	; 2
    430  5185							;    ENDIF
    431  5185		       20 14 f8 	      jsr	GetBoardCharacter	;6+20(A)
    432  5188		       68		      pla
    433  5189		       a8		      tay
    434  518a
    435  518a		       a9 02		      lda	#CHARACTER_BOX
    436  518c		       e0 00		      cpx	#CHARACTER_BLANK
    437  518e		       f0 0e		      beq	canPushTarget
    438  5190
    439  5190		       e0 03		      cpx	#CHARACTER_TARGET
    440  5192		       f0 05		      beq	decreaseTargets
    441  5194		       e0 04		      cpx	#CHARACTER_TARGET2
    442  5196		       f0 01		      beq	decreaseTargets
    443  5198		       60		      rts
    444  5199
    445  5199							; Box is now on a target - so decrease the remaining targets
    446  5199
    447  5199		       20 48 fd    decreaseTargets jsr	DeRegisterTarget
    448  519c		       a9 0a		      lda	#CHARACTER_BOX_ON_TARGET
    449  519e		       48	   canPushTarget pha
    450  519f
    451  519f							; If the box *WAS* on a target (restoration character = CHARACTER_TARGET)
    452  519f							; then we increase targets (as there is one more to get)
    453  519f
    454  519f		       a5 dd		      lda	restorationCharacter
    455  51a1		       c9 03		      cmp	#CHARACTER_TARGET
    456  51a3		       d0 03		      bne	notOnTargetAlready
    457  51a5
    458  51a5							; increase the required targets as box is leaving one
    459  51a5
    460  51a5		       20 3e fd 	      jsr	RegisterTarget
    461  51a8
    462  51a8				   notOnTargetAlready
    463  51a8
    464  51a8							; record the box takeback params for the player move to use
    465  51a8
    466  51a8		       86 91		      stx	TB_CHAR
    467  51aa		       a5 87		      lda	POS_X
    468  51ac		       85 8f		      sta	TB_PUSHX
    469  51ae		       a5 88		      lda	POS_Y
    470  51b0		       85 90		      sta	TB_PUSHY
    471  51b2
    472  51b2		       68		      pla		; new char to go on board in box's new position
    473  51b3
    474  51b3
    475  51b3							;  IF MULTI_BANK_BOARD = YES
    476  51b3							;		ldx RAM_Bank			  ; <-- this will never work calling from INITBANK!!!
    477  51b3							;  ELSE
    478  51b3		       a2 0d		      ldx	#BANK_BOARD	; 2
    479  51b5							;  ENDIF
    480  51b5		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)
    481  51b8
    482  51b8		       a5 8c		      lda	POS_VAR	; player's restoration character
    483  51ba		       48		      pha
    484  51bb
    485  51bb							; Before the player moves to the new position, take away the box and replace with the
    486  51bb							; character the box was sitting on (BLANK or TARGET). Then the player moves in "next"
    487  51bb
    488  51bb		       a5 8a		      lda	POS_Y_NEW
    489  51bd		       85 88		      sta	POS_Y
    490  51bf		       a5 89		      lda	POS_X_NEW
    491  51c1		       85 87		      sta	POS_X
    492  51c3		       a5 dd		      lda	restorationCharacter
    493  51c5		       85 8c		      sta	POS_VAR
    494  51c7		       20 e3 f8 	      jsr	PutCharacterAtXY	; put back BOX's restoration character
    495  51ca
    496  51ca		       68		      pla
    497  51cb		       85 8c		      sta	POS_VAR
    498  51cd
    499  51cd							;START_SOUND SOUND_BOX
    500  51cd
    501  51cd							; Note: MovePlayer expects new position to be POS_X_NEW, POS_Y_NEW
    502  51cd							; AND the current man's square to be ManX, ManY
    503  51cd
    504  51cd		       4c 37 f9 	      jmp	MovePlayer	; now there's a gap, player should move in
    505  51d0
    506  51d0
    507  51d0							;------------------------------------------------------------------------------
    508  51d0
    509  51d0							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    510  51d0							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    511  51d0
    512  51d0							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    513  51d0
    514  51d0							; if the creature dies then jump NextObject
    515  51d0
    516  51d0
    517  51d0
    518  51d0							;RDirY 	  .byte -1    ;,0,1,0
    519  51d0							;RDirX 	  .byte 0,1   ;,0,-1
    520  51d0							;DirPushModX	   .byte 0,-1,1,0
    521  51d0							;DirPushModY	   .byte -1,0,0,1
    522  51d0							;Directional	  .byte 1,2,3,0,1,2, 0,0, 11,8,9,10,11,8
    523  51d0
    524  51d0
    525  51d0							;------------------------------------------------------------------------------
    526  51d0
    527  51d0							; the auto-calculation of these was causing DASM to get confused and abort assembling.
    528  51d0							; I don't particularly know why; probably because of the level variable-size array and the values
    529  51d0							; changing from pass to pass. I've put in the hardwired values and it seems to be OK now.
    530  51d0
    531  51d0		       00 00	   MANMODE_STARTUP =	0
    532  51d0		       00 01	   MANMODE_NORMAL =	1
    533  51d0		       00 02	   MANMODE_DEAD =	2
    534  51d0		       00 03	   MANMODE_WAITING =	3
    535  51d0		       00 04	   MANMODE_WAITING2 =	4
    536  51d0		       00 05	   MANMODE_WAITING_NT =	5
    537  51d0		       00 06	   MANMODE_WAITING_NT2 =	6
    538  51d0		       00 07	   MANMODE_NEXTLEVEL =	7
    539  51d0		       00 08	   MANMODE_NEXTLEVEL2 =	8
    540  51d0		       00 09	   MANMODE_SWITCH =	9
    541  51d0		       00 0a	   MANMODE_TURNAROUND =	10
    542  51d0		       00 0b	   MANMODE_TURNAROUND2 =	11
    543  51d0		       00 0c	   MANMODE_SWITCH2 =	12
    544  51d0		       00 0d	   MANMODE_NEXTLEVEL3 =	13
    545  51d0
    546  51d0
    547  51d0
    548  51d0
      0  51d0					      DEFINE_SUBROUTINE	ManProcess
      1  51d0		       00 0a	   BANK_ManProcess =	_CURRENT_BANK
      2  51d0					      SUBROUTINE
      3  51d0				   ManProcess
    550  51d0
    551  51d0							; ManMode tells the player what it is currently doing.  State machine.
    552  51d0
    553  51d0							; Check the switches....
    554  51d0							; RESET to restart this level
    555  51d0							; SELECT to start next level
    556  51d0
    557  51d0		       ad 82 02 	      lda	SWCHB
    558  51d3		       29 03		      and	#3
    559  51d5		       aa		      tax
    560  51d6		       bd f9 f1 	      lda	newMode,x
    561  51d9		       30 02		      bmi	skipModeChange
    562  51db		       85 a1		      sta	ManMode
    563  51dd				   skipModeChange
    564  51dd
    565  51dd		       20 00 f8 	      jsr	DrawTimeFromROM	; Z-flag == 0!
    566  51e0
    567  51e0		       38		      sec
    568  51e1		       a5 b3		      lda	Throttle	;3
    569  51e3		       e9 a0		      sbc	#MAX_THROTTLE	;2
    570  51e5		       90 11		      bcc	DoNothing2	;2/3		 plenty of time left!
    571  51e7		       85 b3		      sta	Throttle	;3 = 10	 save fractional 'left over' bit
    572  51e9
    573  51e9
    574  51e9		       a4 a1		      ldy	ManMode
    575  51eb		       b9 fd f1 	      lda	ManActionLO,y
    576  51ee		       85 db		      sta	actionVector
    577  51f0		       b9 0b f2 	      lda	ManActionHI,y
    578  51f3		       85 dc		      sta	actionVector+1
    579  51f5		       6c db 00 	      jmp	(actionVector)
    580  51f8
    581  51f8				   DoNothing2
    582  51f8		       60		      rts
    583  51f9
    584  51f9		       ff 0c 04 ff newMode    .byte.b	-1, MANMODE_SWITCH2, MANMODE_WAITING2, -1
    585  51fd
    586  51fd				   ManActionLO
    587  51fd		       40		      .byte.b	<manStartup	; 0		 no timer
    588  51fe		       6e		      .byte.b	<normalMan	; 1		 timer
    589  51ff		       00		      .byte.b	<0	; 2		 timer
    590  5200		       69		      .byte.b	<waitingMan	; 3		 timer
    591  5201		       69		      .byte.b	<waitingManPress	; 4		 timer
    592  5202		       69		      .byte.b	<waitingMan	; 5		 no timer
    593  5203		       69		      .byte.b	<waitingManPress	; 6		 no timer
    594  5204		       fa		      .byte.b	<nextLevelMan	; 7		 no timer
    595  5205		       08		      .byte.b	<nextLevelMan2	; 8		 no timer
    596  5206		       24		      .byte.b	<switchLevels	; 9		 no timer
    597  5207		       19		      .byte.b	<TurnAround	; 10
    598  5208		       32		      .byte.b	<TurnAround2	; 10
    599  5209		       01		      .byte.b	<switchLevels2
    600  520a		       1c		      .byte.b	<nextLevelMan3
    601  520b
    602  520b				   ManActionHI
    603  520b		       f2		      .byte.b	>manStartup	; no timer
    604  520c		       f2		      .byte.b	>normalMan	; timer
    605  520d		       00		      .byte.b	>0	; timer
    606  520e		       f2		      .byte.b	>waitingMan	; timer
    607  520f		       f2		      .byte.b	>waitingManPress	; timer
    608  5210		       f2		      .byte.b	>waitingMan	; no timer
    609  5211		       f2		      .byte.b	>waitingManPress	; no timer
    610  5212		       fc		      .byte.b	>nextLevelMan	; no timer
    611  5213		       fd		      .byte.b	>nextLevelMan2	; no timer
    612  5214		       fd		      .byte.b	>switchLevels	;9  no timer
    613  5215		       f2		      .byte.b	>TurnAround	; 10
    614  5216		       f2		      .byte.b	>TurnAround2	; 10
    615  5217		       fd		      .byte.b	>switchLevels2
    616  5218		       fd		      .byte.b	>nextLevelMan3
    617  5219
    618  5219
      0  5219					      DEFINE_SUBROUTINE	TurnAround
      1  5219		       00 0a	   BANK_TurnAround =	_CURRENT_BANK
      2  5219					      SUBROUTINE
      3  5219				   TurnAround
    620  5219
      0  5219					      LOAD_ANIMATION	TURNAROUND
      1  5219		       a9 ba		      lda	#<Animation_TURNAROUND
      2  521b		       85 9a		      sta	animation
      3  521d		       a9 f0		      lda	#>Animation_TURNAROUND
      4  521f		       85 9b		      sta	animation+1
      5  5221		       a9 00		      lda	#0
      6  5223		       85 9c		      sta	animation_delay
      7  5225		       a9 14		      lda	#ANIMATION_TURNAROUND_ID
      8  5227		       85 a6		      sta	ManAnimationID
    622  5229
    623  5229		       a5 a2		      lda	ManLastDirection
    624  522b		       85 a3		      sta	ManTurnStart
    625  522d
    626  522d		       a9 0b		      lda	#MANMODE_TURNAROUND2
    627  522f		       85 a1		      sta	ManMode
    628  5231		       60		      rts
    629  5232
      0  5232					      DEFINE_SUBROUTINE	TurnAround2
      1  5232		       00 0a	   BANK_TurnAround2 =	_CURRENT_BANK
      2  5232					      SUBROUTINE
      3  5232				   TurnAround2
    631  5232
    632  5232		       a5 a3		      lda	ManTurnStart
    633  5234		       c5 a2		      cmp	ManLastDirection
    634  5236		       f0 07		      beq	notTurnedYet
    635  5238
    636  5238		       a9 01		      lda	#MANMODE_NORMAL
    637  523a		       85 a1		      sta	ManMode
    638  523c		       4c 6e f2 	      jmp	normalMan
    639  523f
    640  523f
    641  523f		       60	   notTurnedYet rts
    642  5240
    643  5240
    644  5240							;------------------------------------------------------------------------------
      0  5240					      DEFINE_SUBROUTINE	manStartup
      1  5240		       00 0a	   BANK_manStartup =	_CURRENT_BANK
      2  5240					      SUBROUTINE
      3  5240				   manStartup
    646  5240
    647  5240					      IF	WAIT_FOR_INITIAL_DRAW
    648  5240							; Delay turning on the visible screen until the background has completed drawing.
    649  5240							; This is simple - is there anything still in the draw stack?
    650  5240		       a5 81		      lda	DrawStackPointer
    651  5242		       10 04		      bpl	midDraw
    652  5244		       a9 00		      lda	#0
    653  5246		       85 ae		      sta	blankState
    654  5248				   midDraw
    655  5248					      ENDIF
    656  5248
    657  5248		       a5 9d		      lda	ManX
    658  524a		       85 89		      sta	POS_X_NEW
    659  524c		       a5 9e		      lda	ManY
    660  524e		       85 8a		      sta	POS_Y_NEW
    661  5250
    662  5250		       a9 01		      lda	#MANMODE_NORMAL
    663  5252		       85 a1		      sta	ManMode
    664  5254
    665  5254		       a9 00		      lda	#0
    666  5256		       85 a8		      sta	idleCount
    667  5258
      0  5258					      LOAD_ANIMATION	IDLE
      1  5258		       a9 4a		      lda	#<Animation_IDLE
      2  525a		       85 9a		      sta	animation
      3  525c		       a9 f0		      lda	#>Animation_IDLE
      4  525e		       85 9b		      sta	animation+1
      5  5260		       a9 00		      lda	#0
      6  5262		       85 9c		      sta	animation_delay
      7  5264		       a9 02		      lda	#ANIMATION_IDLE_ID
      8  5266		       85 a6		      sta	ManAnimationID
    669  5268
    670  5268				   RTS_CF
    671  5268		       60		      rts
    672  5269
    673  5269							;------------------------------------------------------------------------------
    674  5269
    675  5269				   waitingMan
    676  5269				   waitingManPress
    677  5269
    678  5269							;		  lda #50
    679  5269							;		  sta ColourTimer
    680  5269
    681  5269							; RESET gets here
    682  5269
    683  5269							;lda NextLevelTrigger
    684  5269							;ora #BIT_NEXTLIFE
    685  5269
    686  5269		       a9 00		      lda	#0
    687  526b		       85 c1		      sta	NextLevelTrigger
    688  526d		       60		      rts
    689  526e
    690  526e
    691  526e							;------------------------------------------------------------------------------
    692  526e							; Normal man state
    693  526e
      0  526e					      DEFINE_SUBROUTINE	normalMan
      1  526e		       00 0a	   BANK_normalMan =	_CURRENT_BANK
      2  526e					      SUBROUTINE
      3  526e				   normalMan
    695  526e
    696  526e							; Calling code uses 'POS_X_NEW' and 'POS_Y_NEW' as new player position, so these must be set
    697  526e							; before exiting via (for example) look-around option :)
    698  526e
    699  526e		       a5 9d		      lda	ManX
    700  5270		       85 89		      sta	POS_X_NEW
    701  5272		       a5 9e		      lda	ManY
    702  5274		       85 8a		      sta	POS_Y_NEW
    703  5276
    704  5276							;------------------------------------------------------------------------------
    705  5276							; Take-back is a press/release of the button, with the press being limited in duratino
    706  5276							; to allow the action to be "cancelled". Meanwhile, a button press + direction triggers
    707  5276							; "look-around mode"
    708  5276
    709  5276		       a5 cb		      lda	FadeComplete
    710  5278		       d0 3d		      bne	noLook
    711  527a		       a5 4c		      lda	INPT4
    712  527c		       30 39		      bmi	noLook	; button?
    713  527e
    714  527e							; button pressed, so in looking-around mode
    715  527e
    716  527e		       a5 a5		      lda	LookingAround
    717  5280		       30 04		      bmi	LookAround
    718  5282		       a2 ff		      ldx	#$FF
    719  5284		       86 a5		      stx	LookingAround
    720  5286				   LookAround
    721  5286
    722  5286							; Use the joystick as a window-scroller to change the viewport
    723  5286
    724  5286		       ad 80 02 	      lda	SWCHA	;BufferedJoystick
    725  5289		       4a		      lsr
    726  528a		       4a		      lsr
    727  528b		       4a		      lsr
    728  528c		       4a		      lsr
    729  528d		       a8		      tay
    730  528e
    731  528e							;lda #-1
    732  528e							;sta BufferedJoystick
    733  528e
    734  528e		       b9 31 f3 	      lda	JoyMoveX,y
    735  5291		       19 41 f3 	      ora	JoyMoveY,y
    736  5294		       f0 20		      beq	AbandonY
    737  5296
    738  5296		       a9 fe		      lda	#$FE
    739  5298		       85 a5		      sta	LookingAround
    740  529a		       a9 a1		      lda	#MAX_THROTTLE+1
    741  529c		       85 b3		      sta	Throttle	; IMMEDIATE reaction to any joystick!
    742  529e
    743  529e		       b9 31 f3 	      lda	JoyMoveX,y
    744  52a1							;asl
    745  52a1		       18		      clc
    746  52a2		       65 97		      adc	BoardScrollX
    747  52a4		       c5 94		      cmp	BoardEdge_Right
    748  52a6		       b0 02		      bcs	AbandonX
    749  52a8		       85 97		      sta	BoardScrollX
    750  52aa
    751  52aa				   AbandonX
    752  52aa							;lda JoyMoveX,y
    753  52aa							;bne AbandonY			  ; don't allow diagonals!
    754  52aa
    755  52aa		       b9 41 f3 	      lda	JoyMoveY,y
    756  52ad							;asl
    757  52ad		       18		      clc
    758  52ae		       65 96		      adc	BoardScrollY
    759  52b0		       c5 95		      cmp	BoardEdge_Bottom
    760  52b2		       b0 02		      bcs	AbandonY
    761  52b4		       85 96		      sta	BoardScrollY
    762  52b6
    763  52b6		       60	   AbandonY   rts
    764  52b7
    765  52b7		       a2 00	   noLook     ldx	#0
    766  52b9		       a5 a5		      lda	LookingAround
    767  52bb		       c9 ff		      cmp	#$FF
    768  52bd		       86 a5		      stx	LookingAround
    769  52bf		       d0 03		      bne	bProcComp	; $FE means there was a lookaround, so skip
    770  52c1
    771  52c1							; button was presssed and now released and we didn't actually look around
    772  52c1							; so we do a take-back
    773  52c1
    774  52c1		       4c 17 fa 	      jmp	takebackRestoreEarlierPosition	;.. and rts
    775  52c4							;rts
    776  52c4
    777  52c4				   bProcComp
    778  52c4							;------------------------------------------------------------------------------
    779  52c4
    780  52c4		       a9 02		      lda	#ANIMATION_IDLE_ID
    781  52c6		       c5 a6		      cmp	ManAnimationID
    782  52c8		       f0 20		      beq	alreadyIdling
    783  52ca
    784  52ca		       a5 a4		      lda	ManPushCounter
    785  52cc		       d0 1c		      bne	alreadyIdling
    786  52ce
    787  52ce		       e6 a8		      inc	idleCount
    788  52d0		       a4 a8		      ldy	idleCount
    789  52d2		       c0 02		      cpy	#2
    790  52d4		       90 14		      bcc	alreadyIdling
    791  52d6
      0  52d6					      LOAD_ANIMATION	IDLE
      1  52d6		       a9 4a		      lda	#<Animation_IDLE
      2  52d8		       85 9a		      sta	animation
      3  52da		       a9 f0		      lda	#>Animation_IDLE
      4  52dc		       85 9b		      sta	animation+1
      5  52de		       a9 00		      lda	#0
      6  52e0		       85 9c		      sta	animation_delay
      7  52e2		       a9 02		      lda	#ANIMATION_IDLE_ID
      8  52e4		       85 a6		      sta	ManAnimationID
    793  52e6
    794  52e6		       a9 00		      lda	#0
    795  52e8		       85 a8		      sta	idleCount
    796  52ea				   alreadyIdling
    797  52ea
    798  52ea		       a5 a2		      lda	ManLastDirection
    799  52ec		       29 07		      and	#DIRECTION_BITS
    800  52ee		       a8		      tay
    801  52ef
    802  52ef		       a5 92		      lda	BufferedJoystick	; joystick
    803  52f1		       85 93		      sta	PreviousJoystick
    804  52f3							;and BufferedJoystick+1
    805  52f3
    806  52f3		       a2 00		      ldx	#0
    807  52f5		       0a	   .loopDirs  asl
    808  52f6		       90 06		      bcc	.dirFound
    809  52f8		       88		      dey
    810  52f9		       e8		      inx
    811  52fa		       e0 04		      cpx	#4
    812  52fc		       d0 f7		      bne	.loopDirs
    813  52fe
    814  52fe							; no direction!
    815  52fe
    816  52fe							;inc BGColour
    817  52fe
    818  52fe
    819  52fe							;lda #MAX_THROTTLE+1
    820  52fe							;sta Throttle		     ; IMMEDIATE reaction to any joystick!
    821  52fe
    822  52fe				   .dirFound
    823  52fe
    824  52fe		       a9 ff		      lda	#-1
    825  5300		       85 92		      sta	BufferedJoystick
    826  5302
    827  5302		       bd 58 f3 	      lda	anim_direction,x
    828  5305		       30 0d		      bmi	dontChange
    829  5307		       45 a2		      eor	ManLastDirection
    830  5309		       29 08		      and	#%1000
    831  530b		       f0 07		      beq	dontChange
    832  530d
    833  530d							; at this point we want to activate the stand/turn animation before continuing
    834  530d
    835  530d		       a9 0a		      lda	#MANMODE_TURNAROUND
    836  530f		       85 a1		      sta	ManMode
    837  5311		       4c 19 f2 	      jmp	TurnAround
    838  5314
    839  5314
    840  5314
    841  5314
    842  5314							;bne noMovement ;kipMove
    843  5314				   dontChange
    844  5314
    845  5314
    846  5314
    847  5314		       18		      clc
    848  5315		       a5 89		      lda	POS_X_NEW
    849  5317		       7d 53 f3 	      adc	JoyDirX,x
    850  531a		       85 89		      sta	POS_X_NEW
    851  531c
    852  531c		       18		      clc
    853  531d		       a5 8a		      lda	POS_Y_NEW
    854  531f		       7d 51 f3 	      adc	JoyDirY,x
    855  5322		       85 8a		      sta	POS_Y_NEW
    856  5324
    857  5324
    858  5324		       98	   skipMove   tya
    859  5325		       f0 09		      beq	noMovement	; animation OK
    860  5327
    861  5327		       8a		      txa
    862  5328		       45 a2		      eor	ManLastDirection
    863  532a		       29 07		      and	#DIRECTION_BITS
    864  532c		       45 a2		      eor	ManLastDirection
    865  532e		       85 a2		      sta	ManLastDirection
    866  5330
    867  5330				   noMovement
    868  5330
    869  5330
    870  5330		       60	   DFS_rts    rts
    871  5331
    872  5331
    873  5331							;			RLDU RLD  RL U RL   R DU R D  R  U R	 LDU  LD   L U	L     DU   D	 U
    874  5331							;			0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    875  5331		       00 00 00 00*JoyMoveX   .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 0, 0, 0
    876  5341		       00 00 00 00*JoyMoveY   .byte.b	0, 0, 0, 0, 0, 1, -1, 0, 0, 1, -1, 0, 0, 1, -1, 0
    877  5351
    878  5351				   JoyDirY
    879  5351		       00 00		      .byte.b	0,0	;,1,-1,0
    880  5353				   JoyDirX
    881  5353		       01 ff 00 00*	      .byte.b	1,-1,0,0,0
    882  5358
    883  5358							;Data Bit  Direction Player
    884  5358							;		 D7	   right	  P0  D4
    885  5358							;		 D6	   left      P0  D3
    886  5358							;		 D5	   down      P0  D2
    887  5358							;		 D4	   up	     P0  D1
    888  5358							;     A "0" in a data bit indicates the joystick has been moved
    889  5358							;     to close that switch.  All "1's" in a player's nibble
    890  5358							;     indicates that joystick is not moving.
    891  5358
    892  5358							;0  0000 x
    893  5358							;1  0001 x
    894  5358							;2  0010 x
    895  5358							;3  0011 x
    896  5358							;4  0100 x
    897  5358							;5  0101 right down
    898  5358							;6  0110 right up
    899  5358							;7  0111 right
    900  5358							;8  1000 x
    901  5358							;9  1001 left down
    902  5358							;10  1010 left up
    903  5358							;11  1011 left
    904  5358							;12  1100 x
    905  5358							;13  1101 down
    906  5358							;14  1110 up
    907  5358							;15  1111 none
    908  5358
    909  5358		       00 08 80 80*anim_direction .byte.b	0,%1000,128,128,128
    910  535d
    911  535d							;------------------------------------------------------------------------------
    912  535d
    913  535d
      0  535d					      DEFINE_SUBROUTINE	DrawFullScreen	; @31✅
      1  535d		       00 0a	   BANK_DrawFullScreen =	_CURRENT_BANK
      2  535d					      SUBROUTINE
      3  535d				   DrawFullScreen
    915  535d
    916  535d		       ad 84 02 	      lda	INTIM	; 4
    917  5360		       c9 29		      cmp	#SEGTIME_BDF	; 2
    918  5362		       90 cc		      bcc	DFS_rts	; 2/3 ==> [31]+(9)+6rts = 46✅ on abort
    919  5364
    920  5364		       a9 f4		      lda	#>( DrawFlag + RAM_WRITE )	; 2
    921  5366		       85 dc		      sta	BDF_DrawFlagAddress+1	; 3
    922  5368		       85 de		      sta	BDF_DrawFlagAddress2+1	; 3 = 8✅
    923  536a
    924  536a		       ba		      tsx		; 2
    925  536b		       86 e5		      stx	DHS_Stack	; 3
    926  536d
    927  536d		       e6 86		      inc	ScreenDrawPhase	; 5
    928  536f
    929  536f		       18		      clc		; 2	     required clear for DrawScreenRowPreparation
    930  5370		       a2 08		      ldx	#SCREEN_LINES	; 2
    931  5372		       8a		      txa		; 2 = 24✅
    932  5373
    933  5373							; fall through
    934  5373
    935  5373							;------------------------------------------------------------------------------
    936  5373
    937  5373							; @311✅ (from loop)
    938  5373							; @24✅ (fall through)
    939  5373
    940  5373							; 8 lines x 311 + (24)
    941  5373							; = 2512
    942  5373							; = 39 :)
    943  5373
      0  5373					      DEFINE_SUBROUTINE	DrawScreenRowPreparation
      1  5373		       00 0a	   BANK_DrawScreenRowPreparation =	_CURRENT_BANK
      2  5373					      SUBROUTINE
      3  5373				   DrawScreenRowPreparation
    945  5373
    946  5373							;clc
    947  5373		       ca		      dex		; 2
    948  5374		       86 e4		      stx	DHS_Line	; 3
    949  5376		       65 96		      adc	BoardScrollY	; 3	     the Y offset of screen into board
    950  5378		       a8		      tay		; 2 = 10✅
    951  5379
    952  5379							;clc
    953  5379		       b9 00 f0 	      lda	BoardLineStartLO-1,y	; 4	     Y is one too big!
    954  537c		       65 97		      adc	BoardScrollX	; 3	     the X offset of screen into board
    955  537e		       85 df		      sta	BDF_BoardAddress	; 3
    956  5380		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    957  5382		       85 e1		      sta	BDF_BoardAddress2	; 3 = 15✅
    958  5384
    959  5384		       b9 20 f0 	      lda	BoardLineStartHiR-1,y	; 4	     a board line *WILL NOT CROSS* page boundary
    960  5387		       85 e0		      sta	BDF_BoardAddress+1	; 3
    961  5389		       85 e2		      sta	BDF_BoardAddress2+1	; 3 = 10 @35✅
    962  538b
    963  538b		       bd c2 f0 	      lda	DrawLineStartLO,x	; 4
    964  538e		       85 db		      sta	BDF_DrawFlagAddress	; 3
    965  5390		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    966  5392		       85 dd		      sta	BDF_DrawFlagAddress2	; 3 = 12✅
    967  5394
    968  5394							;    IF MULTI_BANK_BOARD = YES
    969  5394							;		  lda BoardBank-1,y		  ; 4
    970  5394							;		  sta BDF_BoardBank		  ; 3
    971  5394							;    ENDIF
    972  5394		       a0 04		      ldy	#SCREEN_WIDTH/2-1	; 2
    973  5396		       4c 8b fb 	      jmp	CopyRow2	; 3 = 12 @59✅
    974  5399
    975  5399							;------------------------------------------------------------------------------
    976  5399
      0  5399					      DEFINE_SUBROUTINE	EndOfLevel
      1  5399		       00 0a	   BANK_EndOfLevel =	_CURRENT_BANK
      2  5399					      SUBROUTINE
      3  5399				   EndOfLevel
    978  5399
    979  5399		       a9 0a		      lda	#10
    980  539b		       85 a9		      sta	DelayEndOfLevel
    981  539d
    982  539d		       a6 80		      ldx	Platform
    983  539f		       bd bd f3 	      lda	FlashColour,x	;+4,x
    984  53a2		       85 b0		      sta	BGColour	;ColourFlash		      ; green
    985  53a4		       a9 08		      lda	#8
    986  53a6		       85 c0		      sta	ColourTimer
    987  53a8
    988  53a8
      0  53a8					      LOAD_ANIMATION	WIN
      1  53a8		       a9 24		      lda	#<Animation_WIN
      2  53aa		       85 9a		      sta	animation
      3  53ac		       a9 f0		      lda	#>Animation_WIN
      4  53ae		       85 9b		      sta	animation+1
      5  53b0		       a9 00		      lda	#0
      6  53b2		       85 9c		      sta	animation_delay
      7  53b4		       a9 04		      lda	#ANIMATION_WIN_ID
      8  53b6		       85 a6		      sta	ManAnimationID
    990  53b8
    991  53b8		       a9 08		      lda	#MANMODE_NEXTLEVEL2
    992  53ba		       85 a1		      sta	ManMode
    993  53bc		       60		      rts
    994  53bd
    995  53bd
    996  53bd		       c4 c4 54 54 FlashColour .byte.b	$C4, $C4, $54, $54
    997  53c1
    998  53c1
      0  53c1					      DEFINE_SUBROUTINE	IMC
      1  53c1		       00 0a	   BANK_IMC   =	_CURRENT_BANK
      2  53c1					      SUBROUTINE
      3  53c1				   IMC
   1000  53c1
   1001  53c1		       18		      clc
   1002  53c2		       a5 b7		      lda	takebackIndex
   1003  53c4		       69 01		      adc	#1
   1004  53c6		       29 3f		      and	#TAKEBACK_MASK
   1005  53c8		       85 b7		      sta	takebackIndex
   1006  53ca		       c5 b8		      cmp	takebackBaseIndex
   1007  53cc		       d0 06		      bne	baseOK
   1008  53ce		       69 00		      adc	#0
   1009  53d0		       29 3f		      and	#TAKEBACK_MASK
   1010  53d2		       85 b8		      sta	takebackBaseIndex
   1011  53d4				   baseOK
   1012  53d4
   1013  53d4		       f8		      sed
   1014  53d5		       18		      clc
   1015  53d6		       a5 b5		      lda	BCD_moveCounter
   1016  53d8		       69 01		      adc	#1
   1017  53da		       85 b5		      sta	BCD_moveCounter
   1018  53dc		       a5 b6		      lda	BCD_moveCounter+1
   1019  53de		       69 00		      adc	#0
   1020  53e0		       85 b6		      sta	BCD_moveCounter+1
   1021  53e2		       d8		      cld
   1022  53e3
   1023  53e3		       60		      rts
   1024  53e4
   1025  53e4							;------------------------------------------------------------------------------
   1026  53e4
      0  53e4					      DEFINE_SUBROUTINE	VectorProcess	;=19 + 13, = 31✅ minimum
      1  53e4		       00 0a	   BANK_VectorProcess =	_CURRENT_BANK
      2  53e4					      SUBROUTINE
      3  53e4				   VectorProcess
   1028  53e4
   1029  53e4		       bd f2 f3 	      lda	OSPointerHI,x	; 4
   1030  53e7		       85 dc		      sta	POS_Vector+1	; 3
   1031  53e9		       bd f1 f3 	      lda	OSPointerLO,x	; 4
   1032  53ec		       85 db		      sta	POS_Vector	; 3
   1033  53ee
   1034  53ee		       6c db 00 	      jmp	(POS_Vector)	; 5 = 19	  vector to processor for particular object type
   1035  53f1
   1036  53f1							; earliest abort from process = +13
   1037  53f1
   1038  53f1							;		 NOTE: Bank is either INITBANK or FIXED.
   1039  53f1							;------------------------------------------------------------------------------
   1040  53f1
   1041  53f1
   1042  53f1				   OBJTYPE    SET	0
   1043  53f1					      MAC	define
   1044  53f1				   TYPE_{1}   =	OBJTYPE
   1045  53f1				   OBJTYPE    .SET	OBJTYPE + 1
   1046  53f1					      ENDM
   1047  53f1
   1048  53f1							; If adding/removing types, the following must also be updated...
   1049  53f1							;   InitialFace[...]		     in UnpackLevel.asm
   1050  53f1							;   BaseTypeCharacter[...]	     in BANK_FIXED.asm
   1051  53f1							;   BaseTypeCharacterFalling[...]   in BANK_FIXED.asm
   1052  53f1							;   OSPointerLO[...]		     in BANK_INITBANK.asm
   1053  53f1							;   OSPointerHI[...]		     in BANK_INITBANK.asm
   1054  53f1							;   CharReplacement[...]	     in BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1055  53f1							;   Sortable[...]		     in BANK_FIXED.asm
   1056  53f1
   1057  53f1
      0  53f1					      DEFINE	MAN
      1  53f1		       00 00	   TYPE_MAN   =	OBJTYPE
      2  53f1				   OBJTYPE    .SET	OBJTYPE + 1
   1059  53f1							;DEFINE CIRCLE
   1060  53f1							;DEFINE CIRCLE_HELPER
   1061  53f1							;DEFINE CIRCLE_DRAWER
   1062  53f1
      0  53f1					      DEFINE	MAXIMUM
      1  53f1		       00 01	   TYPE_MAXIMUM =	OBJTYPE
      2  53f1				   OBJTYPE    .SET	OBJTYPE + 1
   1064  53f1
   1065  53f1
      0  53f1					      DEFINE_SUBROUTINE	OSPointerLO
      1  53f1		       00 0a	   BANK_OSPointerLO =	_CURRENT_BANK
      2  53f1					      SUBROUTINE
      3  53f1				   OSPointerLO
   1067  53f1		       a9		      .byte.b	<PROCESS_MAN
   1068  53f2							;.byte <PROCESS_CIRCLE
   1069  53f2							;.byte <PROCESS_CIRCLE_HELPER
   1070  53f2
   1071  53f2				  -	      IF	* - OSPointerLO < TYPE_MAXIMUM-4
   1072  53f2				  -	      ECHO	"ERROR: Missing entry in OSPointerLO table!"
   1073  53f2				  -	      ERR
   1074  53f2					      ENDIF
   1075  53f2
   1076  53f2
      0  53f2					      DEFINE_SUBROUTINE	OSPointerHI
      1  53f2		       00 0a	   BANK_OSPointerHI =	_CURRENT_BANK
      2  53f2					      SUBROUTINE
      3  53f2				   OSPointerHI
   1078  53f2		       f8		      .byte.b	>PROCESS_MAN
   1079  53f3							;.byte >PROCESS_CIRCLE
   1080  53f3							;.byte >PROCESS_CIRCLE_HELPER
   1081  53f3
   1082  53f3				  -	      IF	* - OSPointerHI < TYPE_MAXIMUM-4
   1083  53f3				  -	      ECHO	"ERROR: Missing entry in OSPointerHI table!"
   1084  53f3				  -	      ERR
   1085  53f3					      ENDIF
   1086  53f3
   1087  53f3							;------------------------------------------------------------------------------
   1088  53f3
      0  53f3					      DEFINE_SUBROUTINE	MoveVecLO	; [character type]
      1  53f3		       00 0a	   BANK_MoveVecLO =	_CURRENT_BANK
      2  53f3					      SUBROUTINE
      3  53f3				   MoveVecLO
   1090  53f3
   1091  53f3		       92		      .byte.b	<MOVE_BLANK
   1092  53f4		       92		      .byte.b	<MOVE_SOIL
   1093  53f5		       05		      .byte.b	<MOVE_BOX
   1094  53f6		       92		      .byte.b	<MOVE_TARGET
   1095  53f7		       92		      .byte.b	<MOVE_TARGET
   1096  53f8		       f0		      .byte.b	<MOVE_GENERIC	;man occupied
   1097  53f9		       f0		      .byte.b	<MOVE_GENERIC	;steel
   1098  53fa		       f0		      .byte.b	<MOVE_GENERIC	;rivet
   1099  53fb		       f0		      .byte.b	<MOVE_GENERIC	;wall
   1100  53fc		       f0		      .byte.b	<MOVE_GENERIC	;stripe
   1101  53fd		       0e		      .byte.b	<MOVE_BOX_ON_TARGET	;box on target
   1102  53fe							;	  .byte <MOVE_BOX_ON_TARGET ;box on target
   1103  53fe		       f0		      .byte.b	<MOVE_GENERIC	;nogo
   1104  53ff		       92		      .byte.b	<MOVE_TARGET	;1
   1105  5400		       92		      .byte.b	<MOVE_TARGET	;3
   1106  5401		       92		      .byte.b	<MOVE_TARGET	;5
   1107  5402		       92		      .byte.b	<MOVE_TARGET	;7
   1108  5403
   1109  5403				  -	      if	DIGITS
   1110  5403				  -	      REPEAT	10	; DIGITS 0-9
   1111  5403				  -	      .byte	<MOVE_BLANK
   1112  5403				  -	      REPEND
   1113  5403					      endif
   1114  5403
   1115  5403				  -	      IF	* - MoveVecLO != CHARACTER_MAXIMUM
   1116  5403				  -	      ECHO	"ERROR: Incorrect number of entries in MoveVecLO table!"
   1117  5403				  -	      ERR
   1118  5403					      ENDIF
   1119  5403
   1120  5403
      0  5403					      DEFINE_SUBROUTINE	MoveVecHI	;[character type]
      1  5403		       00 0a	   BANK_MoveVecHI =	_CURRENT_BANK
      2  5403					      SUBROUTINE
      3  5403				   MoveVecHI
   1122  5403
   1123  5403		       f9		      .byte.b	>MOVE_BLANK
   1124  5404		       f9		      .byte.b	>MOVE_SOIL
   1125  5405		       fa		      .byte.b	>MOVE_BOX
   1126  5406		       f9		      .byte.b	>MOVE_TARGET
   1127  5407		       f9		      .byte.b	>MOVE_TARGET
   1128  5408		       f9		      .byte.b	>MOVE_GENERIC	;man occupied
   1129  5409		       f9		      .byte.b	>MOVE_GENERIC	;steel
   1130  540a		       f9		      .byte.b	>MOVE_GENERIC	;rivet
   1131  540b		       f9		      .byte.b	>MOVE_GENERIC	;wall
   1132  540c		       f9		      .byte.b	>MOVE_GENERIC	;stripe
   1133  540d		       fa		      .byte.b	>MOVE_BOX_ON_TARGET	;box on target
   1134  540e							;	  .byte >MOVE_BOX_ON_TARGET ;box on target
   1135  540e		       f9		      .byte.b	>MOVE_GENERIC	;nogo
   1136  540f		       f9		      .byte.b	>MOVE_TARGET	;1
   1137  5410		       f9		      .byte.b	>MOVE_TARGET	;3
   1138  5411		       f9		      .byte.b	>MOVE_TARGET	;5
   1139  5412		       f9		      .byte.b	>MOVE_TARGET	; 7
   1140  5413
   1141  5413				  -	      if	DIGITS
   1142  5413				  -	      REPEAT	10	; DIGITS 0-9
   1143  5413				  -	      .byte	>MOVE_BLANK
   1144  5413				  -	      REPEND
   1145  5413					      endif
   1146  5413
   1147  5413				  -	      IF	* - MoveVecHI != CHARACTER_MAXIMUM
   1148  5413				  -	      ECHO	"ERROR: Incorrect number of entries in MoveVecHI table!"
   1149  5413				  -	      ERR
   1150  5413					      ENDIF
   1151  5413
   1152  5413							;------------------------------------------------------------------------------
   1153  5413
      0  5413					      DEFINE_SUBROUTINE	SoundFX
      1  5413		       00 0a	   BANK_SoundFX =	_CURRENT_BANK
      2  5413					      SUBROUTINE
      3  5413				   SoundFX
------- FILE sound/intro1_player.asm LEVEL 3 PASS 3
      0  5413					      include	"sound/intro1_player.asm"
      1  5413							; TIATracker music player
      2  5413							; Copyright 2016 Andre "Kylearan" Wichmann
      3  5413							; Website: https://bitbucket.org/kylearan/tiatracker
      4  5413							; Email: andre.wichmann@gmx.de
      5  5413							;
      6  5413							; Licensed under the Apache License, Version 2.0 (the "License");
      7  5413							; you may not use this file except in compliance with the License.
      8  5413							; You may obtain a copy of the License at
      9  5413							;
     10  5413							;   http://www.apache.org/licenses/LICENSE-2.0
     11  5413							;
     12  5413							; Unless required by applicable law or agreed to in writing, software
     13  5413							; distributed under the License is distributed on an "AS IS" BASIS,
     14  5413							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  5413							; See the License for the specific language governing permissions and
     16  5413							; limitations under the License.
     17  5413
     18  5413							; Song author:
     19  5413							; Song name:
     20  5413
     21  5413							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  5413
     23  5413							; =====================================================================
     24  5413							; TIATracker Player
     25  5413							; =====================================================================
     26  5413				   tt_PlayerStart
     27  5413
     28  5413							; PLANNED PLAYER VARIANTS:
     29  5413							; - RAM, speed, player ROM: c0/c1 patterns have same length
     30  5413							; - RAM: Pack 2 values (out of cur_pat_index, cur_note_index, envelope_index)
     31  5413							;	 into one and use lsr/asl to unpack them, allowing only ranges of
     32  5413							;	 16/16 or 32/8 for them, depending on number of patterns, max
     33  5413							;	 pattern size and max ADSR size
     34  5413							; - ROM: Check if tt_SequenceTable can hold ptrs directly without indexing
     35  5413							;	 tt_PatternPtrLo/Hi. Can be smaller if not many patterns get repeated
     36  5413							;	 (saves table and decode routine)
     37  5413							; - Speed: Inline tt_CalcInsIndex
     38  5413							; - Speed: Store ptr to current note in RAM instead of reconstructing it?
     39  5413							;	 Might also save the need for cur_note_index
     40  5413
     41  5413
     42  5413							; ---------------------------------------------------------------------
     43  5413							; Helper macro: Retrieves current note. May advance pattern if needed.
     44  5413							; Becomes a subroutine if TT_USE_OVERLAY is used.
     45  5413							; ---------------------------------------------------------------------
     46  5413					      MAC	tt_fetch_current_note
     47  5413							; construct ptr to pattern
     48  5413				   .constructPatPtr
     49  5413					      ldy	tt_cur_pat_index_c0,x	; get current pattern (index into tt_SequenceTable)
     50  5413					      lda	tt_SequenceTable,y
     51  5413					      IF	TT_USE_GOTO = 1
     52  5413					      bpl	.noPatternGoto
     53  5413					      and	#%01111111	; mask out goto bit to get pattern number
     54  5413					      sta	tt_cur_pat_index_c0,x	; store goto'ed pattern index
     55  5413					      bpl	.constructPatPtr	; unconditional
     56  5413				   .noPatternGoto
     57  5413					      ENDIF
     58  5413					      tay
     59  5413					      lda	tt_PatternPtrLo,y
     60  5413					      sta	tt_ptr
     61  5413					      lda	tt_PatternPtrHi,y
     62  5413					      sta	tt_ptr+1
     63  5413							; get new note
     64  5413					      IF	TT_USE_OVERLAY = 0
     65  5413					      ldy	tt_cur_note_index_c0,x
     66  5413					      ELSE
     67  5413							; If the V flag is set and if the new note is an instrument,
     68  5413							; it means it got pre-fetched by an overlay percussion, it has
     69  5413							; to remain in sustain.
     70  5413					      clv
     71  5413							; check if note had been pre-fetched by overlay perc already
     72  5413					      lda	tt_cur_note_index_c0,x
     73  5413					      bpl	.notPrefetched
     74  5413							; If so, remove flag
     75  5413					      and	#%01111111
     76  5413					      sta	tt_cur_note_index_c0,x
     77  5413							; Set V flag for later
     78  5413					      bit	tt_Bit6Set
     79  5413				   .notPrefetched
     80  5413					      tay
     81  5413					      ENDIF
     82  5413					      lda	(tt_ptr),y
     83  5413							; pre-process new note
     84  5413							; 7..5: instrument (1..7), 4..0 (0..31): frequency
     85  5413							; 0/0: End of pattern
     86  5413					      bne	.noEndOfPattern
     87  5413							; End of pattern: Advance to next pattern
     88  5413					      sta	tt_cur_note_index_c0,x	; a is 0
     89  5413					      inc	tt_cur_pat_index_c0,x
     90  5413					      bne	.constructPatPtr	; unconditional
     91  5413				   .noEndOfPattern
     92  5413					      ENDM
     93  5413
     94  5413
     95  5413							; ---------------------------------------------------------------------
     96  5413							; Music player entry. Call once per frame.
     97  5413							; ---------------------------------------------------------------------
     98  5413				   tt_Player  SUBROUTINE
     99  5413							; ==================== Sequencer ====================
    100  5413							; Decrease speed timer
    101  5413		       c6 d0		      dec	tt_timer
    102  5415		       10 6e		      bpl	.noNewNote
    103  5417
    104  5417							; Timer ran out: Do sequencer
    105  5417							; Advance to next note
    106  5417		       a2 01		      ldx	#1	; 2 channels
    107  5419				   .advanceLoop
    108  5419					      IF	TT_USE_OVERLAY = 1
    109  5419		       20 2f f4 	      jsr	tt_FetchNote
    110  541c				  -	      ELSE
    111  541c				  -	      TT_FETCH_CURRENT_NOTE
    112  541c					      ENDIF
    113  541c							; Parse new note from pattern
    114  541c		       c9 10		      cmp	#TT_INS_PAUSE
    115  541e					      IF	TT_USE_SLIDE = 0
    116  541e		       90 55		      bcc	.finishedNewNote
    117  5420		       d0 3d		      bne	.newNote
    118  5422				  -	      ELSE
    119  5422				  -	      beq	.pause
    120  5422				  -	      bcs	.newNote
    121  5422				  -
    122  5422				  -			; --- slide/hold ---
    123  5422				  -			; Adjust frequency and hold note in sustain.
    124  5422				  -			; composer/tracker has to make sure that no unwanted
    125  5422				  -			; under/overflow happens.
    126  5422				  -			; Note: f = f + (8-(16-x)) = x + f - 8
    127  5422				  -	      adc	tt_cur_ins_c0,x	; carry is clear after cmp
    128  5422				  -	      sec
    129  5422				  -	      sbc	#8
    130  5422				  -	      sta	tt_cur_ins_c0,x
    131  5422				  -	      bcs	.finishedNewNote	; unconditional, since legally no underflow can happen (ins>0 or HOLD for ins=0)
    132  5422					      ENDIF
    133  5422
    134  5422							; --- pause ---
    135  5422				   .pause
    136  5422							; Get release index for current instrument. Since a pause can
    137  5422							; only follow an instrument, we don't need to handle percussion
    138  5422							; or commands.
    139  5422		       b5 d7		      lda	tt_cur_ins_c0,x
    140  5424		       20 bd f4 	      jsr	tt_CalcInsIndex
    141  5427		       b9 ff f4 	      lda	tt_InsReleaseIndexes-1,y	; -1 b/c instruments start at #1
    142  542a							; Put it into release. Skip junk byte so index no longer indicates
    143  542a							; sustain phase.
    144  542a		       18		      clc
    145  542b		       69 01		      adc	#1
    146  542d		       90 44		      bcc	.storeADIndex	; unconditional
    147  542f
    148  542f							; ---------------------------------------------------------------------
    149  542f							; Helper subroutine to minimize ROM footprint. Will be inlined if
    150  542f							; TT_USE_OVERLAY is not used.
    151  542f							; Interleaved here so player can be inlined.
    152  542f							; ---------------------------------------------------------------------
    153  542f					      IF	TT_USE_OVERLAY = 1
    154  542f				   tt_FetchNote
      0  542f					      TT_FETCH_CURRENT_NOTE
      1  542f
      2  542f				   .constructPatPtr
      3  542f		       b4 d1		      ldy	tt_cur_pat_index_c0,x
      4  5431		       b9 12 f6 	      lda	tt_SequenceTable,y
      5  5434					      IF	TT_USE_GOTO = 1
      6  5434		       10 06		      bpl	.noPatternGoto
      7  5436		       29 7f		      and	#%01111111
      8  5438		       95 d1		      sta	tt_cur_pat_index_c0,x
      9  543a		       10 f3		      bpl	.constructPatPtr
     10  543c				   .noPatternGoto
     11  543c					      ENDIF
     12  543c		       a8		      tay
     13  543d		       b9 08 f6 	      lda	tt_PatternPtrLo,y
     14  5440		       85 d9		      sta	tt_ptr
     15  5442		       b9 0d f6 	      lda	tt_PatternPtrHi,y
     16  5445		       85 da		      sta	tt_ptr+1
     17  5447
     18  5447				  -	      IF	TT_USE_OVERLAY = 0
     19  5447				  -	      ldy	tt_cur_note_index_c0,x
     20  5447					      ELSE
     21  5447
     22  5447
     23  5447
     24  5447		       b8		      clv
     25  5448
     26  5448		       b5 d3		      lda	tt_cur_note_index_c0,x
     27  544a		       10 07		      bpl	.notPrefetched
     28  544c
     29  544c		       29 7f		      and	#%01111111
     30  544e		       95 d3		      sta	tt_cur_note_index_c0,x
     31  5450
     32  5450		       2c c3 f4 	      bit	tt_Bit6Set
     33  5453				   .notPrefetched
     34  5453		       a8		      tay
     35  5454					      ENDIF
     36  5454		       b1 d9		      lda	(tt_ptr),y
     37  5456
     38  5456
     39  5456
     40  5456		       d0 06		      bne	.noEndOfPattern
     41  5458
     42  5458		       95 d3		      sta	tt_cur_note_index_c0,x
     43  545a		       f6 d1		      inc	tt_cur_pat_index_c0,x
     44  545c		       d0 d1		      bne	.constructPatPtr
     45  545e				   .noEndOfPattern
    156  545e		       60		      rts
    157  545f					      ENDIF
    158  545f
    159  545f
    160  545f							; --- start instrument or percussion ---
    161  545f				   .newNote
    162  545f		       95 d7		      sta	tt_cur_ins_c0,x	; set new instrument
    163  5461							; Instrument or percussion?
    164  5461		       c9 20		      cmp	#TT_FREQ_MASK+1
    165  5463		       b0 06		      bcs	.startInstrument
    166  5465
    167  5465							; --- start percussion ---
    168  5465							; Get index of envelope
    169  5465		       a8		      tay
    170  5466							; -TT_FIRST_PERC because percussion start with TT_FIRST_PERC
    171  5466		       b9 23 f5 	      lda	tt_PercIndexes-TT_FIRST_PERC,y
    172  5469		       d0 08		      bne	.storeADIndex	; unconditional, since index values are >0
    173  546b
    174  546b							; --- start instrument ---
    175  546b				   .startInstrument
    176  546b					      IF	TT_USE_OVERLAY = 1
    177  546b							; If V flag is set, this note had been pre-fetched. That means
    178  546b							; it should remain in sustain.
    179  546b		       70 08		      bvs	.finishedNewNote
    180  546d					      ENDIF
    181  546d							; Put note into attack/decay
    182  546d		       20 bd f4 	      jsr	tt_CalcInsIndex
    183  5470		       b9 f5 f4 	      lda	tt_InsADIndexes-1,y	; -1 because instruments start at #1
    184  5473				   .storeADIndex
    185  5473		       95 d5		      sta	tt_envelope_index_c0,x
    186  5475
    187  5475							; --- Finished parsing new note ---
    188  5475				   .finishedNewNote
    189  5475							; increase note index into pattern
    190  5475		       f6 d3		      inc	tt_cur_note_index_c0,x
    191  5477							; loop over channels
    192  5477				   .sequencerNextChannel
    193  5477		       ca		      dex
    194  5478		       10 9f		      bpl	.advanceLoop
    195  547a
    196  547a							; Reset timer value
    197  547a				  -	      IF	TT_GLOBAL_SPEED = 0
    198  547a				  -			; Get timer value for current pattern in channel 0
    199  547a				  -	      ldx	tt_cur_pat_index_c0	; get current pattern (index into tt_SequenceTable)
    200  547a				  -	      ldy	tt_SequenceTable,x	; Current pattern index now in y
    201  547a				  -	      IF	TT_USE_FUNKTEMPO = 0
    202  547a				  -	      lda	tt_PatternSpeeds,y
    203  547a				  -	      sta	tt_timer
    204  547a				  -	      ELSE
    205  547a				  -			; Test for odd/even frame
    206  547a				  -	      lda	tt_cur_note_index_c0
    207  547a				  -	      lsr
    208  547a				  -	      lda	tt_PatternSpeeds,y	; does not affect carry flag
    209  547a				  -	      bcc	.evenFrame
    210  547a				  -	      and	#$0f	; does not affect carry flag
    211  547a				  -	      bcs	.storeFunkTempo
    212  547a				  -.evenFrame
    213  547a				  -	      lsr
    214  547a				  -	      lsr
    215  547a				  -	      lsr
    216  547a				  -	      lsr
    217  547a				  -.storeFunkTempo
    218  547a				  -	      sta	tt_timer
    219  547a				  -	      ENDIF		; TT_USE_FUNKTEMPO = 0
    220  547a				  -
    221  547a					      ELSE
    222  547a							; Global tempo
    223  547a		       a2 04		      ldx	#TT_SPEED-1
    224  547c					      IF	TT_USE_FUNKTEMPO = 1
    225  547c		       a5 d3		      lda	tt_cur_note_index_c0
    226  547e		       4a		      lsr
    227  547f		       90 02		      bcc	.noOddFrame
    228  5481		       a2 03		      ldx	#TT_ODD_SPEED-1
    229  5483				   .noOddFrame
    230  5483					      ENDIF		; TT_USE_FUNKTEMPO = 1
    231  5483		       86 d0		      stx	tt_timer
    232  5485					      ENDIF		; TT_GLOBAL_SPEED = 0
    233  5485
    234  5485							; No new note to process
    235  5485				   .noNewNote
    236  5485
    237  5485							; ==================== Update registers ====================
    238  5485		       a2 01		      ldx	#1	; 2 channels
    239  5487				   .updateLoop
    240  5487							; Percussion or melodic instrument?
    241  5487		       b5 d7		      lda	tt_cur_ins_c0,x
    242  5489				  -	      IF	TT_STARTS_WITH_NOTES = 0
    243  5489				  -			; This branch can be removed if track starts with a note in each channel
    244  5489				  -	      beq	.afterAudioUpdate
    245  5489					      ENDIF
    246  5489		       c9 20		      cmp	#TT_FREQ_MASK+1
    247  548b		       b0 37		      bcs	.instrument	; Melodic instrument
    248  548d
    249  548d							; --- Percussion: Get envelope index ---
    250  548d		       b4 d5		      ldy	tt_envelope_index_c0,x
    251  548f							; Set AUDC and AUDV value from envelope
    252  548f		       b9 4c f5 	      lda	tt_PercCtrlVolTable-1,y	; -1 because values are stored +1
    253  5492		       f0 02		      beq	.endOfPercussion	; 0 means end of percussion data
    254  5494		       f6 d5		      inc	tt_envelope_index_c0,x	; if end not reached: advance index
    255  5496				   .endOfPercussion
    256  5496		       95 59		      sta	AUDV0,x
    257  5498		       4a		      lsr
    258  5499		       4a		      lsr
    259  549a		       4a		      lsr
    260  549b		       4a		      lsr
    261  549c		       95 55		      sta	AUDC0,x
    262  549e							; Set AUDF
    263  549e		       b9 36 f5 	      lda	tt_PercFreqTable-1,y	; -1 because values are stored +1
    264  54a1							; Bit 7 (overlay) might be set, but is unused in AUDF
    265  54a1		       95 57		      sta	AUDF0,x
    266  54a3					      IF	TT_USE_OVERLAY = 1
    267  54a3		       10 48		      bpl	.afterAudioUpdate
    268  54a5							; Overlay percussion: Fetch next note out of order
    269  54a5		       20 2f f4 	      jsr	tt_FetchNote
    270  54a8							; Only do something if it's a melodic instrument
    271  54a8		       c9 20		      cmp	#TT_FREQ_MASK+1
    272  54aa		       90 41		      bcc	.afterAudioUpdate
    273  54ac							; Instrument: Put into sustain
    274  54ac		       95 d7		      sta	tt_cur_ins_c0,x	; set new instrument
    275  54ae		       20 bd f4 	      jsr	tt_CalcInsIndex
    276  54b1		       b9 fa f4 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start at #1
    277  54b4		       95 d5		      sta	tt_envelope_index_c0,x
    278  54b6							; Set prefetch flag. asl-sec-ror is smaller than lda-ora #128-sta
    279  54b6		       16 d3		      asl	tt_cur_note_index_c0,x
    280  54b8		       38		      sec
    281  54b9		       76 d3		      ror	tt_cur_note_index_c0,x
    282  54bb		       30 30		      bmi	.afterAudioUpdate	; unconditional
    283  54bd				  -	      ELSE
    284  54bd				  -	      jmp	.afterAudioUpdate
    285  54bd					      ENDIF
    286  54bd
    287  54bd
    288  54bd							; ---------------------------------------------------------------------
    289  54bd							; Helper subroutine to minimize ROM footprint.
    290  54bd							; Interleaved here so player routine can be inlined.
    291  54bd							; ---------------------------------------------------------------------
    292  54bd				   tt_CalcInsIndex
    293  54bd							; move upper 3 bits to lower 3
    294  54bd		       4a		      lsr
    295  54be		       4a		      lsr
    296  54bf		       4a		      lsr
    297  54c0		       4a		      lsr
    298  54c1		       4a		      lsr
    299  54c2		       a8		      tay
    300  54c3				   tt_Bit6Set		; This opcode has bit #6 set, for use with bit instruction
    301  54c3		       60		      rts
    302  54c4
    303  54c4
    304  54c4				   .instrument
    305  54c4							; --- Melodic instrument ---
    306  54c4							; Compute index into ADSR indexes and master Ctrl tables
    307  54c4		       20 bd f4 	      jsr	tt_CalcInsIndex
    308  54c7							; Set AUDC with master value for this instrument, while we are at it
    309  54c7		       b9 f0 f4 	      lda	tt_InsCtrlTable-1,y	; -1 because instruments start with #1
    310  54ca		       95 55		      sta	AUDC0,x
    311  54cc							; advance ADSR counter and compare to end of Sustain
    312  54cc		       b5 d5		      lda	tt_envelope_index_c0,x
    313  54ce		       d9 ff f4 	      cmp	tt_InsReleaseIndexes-1,y	; -1 because instruments start with #1
    314  54d1		       d0 03		      bne	.noEndOfSustain
    315  54d3							; End of sustain: Go back to start of sustain
    316  54d3		       b9 fa f4 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start with #1
    317  54d6				   .noEndOfSustain
    318  54d6		       a8		      tay
    319  54d7							; Set volume from envelope
    320  54d7		       b9 05 f5 	      lda	tt_InsFreqVolTable,y
    321  54da		       f0 01		      beq	.endOfEnvelope	; 0 means end of release has been reached:
    322  54dc		       c8		      iny		; advance index otherwise
    323  54dd				   .endOfEnvelope
    324  54dd		       94 d5		      sty	tt_envelope_index_c0,x
    325  54df		       95 59		      sta	AUDV0,x
    326  54e1							; Now adjust frequency with ADSR value from envelope
    327  54e1		       4a		      lsr
    328  54e2		       4a		      lsr
    329  54e3		       4a		      lsr
    330  54e4		       4a		      lsr
    331  54e5		       18		      clc
    332  54e6		       75 d7		      adc	tt_cur_ins_c0,x
    333  54e8		       38		      sec
    334  54e9		       e9 08		      sbc	#8
    335  54eb		       95 57		      sta	AUDF0,x
    336  54ed
    337  54ed				   .afterAudioUpdate
    338  54ed							; loop over channels
    339  54ed		       ca		      dex
    340  54ee		       10 97		      bpl	.updateLoop
    341  54f0
 Music player size:  $dd
    342  54f0					      echo	"Music player size: ", *-tt_PlayerStart
------- FILE BANK_INITBANK.asm
   1156  54f0		       60		      rts
   1157  54f1
------- FILE sound/intro1_trackdata.asm LEVEL 3 PASS 3
      0  54f1					      include	"sound/intro1_trackdata.asm"
      1  54f1							; TIATracker music player
      2  54f1							; Copyright 2016 Andre "Kylearan" Wichmann
      3  54f1							; Website: https://bitbucket.org/kylearan/tiatracker
      4  54f1							; Email: andre.wichmann@gmx.de
      5  54f1							;
      6  54f1							; Licensed under the Apache License, Version 2.0 (the "License");
      7  54f1							; you may not use this file except in compliance with the License.
      8  54f1							; You may obtain a copy of the License at
      9  54f1							;
     10  54f1							;   http://www.apache.org/licenses/LICENSE-2.0
     11  54f1							;
     12  54f1							; Unless required by applicable law or agreed to in writing, software
     13  54f1							; distributed under the License is distributed on an "AS IS" BASIS,
     14  54f1							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  54f1							; See the License for the specific language governing permissions and
     16  54f1							; limitations under the License.
     17  54f1
     18  54f1							; Song author: 
     19  54f1							; Song name: 
     20  54f1
     21  54f1							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  54f1
     23  54f1							; =====================================================================
     24  54f1							; TIATracker melodic and percussion instruments, patterns and sequencer
     25  54f1							; data.
     26  54f1							; =====================================================================
     27  54f1				   tt_TrackDataStart
     28  54f1
     29  54f1							; =====================================================================
     30  54f1							; Melodic instrument definitions (up to 7). tt_envelope_index_c0/1 hold
     31  54f1							; the index values into these tables for the current instruments played
     32  54f1							; in channel 0 and 1.
     33  54f1							; 
     34  54f1							; Each instrument is defined by:
     35  54f1							; - tt_InsCtrlTable: the AUDC value
     36  54f1							; - tt_InsADIndexes: the index of the start of the ADSR envelope as
     37  54f1							;	 defined in tt_InsFreqVolTable
     38  54f1							; - tt_InsSustainIndexes: the index of the start of the Sustain phase
     39  54f1							;	 of the envelope
     40  54f1							; - tt_InsReleaseIndexes: the index of the start of the Release phase
     41  54f1							; - tt_InsFreqVolTable: The AUDF frequency and AUDV volume values of
     42  54f1							;	 the envelope
     43  54f1							; =====================================================================
     44  54f1
     45  54f1							; Instrument master CTRL values
     46  54f1				   tt_InsCtrlTable
     47  54f1		       07 04 0c 04*	      dc.b	$07, $04, $0c, $04, $0c
     48  54f6
     49  54f6
     50  54f6							; Instrument Attack/Decay start indexes into ADSR tables.
     51  54f6				   tt_InsADIndexes
     52  54f6		       00 0e 0e 1e*	      dc.b	$00, $0e, $0e, $1e, $1e
     53  54fb
     54  54fb
     55  54fb							; Instrument Sustain start indexes into ADSR tables
     56  54fb				   tt_InsSustainIndexes
     57  54fb		       08 19 19 2b*	      dc.b	$08, $19, $19, $2b, $2b
     58  5500
     59  5500
     60  5500							; Instrument Release start indexes into ADSR tables
     61  5500							; Caution: Values are stored with an implicit -1 modifier! To get the
     62  5500							; real index, add 1.
     63  5500				   tt_InsReleaseIndexes
     64  5500		       09 1b 1b 2c*	      dc.b	$09, $1b, $1b, $2c, $2c
     65  5505
     66  5505
     67  5505							; AUDVx and AUDFx ADSR envelope values.
     68  5505							; Each byte encodes the frequency and volume:
     69  5505							; - Bits 7..4: Freqency modifier for the current note ([-8..7]),
     70  5505							;	 8 means no change. Bit 7 is the sign bit.
     71  5505							; - Bits 3..0: Volume
     72  5505							; Between sustain and release is one byte that is not used and
     73  5505							; can be any value.
     74  5505							; The end of the release phase is encoded by a 0.
     75  5505				   tt_InsFreqVolTable
     76  5505							; 0: Pizzicato bassb
     77  5505		       8a 8a 89 88*	      dc.b	$8a, $8a, $89, $88, $86, $85, $85, $84
     78  550d		       83 00 83 83*	      dc.b	$83, $00, $83, $83, $83, $00
     79  5513							; 1+2: Square2
     80  5513		       8c 8c 8b 89*	      dc.b	$8c, $8c, $8b, $89, $87, $85, $84, $83
     81  551b		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $00, $81, $00
     82  5523							; 3+4: Square
     83  5523		       85 85 85 85*	      dc.b	$85, $85, $85, $85, $84, $83, $83, $82
     84  552b		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $81, $00, $80
     85  5533		       00		      dc.b	$00
     86  5534
     87  5534
     88  5534
     89  5534							; =====================================================================
     90  5534							; Percussion instrument definitions (up to 15)
     91  5534							;
     92  5534							; Each percussion instrument is defined by:
     93  5534							; - tt_PercIndexes: The index of the first percussion frame as defined
     94  5534							;	 in tt_PercFreqTable and tt_PercCtrlVolTable
     95  5534							; - tt_PercFreqTable: The AUDF frequency value
     96  5534							; - tt_PercCtrlVolTable: The AUDV volume and AUDC values
     97  5534							; =====================================================================
     98  5534
     99  5534							; Indexes into percussion definitions signifying the first frame for
    100  5534							; each percussion in tt_PercFreqTable.
    101  5534							; Caution: Values are stored with an implicit +1 modifier! To get the
    102  5534							; real index, subtract 1.
    103  5534				   tt_PercIndexes
    104  5534		       01 0a 0c 	      dc.b	$01, $0a, $0c
    105  5537
    106  5537
    107  5537							; The AUDF frequency values for the percussion instruments.
    108  5537							; If the second to last value is negative (>=128), it means it's an
    109  5537							; "overlay" percussion, i.e. the player fetches the next instrument note
    110  5537							; immediately and starts it in the sustain phase next frame. (Needs
    111  5537							; TT_USE_OVERLAY)
    112  5537				   tt_PercFreqTable
    113  5537							; 0: Kick
    114  5537		       00 01 02 03*	      dc.b	$00, $01, $02, $03, $04, $05, $06, $87
    115  553f		       00		      dc.b	$00
    116  5540							; 1: HH
    117  5540		       80 00		      dc.b	$80, $00
    118  5542							; 2: Snare
    119  5542		       01 03 06 0e*	      dc.b	$01, $03, $06, $0e, $13, $11, $15, $14
    120  554a		       17 1b 00 	      dc.b	$17, $1b, $00
    121  554d
    122  554d
    123  554d							; The AUDCx and AUDVx volume values for the percussion instruments.
    124  554d							; - Bits 7..4: AUDC value
    125  554d							; - Bits 3..0: AUDV value
    126  554d							; 0 means end of percussion data.
    127  554d				   tt_PercCtrlVolTable
    128  554d							; 0: Kick
    129  554d		       ee ed ed eb*	      dc.b	$ee, $ed, $ed, $eb, $e9, $e8, $e8, $e6
    130  5555		       00		      dc.b	$00
    131  5556							; 1: HH
    132  5556		       87 00		      dc.b	$87, $00
    133  5558							; 2: Snare
    134  5558		       8b 8a 8a 8a*	      dc.b	$8b, $8a, $8a, $8a, $8a, $8a, $89, $88
    135  5560		       87 86 00 	      dc.b	$87, $86, $00
    136  5563
    137  5563
    138  5563
    139  5563							; =====================================================================
    140  5563							; Track definition
    141  5563							; The track is defined by:
    142  5563							; - tt_PatternX (X=0, 1, ...): Pattern definitions
    143  5563							; - tt_PatternPtrLo/Hi: Pointers to the tt_PatternX tables, serving
    144  5563							;	 as index values
    145  5563							; - tt_SequenceTable: The order in which the patterns should be played,
    146  5563							;	 i.e. indexes into tt_PatternPtrLo/Hi. Contains the sequences
    147  5563							;	 for all channels and sub-tracks. The variables
    148  5563							;	 tt_cur_pat_index_c0/1 hold an index into tt_SequenceTable for
    149  5563							;	 each channel.
    150  5563							;
    151  5563							; So tt_SequenceTable holds indexes into tt_PatternPtrLo/Hi, which
    152  5563							; in turn point to pattern definitions (tt_PatternX) in which the notes
    153  5563							; to play are specified.
    154  5563							; =====================================================================
    155  5563
    156  5563							; ---------------------------------------------------------------------
    157  5563							; Pattern definitions, one table per pattern. tt_cur_note_index_c0/1
    158  5563							; hold the index values into these tables for the current pattern
    159  5563							; played in channel 0 and 1.
    160  5563							;
    161  5563							; A pattern is a sequence of notes (one byte per note) ending with a 0.
    162  5563							; A note can be either:
    163  5563							; - Pause: Put melodic instrument into release. Must only follow a
    164  5563							;	 melodic instrument.
    165  5563							; - Hold: Continue to play last note (or silence). Default "empty" note.
    166  5563							; - Slide (needs TT_USE_SLIDE): Adjust frequency of last melodic note
    167  5563							;	 by -7..+7 and keep playing it
    168  5563							; - Play new note with melodic instrument
    169  5563							; - Play new note with percussion instrument
    170  5563							; - End of pattern
    171  5563							;
    172  5563							; A note is defined by:
    173  5563							; - Bits 7..5: 1-7 means play melodic instrument 1-7 with a new note
    174  5563							;	 and frequency in bits 4..0. If bits 7..5 are 0, bits 4..0 are
    175  5563							;	 defined as:
    176  5563							;	 - 0: End of pattern
    177  5563							;	 - [1..15]: Slide -7..+7 (needs TT_USE_SLIDE)
    178  5563							;	 - 8: Hold
    179  5563							;	 - 16: Pause
    180  5563							;	 - [17..31]: Play percussion instrument 1..15
    181  5563							;
    182  5563							; The tracker must ensure that a pause only follows a melodic
    183  5563							; instrument or a hold/slide.
    184  5563							; ---------------------------------------------------------------------
    185  5563		       00 1f	   TT_FREQ_MASK =	%00011111
    186  5563		       00 08	   TT_INS_HOLD =	8
    187  5563		       00 10	   TT_INS_PAUSE =	16
    188  5563		       00 11	   TT_FIRST_PERC =	17
    189  5563
    190  5563							; Intro left
    191  5563				   tt_pattern0
    192  5563		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $3e, $08
    193  556b		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $3e, $08
    194  5573		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $12, $3e
    195  557b		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $13, $08
    196  5583		       00		      dc.b	$00
    197  5584
    198  5584							; Intro2 L
    199  5584				   tt_pattern1
    200  5584		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    201  558c		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    202  5594		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    203  559c		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    204  55a4		       00		      dc.b	$00
    205  55a5
    206  55a5							; Intro2-fill L
    207  55a5				   tt_pattern2
    208  55a5		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    209  55ad		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    210  55b5		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    211  55bd		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    212  55c5		       00		      dc.b	$00
    213  55c6
    214  55c6							; Intro right
    215  55c6				   tt_pattern3
    216  55c6		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $73, $08
    217  55ce		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $73, $08, $73, $08
    218  55d6		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $b3, $08
    219  55de		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    220  55e6		       00		      dc.b	$00
    221  55e7
    222  55e7							; Intro2 R
    223  55e7				   tt_pattern4
    224  55e7		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    225  55ef		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    226  55f7		       b3 08 73 08*	      dc.b	$b3, $08, $73, $08, $b3, $08, $73, $08
    227  55ff		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    228  5607		       00		      dc.b	$00
    229  5608
    230  5608
    231  5608
    232  5608
    233  5608							; Individual pattern speeds (needs TT_GLOBAL_SPEED = 0).
    234  5608							; Each byte encodes the speed of one pattern in the order
    235  5608							; of the tt_PatternPtr tables below.
    236  5608							; If TT_USE_FUNKTEMPO is 1, then the low nibble encodes
    237  5608							; the even speed and the high nibble the odd speed.
    238  5608				  -	      IF	TT_GLOBAL_SPEED = 0
    239  5608				  -tt_PatternSpeeds
    240  5608				  -%%PATTERNSPEEDS%%
    241  5608					      ENDIF
    242  5608
    243  5608
    244  5608							; ---------------------------------------------------------------------
    245  5608							; Pattern pointers look-up table.
    246  5608							; ---------------------------------------------------------------------
    247  5608				   tt_PatternPtrLo
    248  5608		       63 84 a5 c6	      dc.b	<tt_pattern0, <tt_pattern1, <tt_pattern2, <tt_pattern3
    249  560c		       e7		      dc.b	<tt_pattern4
    250  560d				   tt_PatternPtrHi
    251  560d		       f5 f5 f5 f5	      dc.b	>tt_pattern0, >tt_pattern1, >tt_pattern2, >tt_pattern3
    252  5611		       f5		      dc.b	>tt_pattern4
    253  5612
    254  5612
    255  5612							; ---------------------------------------------------------------------
    256  5612							; Pattern sequence table. Each byte is an index into the
    257  5612							; tt_PatternPtrLo/Hi tables where the pointers to the pattern
    258  5612							; definitions can be found. When a pattern has been played completely,
    259  5612							; the next byte from this table is used to get the address of the next
    260  5612							; pattern to play. tt_cur_pat_index_c0/1 hold the current index values
    261  5612							; into this table for channels 0 and 1.
    262  5612							; If TT_USE_GOTO is used, a value >=128 denotes a goto to the pattern
    263  5612							; number encoded in bits 6..0 (i.e. value AND %01111111).
    264  5612							; ---------------------------------------------------------------------
    265  5612				   tt_SequenceTable
    266  5612							; ---------- Channel 0 ----------
    267  5612		       00 00 01 02*	      dc.b	$00, $00, $01, $02, $80
    268  5617
    269  5617
    270  5617							; ---------- Channel 1 ----------
    271  5617		       03 04 03 04*	      dc.b	$03, $04, $03, $04, $85
    272  561c
    273  561c
 Track size:  $12b
    274  561c					      echo	"Track size: ", *-tt_TrackDataStart
------- FILE BANK_INITBANK.asm
   1159  561c
   1160  561c							;------------------------------------------------------------------------------
   1161  561c
      0  561c					      CHECK_BANK_SIZE	"INITBANK"
      1  561c		       06 1c	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $61c , FREE= $1e4
      2  561c					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  561c				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  561c				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  561c				  -	      ERR
      6  561c					      endif
------- FILE ./sokoboo.asm
    844  561c
    845  561c							; MUST BE LAST...
------- FILE BANK_FIXED.asm LEVEL 2 PASS 3
      0  561c					      include	"BANK_FIXED.asm"
      1  561c							;    Sokoboo - a Sokoban implementation
      2  561c							;    using a generic tile-based display engine for the Atari 2600
      3  561c							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  561c							;
      5  561c							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  561c							;
      7  561c							;    Code related to the generic tile-based display engine was developed by
      8  561c							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  561c							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  561c							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  561c							;
     12  561c							;    Code related to music and sound effects uses the TIATracker music player
     13  561c							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  561c							;    directory for Apache licensing details.
     15  561c							;
     16  561c							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  561c							;    See the copyright notices in the License directory for a list of level
     18  561c							;    contributors.
     19  561c							;
     20  561c							;    Except where otherwise indicated, this software is released under the
     21  561c							;    following licensing arrangement...
     22  561c							;
     23  561c							;    This program is free software: you can redistribute it and/or modify
     24  561c							;    it under the terms of the GNU General Public License as published by
     25  561c							;    the Free Software Foundation, either version 3 of the License, or
     26  561c							;    (at your option) any later version.
     27  561c							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  561c
     29  561c							;    This program is distributed in the hope that it will be useful,
     30  561c							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  561c							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  561c							;    GNU General Public License for more details.
     33  561c
     34  561c							;------------------------------------------------------------------------------
     35  561c							;###############################  FIXED BANK  #################################
     36  561c							;------------------------------------------------------------------------------
     37  561c
     38  561c
     39  561c				   ORIGIN     SET	FIXED_BANK
     40  561c
      0  561c					      NEWBANK	THE_FIXED_BANK
      1  7ff2 ????				      SEG	THE_FIXED_BANK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	THE_FIXED_BANK
     42  7800					      RORG	$f800
     43  7800
     44  7800							;------------------------------------------------------------------------------
     45  7800
      0  7800					      DEFINE_SUBROUTINE	DrawTimeFromROM
      1  7800		       00 0f	   BANK_DrawTimeFromROM =	_CURRENT_BANK
      2  7800					      SUBROUTINE
      3  7800				   DrawTimeFromROM
     47  7800
     48  7800		       a9 09		      lda	#BANK_SCORING
     49  7802		       85 3e		      sta	SET_BANK_RAM
     50  7804		       20 a3 f2 	      jsr	DrawTime
     51  7807		       20 97 f2 	      jsr	DrawBCD_targetsRequired
     52  780a		       a5 be		      lda	ROM_Bank
     53  780c		       85 3f		      sta	SET_BANK
     54  780e		       60		      rts
     55  780f
     56  780f							;------------------------------------------------------------------------------
     57  780f
      0  780f					      DEFINE_SUBROUTINE	GetROMByte	;=23(A)
      1  780f		       00 0f	   BANK_GetROMByte =	_CURRENT_BANK
      2  780f					      SUBROUTINE
      3  780f				   GetROMByte
     59  780f
     60  780f							; a = ROM bank to retrieve
     61  780f							; y = page index
     62  780f							; ROM_Bank = bank to return to
     63  780f							; (Board_AddressR) = page
     64  780f							; out a = byte from (Board_AddressR)
     65  780f
     66  780f		       85 3f		      sta	SET_BANK	;3
     67  7811		       4c 16 f8 	      jmp	GetBoardCharacter2	;3+17(A)	 unconditional
     68  7814
     69  7814							;------------------------------------------------------------------------------
     70  7814
      0  7814					      DEFINE_SUBROUTINE	GetBoardCharacter	;=20(A)
      1  7814		       00 0f	   BANK_GetBoardCharacter =	_CURRENT_BANK
      2  7814					      SUBROUTINE
      3  7814				   GetBoardCharacter
     72  7814
     73  7814							; call from ROM bank
     74  7814							; switches back to ROM_Bank on exit
     75  7814
     76  7814							; pass A = bank containing character
     77  7814							; Y = x character position
     78  7814							; (Board_AddressR) points to character position
     79  7814							; returns character from board
     80  7814
     81  7814
     82  7814		       85 3e		      sta	SET_BANK_RAM	;3   switch to bank to read
     83  7816
     84  7816				   GetBoardCharacter2		;=17(A)
     85  7816
     86  7816		       b3 ba		      lax	(Board_AddressR),y	;5
     87  7818		       a4 be		      ldy	ROM_Bank	;3
     88  781a		       84 3f		      sty	SET_BANK	;3   switch back caller's bank
     89  781c		       60		      rts		;6   and go back
     90  781d
     91  781d							;---------------------------------------------------------------------------
     92  781d
      0  781d					      DEFINE_SUBROUTINE	PutBoardCharacter	;=21(A)
      1  781d		       00 0f	   BANK_PutBoardCharacter =	_CURRENT_BANK
      2  781d					      SUBROUTINE
      3  781d				   PutBoardCharacter
     94  781d
     95  781d		       86 3e		      stx	SET_BANK_RAM	; 3
     96  781f
     97  781f				   PutBoardCharacterSB		; =18
     98  781f		       91 bc		      sta	(Board_AddressW),y	; 6
     99  7821		       a5 be		      lda	ROM_Bank	; 3
    100  7823		       85 3f		      sta	SET_BANK	; 3
    101  7825		       60		      rts		; 6 = 21
    102  7826
    103  7826							;---------------------------------------------------------------------------
    104  7826
      0  7826					      DEFINE_SUBROUTINE	GetBoardCharacter__CALL_FROM_RAM__	;=61[-2](A)
      1  7826		       00 0f	   BANK_GetBoardCharacter__CALL_FROM_RAM__ =	_CURRENT_BANK
      2  7826					      SUBROUTINE
      3  7826				   GetBoardCharacter__CALL_FROM_RAM__
    106  7826
    107  7826		       a4 88		      ldy	POS_Y	;3
    108  7828
    109  7828		       a9 0a		      lda	#BANK_GetBoardAddressR	;
    110  782a		       85 3f		      sta	SET_BANK	;
    111  782c		       20 dd f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    112  782f
    113  782f
    114  782f							;DEFINE_SUBROUTINE PartialGetBoardCharacter ;=23
    115  782f
    116  782f		       85 3e		      sta	SET_BANK_RAM	;3
    117  7831		       a4 87		      ldy	POS_X	;3
    118  7833		       b3 ba		      lax	(Board_AddressR),y	;5
    119  7835		       a4 bf		      ldy	RAM_Bank	;3
    120  7837		       84 3e		      sty	SET_BANK_RAM	;3		 return to RAM caller
    121  7839		       60		      rts		;6		 and go back
    122  783a
    123  783a							;---------------------------------------------------------------------------
    124  783a
      0  783a					      DEFINE_SUBROUTINE	PutBoardCharacterFromRAM	;=71[-2]
      1  783a		       00 0f	   BANK_PutBoardCharacterFromRAM =	_CURRENT_BANK
      2  783a					      SUBROUTINE
      3  783a				   PutBoardCharacterFromRAM
    126  783a
    127  783a							; POS_Y  = row
    128  783a							; POS_Type = character to write
    129  783a							; POS_X     = column
    130  783a							; RAM_Bank = caller's bank
    131  783a
    132  783a		       a4 88		      ldy	POS_Y	;3
    133  783c
    134  783c		       a9 0a		      lda	#BANK_GetBoardAddressW	;
    135  783e		       85 3f		      sta	SET_BANK	;
    136  7840		       20 ea f0 	      jsr	GetBoardAddressW	;11+24[-2](A)
    137  7843
    138  7843		       86 3e		      stx	SET_BANK_RAM	;3
    139  7845
    140  7845		       a4 87		      ldy	POS_X	;3
    141  7847		       a5 8b		      lda	POS_Type	;3
    142  7849		       91 bc		      sta	(Board_AddressW),y	;6
    143  784b		       a4 bf		      ldy	RAM_Bank	;3
    144  784d		       84 3e		      sty	SET_BANK_RAM	;3 return to RAM caller
    145  784f		       60		      rts		;6
    146  7850
    147  7850
      0  7850					      DEFINE_SUBROUTINE	PutBoardCharacterFromROM
      1  7850		       00 0f	   BANK_PutBoardCharacterFromROM =	_CURRENT_BANK
      2  7850					      SUBROUTINE
      3  7850				   PutBoardCharacterFromROM
    149  7850		       48		      pha
    150  7851		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    151  7854		       68		      pla
    152  7855		       85 3f		      sta	SET_BANK
    153  7857		       60		      rts
    154  7858
    155  7858							;---------------------------------------------------------------------------
    156  7858
      0  7858					      DEFINE_SUBROUTINE	ProcessObjStack	; @31✅ called from Vector
      1  7858		       00 0f	   BANK_ProcessObjStack =	_CURRENT_BANK
      2  7858					      SUBROUTINE
      3  7858				   ProcessObjStack
    158  7858							; 15 minimum segtime abort
    159  7858
    160  7858		       ad 84 02 	      lda	INTIM	; 4
    161  785b		       c9 03		      cmp	#MINIMUM_SEGTIME	; 2
    162  785d		       90 31		      bcc	EarlyAbort	; 2(3)= 8
    163  785f							; => [31]+9+6rts = 46✅ on abort
    164  785f							; @0✅
    165  785f
    166  785f		       a5 82		      lda	ObjStackNum	; 3
    167  7861		       49 01		      eor	#1	; 2
    168  7863		       aa		      tax		; 2 = 7✅
    169  7864
    170  7864		       a5 c2		      lda	ObjIterator	; 3
    171  7866		       d5 83		      cmp	ObjStackPtr,x	; 5
    172  7868		       b0 24		      bcs	nextPhase	; 2/3 = 10/11[+11] ==> @22✅ on exit
    173  786a
    174  786a							; @17✅
    175  786a							; Process an object...
    176  786a							; Actual object code (the handlers) starts 82 cycles after previous segtime check!
    177  786a
    178  786a		       bc 35 f9 	      ldy	BankObjStack,x	; 4
    179  786d		       84 3e		      sty	SET_BANK_RAM	; 3 = 7
    180  786f
    181  786f		       aa		      tax		; 2
    182  7870		       bc 80 11 	      ldy	SortedObjPtr,x	; 4 = 6	      indirect object pointer list (sorted)
    183  7873
    184  7873		       b9 00 10 	      lda	ObjStackX,y	; 4
    185  7876		       85 87		      sta	POS_X	; 3
    186  7878		       b9 80 10 	      lda	ObjStackY,y	; 4
    187  787b		       85 88		      sta	POS_Y	; 3
    188  787d		       b9 00 11 	      lda	ObjStackVar,y	; 4
    189  7880		       85 8c		      sta	POS_VAR	; 3
    190  7882		       be 00 12 	      ldx	ObjStackType,y	; 4
    191  7885		       86 8b		      stx	POS_Type	; 3 = 28
    192  7887
    193  7887		       a9 0a		      lda	#BANK_VectorProcess	; 2
    194  7889		       85 3f		      sta	SET_BANK	; 3
    195  788b		       4c e4 f3 	      jmp	VectorProcess	; 3 = 8
    196  788e
    197  788e							; => [17]+7+6+28+8 = @64 entry to VectorProcess
    198  788e							; + 31 minimum timeout return
    199  788e							; = 95✅
    200  788e
    201  788e							;---------------------------------------------------------------------------
    202  788e							; Now process the blank stack.  This stack holds all the recently blanked squares
    203  788e							; and determines (and moves) BOXs or TARGETs into these squares.  The space vacated
    204  788e							; by these objects are added again to the blank stack.
    205  788e
    206  788e				   nextPhase		; +11✅ for exit from here
    207  788e
    208  788e		       e6 86		      inc	ScreenDrawPhase	;5		 obj/blank finished -- let the draw stuff proceed
    209  7890		       60	   EarlyAbort rts		;6
    210  7891
    211  7891							;---------------------------------------------------------------------------
    212  7891
      0  7891					      DEFINE_SUBROUTINE	SwitchObjects	; = 31 ✅
      1  7891		       00 0f	   BANK_SwitchObjects =	_CURRENT_BANK
      2  7891					      SUBROUTINE
      3  7891				   SwitchObjects
    214  7891
    215  7891							; The game loop has come to an end. The only possible "still happening" thing is the sort, which runs
    216  7891							; in parallel with other processes (objects, draw stack, etc). We may or may not want to wait for the
    217  7891							; sort to complete.  This code does all the checks needed to switch to the next game frame.
    218  7891
    219  7891		       ad 84 02 	      lda	INTIM	; 4
    220  7894		       c9 03		      cmp	#SEGTIME_SWITCHOBJECTS	; 2
    221  7896		       90 f8		      bcc	EarlyAbort	; 2(3) => [31]+(9)+6rts = 46✅ on abort
    222  7898
    223  7898							; If we're undertime, then abort. The sort will continue to run, and that's great. Only when
    224  7898							; we're at the throttle cutoff do we switch game-frames.
    225  7898
    226  7898
    227  7898
    228  7898							;		  ;sec
    229  7898							;		  lda Throttle			  ;3
    230  7898							;		  sbc #MAX_THROTTLE		  ;2
    231  7898							;	      ;    bcc EarlyAbort		   ;2/3 	   plenty of time left!
    232  7898							;		  sta Throttle			  ;3 = 10	  save fractional 'left over' bit
    233  7898
    234  7898
    235  7898							; Now that we have completed processing the object stack, we switch
    236  7898							; the stack bank pointers for the next time around.
    237  7898
    238  7898		       a5 82		      lda	ObjStackNum	;3
    239  789a		       49 01		      eor	#1	;2
    240  789c		       aa		      tax		;2
    241  789d		       86 82		      stx	ObjStackNum	;3 = 10	 swap stacks @here
    242  789f
    243  789f							; Initialise the iterator and stack pointer for next time around.
    244  789f							; Previously the stack pointer auto-initialised by popping the stack. Now we have an iterator it's
    245  789f							; necessary to initialise both.
    246  789f
    247  789f		       a0 00		      ldy	#0	;2
    248  78a1		       84 c2		      sty	ObjIterator	;3
    249  78a3		       94 83		      sty	ObjStackPtr,x	;4
    250  78a5
    251  78a5		       84 86		      sty	ScreenDrawPhase	;3
    252  78a7		       60		      rts		;6
    253  78a8
    254  78a8							;---------------------------------------------------------------------------
    255  78a8
    256  78a8		       60	   EarlyAbort4 rts
    257  78a9
      0  78a9					      DEFINE_SUBROUTINE	PROCESS_MAN
      1  78a9		       00 0f	   BANK_PROCESS_MAN =	_CURRENT_BANK
      2  78a9					      SUBROUTINE
      3  78a9				   PROCESS_MAN
    259  78a9
    260  78a9		       ad 84 02 	      lda	INTIM	; 3
    261  78ac		       c9 16		      cmp	#SEGTIME_MAN	; 2
    262  78ae		       90 f8		      bcc	EarlyAbort4	; 2/3 = 7 + 6rts = 13✅ on abort
    263  78b0
    264  78b0		       a9 0a		      lda	#BANK_ManProcess
    265  78b2		       85 be		      sta	ROM_Bank
    266  78b4		       85 3f		      sta	SET_BANK
    267  78b6		       20 d0 f1 	      jsr	ManProcess
    268  78b9
    269  78b9
    270  78b9		       a9 ff		      lda	#-1
    271  78bb		       85 91		      sta	TB_CHAR	; pre-set box takeback to NONE
    272  78bd							;sta BufferedJoystick
    273  78bd
    274  78bd		       20 37 f9 	      jsr	MovePlayer
    275  78c0
    276  78c0		       a5 a1	   DoNothing  lda	ManMode
    277  78c2		       c9 07		      cmp	#MANMODE_NEXTLEVEL	; kludge
    278  78c4		       b0 08		      bcs	notComplete
    279  78c6		       a5 b4		      lda	BCD_targetsRequired
    280  78c8		       d0 04		      bne	notComplete
    281  78ca		       a9 07		      lda	#MANMODE_NEXTLEVEL
    282  78cc		       85 a1		      sta	ManMode
    283  78ce				   notComplete
    284  78ce
    285  78ce		       a9 03		      lda	#BANK_TrackPlayer	;
    286  78d0		       85 3f		      sta	SET_BANK	;
    287  78d2		       20 e3 f2 	      jsr	TrackPlayer	;11+145
    288  78d5
    289  78d5		       a9 00		      lda	#TYPE_MAN	; 2
    290  78d7		       85 8b		      sta	POS_Type	; 3
    291  78d9
    292  78d9		       20 07 f9 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    293  78dc
    294  78dc		       a9 ff		      lda	#$FF
    295  78de		       85 92		      sta	BufferedJoystick
    296  78e0
    297  78e0		       4c fc f8    gnobj      jmp	NextObject
    298  78e3
    299  78e3							;---------------------------------------------------------------------------
    300  78e3
      0  78e3					      DEFINE_SUBROUTINE	PutCharacterAtXY
      1  78e3		       00 0f	   BANK_PutCharacterAtXY =	_CURRENT_BANK
      2  78e3					      SUBROUTINE
      3  78e3				   PutCharacterAtXY
    302  78e3
    303  78e3							; POS_X	 character location
    304  78e3							; POS_Y
    305  78e3							; POS_VAR	 character to put on board
    306  78e3							; ROM_Bank	 ROM bank to return to
    307  78e3
    308  78e3		       a4 88		      ldy	POS_Y
    309  78e5
    310  78e5		       a9 0a		      lda	#BANK_GetBoardAddressW
    311  78e7		       85 3f		      sta	SET_BANK
    312  78e9		       20 ea f0 	      jsr	GetBoardAddressW
    313  78ec		       86 3e		      stx	SET_BANK_RAM
    314  78ee
    315  78ee		       a4 87		      ldy	POS_X
    316  78f0		       a5 8c		      lda	POS_VAR
    317  78f2		       91 bc		      sta	(Board_AddressW),y
    318  78f4
    319  78f4		       a5 be		      lda	ROM_Bank
    320  78f6		       85 3f		      sta	SET_BANK
    321  78f8		       60		      rts
    322  78f9
    323  78f9							;---------------------------------------------------------------------------
    324  78f9
    325  78f9							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    326  78f9							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    327  78f9
    328  78f9							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    329  78f9
    330  78f9							; if the creature dies then jump NextObject
    331  78f9
    332  78f9
    333  78f9		       20 07 f9    ReInsertObject jsr	InsertObjectStack	; 6+76(B)  = 98 (if jumping here)	  place on stack so it keeps moving
    334  78fc
    335  78fc		       e6 c2	   NextObject inc	ObjIterator	; 5
    336  78fe							;		  dec ObjStackPtr,x		  ; 6
    337  78fe		       60		      rts		;jmp ProcessObjStack		  ; 3 = 16	 ; DON'T chain, instead return
    338  78ff							; let the segtime stuff do its job!
    339  78ff
    340  78ff							;---------------------------------------------------------------------------
    341  78ff
      0  78ff					      DEFINE_SUBROUTINE	InsertObjectStackFromRAM	;=94(B)
      1  78ff		       00 0f	   BANK_InsertObjectStackFromRAM =	_CURRENT_BANK
      2  78ff					      SUBROUTINE
      3  78ff				   InsertObjectStackFromRAM
    343  78ff
    344  78ff		       20 07 f9 	      jsr	InsertObjectStack	;6+76(B)
    345  7902		       a5 bf		      lda	RAM_Bank	;3
    346  7904		       85 3e		      sta	SET_BANK_RAM	;3
    347  7906
    348  7906		       60	   NotEnoughTime rts		;6
    349  7907
    350  7907							;---------------------------------------------------------------------------
    351  7907
      0  7907					      DEFINE_SUBROUTINE	InsertObjectStack	;=81(B)
      1  7907		       00 0f	   BANK_InsertObjectStack =	_CURRENT_BANK
      2  7907					      SUBROUTINE
      3  7907				   InsertObjectStack
    353  7907							; POS_X     x position
    354  7907							; POS_Y     y position
    355  7907							; POS_VAR   direction or other variable
    356  7907							; POS_Type  type of object
    357  7907
    358  7907		       a6 82		      ldx	ObjStackNum	; 3
    359  7909		       bc 35 f9 	      ldy	BankObjStack,x	; 4
    360  790c		       84 3e		      sty	SET_BANK_RAM	; 3
    361  790e		       b4 83		      ldy	ObjStackPtr,x	; 4 = 14
    362  7910
    363  7910
    364  7910		       a5 88		      lda	POS_Y	; 3
    365  7912		       99 80 14 	      sta	ObjStackY+RAM_WRITE,y	; 5
    366  7915		       a5 87		      lda	POS_X	; 3
    367  7917		       99 00 14 	      sta	ObjStackX+RAM_WRITE,y	; 5
    368  791a		       a5 8c		      lda	POS_VAR	; 3
    369  791c		       99 00 15 	      sta	ObjStackVar+RAM_WRITE,y	; 5
    370  791f		       a5 8b		      lda	POS_Type	; 3
    371  7921		       99 00 16 	      sta	ObjStackType+RAM_WRITE,y	; 5 = 32
    372  7924
    373  7924							; Nice addition limits overflow of the stack, BUT always reserves a spot for the man.
    374  7924							; Objects are unceremoniously dumped when there's not enough space.  This is just trying to cater
    375  7924							; for a no-win situation. Try and preserve the player at the cost of correct gameplay. Avoid crashing.
    376  7924
    377  7924
    378  7924				  -	      IF	TYPE_MAN != 0
    379  7924				  -	      cmp	#TYPE_MAN	; 2
    380  7924					      ENDIF
    381  7924		       f0 04		      beq	alwaysAllowMan	; 2/3
    382  7926
    383  7926		       c0 7e		      cpy	#OBJ_STACK_SIZE-2	; 2	     reserve 1 last-gasp slot for man only
    384  7928		       b0 06		      bcs	insertDone	; 2/3= 6    no room -- drop object
    385  792a				   alwaysAllowMan
    386  792a
    387  792a		       98		      tya		; 2
    388  792b		       99 80 15 	      sta	SortedObjPtr+RAM_WRITE,y	; 5	     indirection pointer for later sorting
    389  792e
    390  792e		       f6 83		      inc	ObjStackPtr,x	; 7	     overflow is assumed not to happen!
    391  7930
    392  7930		       a4 be	   insertDone ldy	ROM_Bank	; 3
    393  7932		       84 3f		      sty	SET_BANK	; 3
    394  7934
    395  7934				   ManIsDead2
    396  7934
    397  7934
    398  7934
    399  7934		       60		      rts		; 6 = 29
    400  7935
    401  7935							;---------------------------------------------------------------------------
    402  7935
    403  7935		       0b 0c	   BankObjStack .byte.b	BANK_OBJSTACK, BANK_OBJSTACK2
    404  7937
    405  7937							;---------------------------------------------------------------------------
    406  7937
      0  7937					      DEFINE_SUBROUTINE	MovePlayer
      1  7937		       00 0f	   BANK_MovePlayer =	_CURRENT_BANK
      2  7937					      SUBROUTINE
      3  7937				   MovePlayer
    408  7937
    409  7937		       a4 8a		      ldy	POS_Y_NEW
    410  7939
    411  7939		       a9 0a		      lda	#BANK_GetBoardAddressRW	;2
    412  793b		       85 3f		      sta	SET_BANK	;3
    413  793d		       20 ca f0 	      jsr	GetBoardAddressRW	;6+32[-2]
    414  7940							;    IF MULTI_BANK_BOARD = YES
    415  7940							;		  stx RAM_Bank
    416  7940							;    ENDIF
    417  7940		       86 3e		      stx	SET_BANK_RAM	; 3
    418  7942
    419  7942		       a4 89		      ldy	POS_X_NEW
    420  7944		       b3 ba		      lax	(Board_AddressR),y
    421  7946
    422  7946		       a9 0a		      lda	#BANK_MoveVecLO
    423  7948		       85 3f		      sta	SET_BANK
    424  794a
    425  794a		       bd f3 f3 	      lda	MoveVecLO,x
    426  794d		       85 db		      sta	MAN_Move
    427  794f		       bd 03 f4 	      lda	MoveVecHI,x
    428  7952		       85 dc		      sta	MAN_Move+1
    429  7954
    430  7954							;    IF MULTI_BANK_BOARD = YES
    431  7954							;		  lda RAM_Bank
    432  7954							;    ELSE
    433  7954		       a9 0d		      lda	#BANK_BOARD
    434  7956							;    ENDIF
    435  7956		       85 3e		      sta	SET_BANK_RAM
    436  7958		       6c db 00 	      jmp	(MAN_Move)
    437  795b
    438  795b							;---------------------------------------------------------------------------
    439  795b
      0  795b					      DEFINE_SUBROUTINE	RecordTakeBackPosition
      1  795b		       00 0f	   BANK_RecordTakeBackPosition =	_CURRENT_BANK
      2  795b					      SUBROUTINE
      3  795b				   RecordTakeBackPosition
    441  795b
    442  795b							; Pass...
    443  795b							; TB_X 	 the man's position before he moved
    444  795b							; TB_Y
    445  795b							; TB_CHAR	 if -1 then there is no box push involved, else..
    446  795b							;		 holds the character that was under the box in its new position
    447  795b							; TB_PUSHX	 Position of pushed box AFTER it is pushed
    448  795b							; TB_PUSHY
    449  795b
    450  795b							; On making a move,
    451  795b							; man's position before move --> TB_X,TB_Y
    452  795b							; TB_CHAR = -1
    453  795b							; IF a box was pushed,
    454  795b							;   TB_CHAR = character under the box's new position (i.e., restoration char)
    455  795b							;   box's new position --> TB_PUSHX, TB_PUSHY
    456  795b							; ENDIF
    457  795b							; BCD_moveCounter++
    458  795b
    459  795b		       a5 b9		      lda	TakebackInhibit
    460  795d		       d0 2e		      bne	noLog
    461  795f
    462  795f		       a9 0e		      lda	#BANK_TAKEBACK
    463  7961		       85 3e		      sta	SET_BANK_RAM
    464  7963
    465  7963		       a6 b7		      ldx	takebackIndex
    466  7965
    467  7965		       a5 8d		      lda	TB_X
    468  7967		       9d 00 14 	      sta	RAM_WRITE+TakeBackPreviousX,x
    469  796a		       a5 8e		      lda	TB_Y
    470  796c		       9d 40 14 	      sta	RAM_WRITE+TakeBackPreviousY,x
    471  796f		       a5 91		      lda	TB_CHAR
    472  7971		       9d 00 15 	      sta	RAM_WRITE+TakeBackPushChar,x
    473  7974
    474  7974							; if TB_CHAR is -1 that means there is no box component, and the following values are random
    475  7974
    476  7974		       a5 8f		      lda	TB_PUSHX
    477  7976		       9d 80 14 	      sta	RAM_WRITE+TakeBackPushX,x
    478  7979		       a5 90		      lda	TB_PUSHY
    479  797b		       9d c0 14 	      sta	RAM_WRITE+TakeBackPushY,x
    480  797e
    481  797e		       a5 be		      lda	ROM_Bank
    482  7980		       85 3f		      sta	SET_BANK
    483  7982
    484  7982							; fall through
    485  7982
      0  7982					      DEFINE_SUBROUTINE	IncrementMoveCount
      1  7982		       00 0f	   BANK_IncrementMoveCount =	_CURRENT_BANK
      2  7982					      SUBROUTINE
      3  7982				   IncrementMoveCount
    487  7982		       a9 0a		      lda	#BANK_IMC
    488  7984		       85 3f		      sta	SET_BANK
    489  7986		       20 c1 f3 	      jsr	IMC
    490  7989		       a5 be		      lda	ROM_Bank
    491  798b		       85 3f		      sta	SET_BANK
    492  798d
    493  798d		       a9 00	   noLog      lda	#0
    494  798f		       85 b9		      sta	TakebackInhibit
    495  7991		       60		      rts
    496  7992
    497  7992							;---------------------------------------------------------------------------
    498  7992
      0  7992					      DEFINE_SUBROUTINE	MOVE_BLANK
      1  7992		       00 0f	   BANK_MOVE_BLANK =	_CURRENT_BANK
      2  7992					      SUBROUTINE
      3  7992				   MOVE_BLANK
      0  7992					      DEFINE_SUBROUTINE	MOVE_SOIL
      1  7992		       00 0f	   BANK_MOVE_SOIL =	_CURRENT_BANK
      2  7992					      SUBROUTINE
      3  7992				   MOVE_SOIL
      0  7992					      DEFINE_SUBROUTINE	MOVE_TARGET
      1  7992		       00 0f	   BANK_MOVE_TARGET =	_CURRENT_BANK
      2  7992					      SUBROUTINE
      3  7992				   MOVE_TARGET
    502  7992
    503  7992		       8a		      txa		; character man will be standing on
    504  7993		       48		      pha
    505  7994
    506  7994		       a9 ff		      lda	#$FF
    507  7996		       85 92		      sta	BufferedJoystick
    508  7998
    509  7998
    510  7998		       a5 a6		      lda	ManAnimationID
    511  799a		       c9 08		      cmp	#ANIMATION_PUSH_ID
    512  799c		       d0 0c		      bne	immediate
    513  799e
    514  799e		       e6 a8		      inc	idleCount
    515  79a0		       a5 a8		      lda	idleCount
    516  79a2		       c9 0a		      cmp	#10
    517  79a4		       90 22		      bcc	walkingOK
    518  79a6		       a9 00		      lda	#0
    519  79a8		       85 a8		      sta	idleCount
    520  79aa
    521  79aa				   immediate
    522  79aa		       a5 a6		      lda	ManAnimationID
    523  79ac		       c9 00		      cmp	#ANIMATION_WALK_ID
    524  79ae		       f0 18		      beq	walkingOK
    525  79b0		       c9 12		      cmp	#ANIMATION_WALK2_ID
    526  79b2		       f0 14		      beq	walkingOK
    527  79b4		       a9 00		      lda	#ANIMATION_WALK_ID
    528  79b6		       85 a6		      sta	ManAnimationID
      0  79b8					      LOAD_ANIMATION	WALK
      1  79b8		       a9 18		      lda	#<Animation_WALK
      2  79ba		       85 9a		      sta	animation
      3  79bc		       a9 f0		      lda	#>Animation_WALK
      4  79be		       85 9b		      sta	animation+1
      5  79c0		       a9 00		      lda	#0
      6  79c2		       85 9c		      sta	animation_delay
      7  79c4		       a9 00		      lda	#ANIMATION_WALK_ID
      8  79c6		       85 a6		      sta	ManAnimationID
    530  79c8				   walkingOK
    531  79c8
    532  79c8		       a5 9d		      lda	ManX
    533  79ca		       85 87		      sta	POS_X
    534  79cc		       85 8d		      sta	TB_X
    535  79ce		       a5 9e		      lda	ManY
    536  79d0		       85 88		      sta	POS_Y
    537  79d2		       85 8e		      sta	TB_Y
    538  79d4		       20 e3 f8 	      jsr	PutCharacterAtXY	; RESTORE (previous XY) under-man character
    539  79d7
    540  79d7		       a5 89		      lda	POS_X_NEW
    541  79d9		       85 9d		      sta	ManX
    542  79db		       85 87		      sta	POS_X
    543  79dd		       a5 8a		      lda	POS_Y_NEW
    544  79df		       85 9e		      sta	ManY
    545  79e1		       85 88		      sta	POS_Y
    546  79e3		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    547  79e5		       85 8c		      sta	POS_VAR
    548  79e7		       20 e3 f8 	      jsr	PutCharacterAtXY
    549  79ea
    550  79ea							; TB_X 	 the man's position before he moved
    551  79ea							; TB_Y
    552  79ea							; TB_CHAR	 if -1 then there is no box push involved, else..
    553  79ea							;		 holds the character that was under the box in its new position
    554  79ea							;		 this can be inferred by the box character (ONTARGET)
    555  79ea							; TB_PUSHX	 Position of pushed box AFTER it is pushed
    556  79ea							; TB_PUSHY
    557  79ea
    558  79ea		       20 5b f9 	      jsr	RecordTakeBackPosition
    559  79ed
    560  79ed		       68		      pla
    561  79ee		       85 8c		      sta	POS_VAR	; save 'restore' character
    562  79f0
    563  79f0		       a9 00	   MOVE_GENERIC lda	#0	; 2
    564  79f2		       85 a4		      sta	ManPushCounter	; 3
    565  79f4		       60		      rts		; 6 = 11
    566  79f5
    567  79f5							;---------------------------------------------------------------------------
    568  79f5							; takeback buffer empty - flash red
    569  79f5
    570  79f5		       a6 80	   noMovesToTake ldx	Platform
    571  79f7		       bd 01 fa 	      lda	redColour,x
    572  79fa		       85 b0		      sta	BGColour
    573  79fc		       a9 08		      lda	#8
    574  79fe		       85 c0		      sta	ColourTimer
    575  7a00		       60		      rts
    576  7a01
    577  7a01		       32 32 62 62 redColour  .byte.b	$32, $32, $62, $62
    578  7a05
    579  7a05							;---------------------------------------------------------------------------
    580  7a05
      0  7a05					      DEFINE_SUBROUTINE	MOVE_BOX
      1  7a05		       00 0f	   BANK_MOVE_BOX =	_CURRENT_BANK
      2  7a05					      SUBROUTINE
      3  7a05				   MOVE_BOX
    582  7a05
    583  7a05		       a2 00		      ldx	#CHARACTER_BLANK	; restoration character
    584  7a07		       a9 0a		      lda	#BANK_PushBox
    585  7a09		       85 3f		      sta	SET_BANK
    586  7a0b		       4c 2c f1 	      jmp	PushBox
    587  7a0e
      0  7a0e					      DEFINE_SUBROUTINE	MOVE_BOX_ON_TARGET
      1  7a0e		       00 0f	   BANK_MOVE_BOX_ON_TARGET =	_CURRENT_BANK
      2  7a0e					      SUBROUTINE
      3  7a0e				   MOVE_BOX_ON_TARGET
    589  7a0e
    590  7a0e		       a2 03		      ldx	#CHARACTER_TARGET	; restoration character
    591  7a10		       a9 0a		      lda	#BANK_PushBox
    592  7a12		       85 3f		      sta	SET_BANK
    593  7a14		       4c 2c f1 	      jmp	PushBox
    594  7a17
    595  7a17							;---------------------------------------------------------------------------
    596  7a17
      0  7a17					      DEFINE_SUBROUTINE	takebackRestoreEarlierPosition
      1  7a17		       00 0f	   BANK_takebackRestoreEarlierPosition =	_CURRENT_BANK
      2  7a17					      SUBROUTINE
      3  7a17				   takebackRestoreEarlierPosition
    598  7a17
    599  7a17
    600  7a17							; on reverting a move
    601  7a17							; IF BCD_moveCounter > 0
    602  7a17							;   BCD_moveCounter--
    603  7a17							;   IF TakeBackPushChar != -1
    604  7a17							;	 //restore the character under box (and remove box)
    605  7a17							;	 board[TakeBackPreviousX,TakeBackPreviousY] = TakeBackPushChar
    606  7a17							;   ENDIF
    607  7a17							; // We will "fix" any box going back on the board through the man's restoration char
    608  7a17							; board[ManX,ManY] = POS_VAR
    609  7a17							; POS_VAR = board[TakeBackX,TakeBackY]
    610  7a17							; board[TakeBackX,TakeBackY] = MANOCCUPIED
    611  7a17							; ManX,ManY = TakeBackX, TakeBackY
    612  7a17
    613  7a17		       a6 b7		      ldx	takebackIndex
    614  7a19		       e4 b8		      cpx	takebackBaseIndex
    615  7a1b		       f0 d8		      beq	noMovesToTake
    616  7a1d
    617  7a1d		       e6 b9		      inc	TakebackInhibit	; non-zero
    618  7a1f
    619  7a1f		       ca		      dex
    620  7a20		       8a		      txa
    621  7a21		       29 3f		      and	#TAKEBACK_MASK
    622  7a23		       85 b7		      sta	takebackIndex
    623  7a25		       aa		      tax
    624  7a26
    625  7a26		       f8		      sed
    626  7a27		       38		      sec
    627  7a28		       a5 b5		      lda	BCD_moveCounter
    628  7a2a		       e9 01		      sbc	#1
    629  7a2c		       85 b5		      sta	BCD_moveCounter
    630  7a2e		       a5 b6		      lda	BCD_moveCounter+1
    631  7a30		       e9 00		      sbc	#0
    632  7a32		       85 b6		      sta	BCD_moveCounter+1
    633  7a34		       d8		      cld
    634  7a35
    635  7a35				  -	      if	0
    636  7a35				  -	      lda	Platform
    637  7a35				  -	      clc
    638  7a35				  -	      adc	#8
    639  7a35				  -	      sta	BGColour	;ColourFlash		      ; yellow flash
    640  7a35				  -	      lda	#3
    641  7a35				  -	      sta	ColourTimer
    642  7a35					      endif
    643  7a35
    644  7a35		       a9 0e		      lda	#BANK_TAKEBACK
    645  7a37		       85 3e		      sta	SET_BANK_RAM
    646  7a39
    647  7a39							; TB_X 	 the man's position before he moved
    648  7a39							; TB_Y
    649  7a39							; TB_CHAR	 if -1 then there is no box push involved, else..
    650  7a39							;		 holds the character that was under the box in its new position
    651  7a39							; TB_PUSHX	 Position of pushed box AFTER it is pushed
    652  7a39							; TB_PUSHY
    653  7a39
    654  7a39							;	 //restore the character under box (and remove box)
    655  7a39							;	 board[TakeBackPreviousX,TakeBackPreviousY] = TakeBackPushChar
    656  7a39
    657  7a39		       a5 8c		      lda	POS_VAR
    658  7a3b		       48		      pha
    659  7a3c
    660  7a3c		       a6 b7		      ldx	takebackIndex
    661  7a3e		       bd 00 11 	      lda	TakeBackPushChar,x
    662  7a41		       30 29		      bmi	noPushInvolved	; -1 = no box
    663  7a43
    664  7a43		       85 8c		      sta	POS_VAR
    665  7a45		       c9 03		      cmp	#CHARACTER_TARGET
    666  7a47		       f0 04		      beq	isaTarget
    667  7a49		       c9 04		      cmp	#CHARACTER_TARGET2
    668  7a4b		       d0 03		      bne	notTarget1
    669  7a4d		       20 3e fd    isaTarget  jsr	RegisterTarget
    670  7a50				   notTarget1
    671  7a50
    672  7a50
    673  7a50		       bd 80 10 	      lda	TakeBackPushX,x
    674  7a53		       85 87		      sta	POS_X
    675  7a55		       bd c0 10 	      lda	TakeBackPushY,x
    676  7a58		       85 88		      sta	POS_Y
    677  7a5a
    678  7a5a		       20 e3 f8 	      jsr	PutCharacterAtXY	; fixup BOX!
    679  7a5d
    680  7a5d		       68		      pla
    681  7a5e		       f0 07		      beq	blnkre
    682  7a60		       20 48 fd 	      jsr	DeRegisterTarget
    683  7a63		       a9 0a		      lda	#CHARACTER_BOX_ON_TARGET
    684  7a65		       d0 02		      bne	skls
    685  7a67		       a9 02	   blnkre     lda	#CHARACTER_BOX
    686  7a69		       85 8c	   skls       sta	POS_VAR
    687  7a6b
    688  7a6b		       48		      pha
    689  7a6c
    690  7a6c		       68	   noPushInvolved pla		; man's replacement char
    691  7a6d		       85 8c		      sta	POS_VAR
    692  7a6f
    693  7a6f							; // We will "fix" any box going back on the board through the man's restoration char
    694  7a6f							; board[ManX,ManY] = POS_VAR
    695  7a6f							; POS_VAR = board[TakeBackX,TakeBackY]
    696  7a6f							; board[TakeBackX,TakeBackY] = MANOCCUPIED
    697  7a6f							; ManX,ManY = TakeBackX, TakeBackY
    698  7a6f
    699  7a6f		       a5 9d		      lda	ManX
    700  7a71		       85 87		      sta	POS_X
    701  7a73		       a5 9e		      lda	ManY
    702  7a75		       85 88		      sta	POS_Y
    703  7a77		       20 e3 f8 	      jsr	PutCharacterAtXY	; put what man was on... back
    704  7a7a
    705  7a7a
    706  7a7a		       a9 0e		      lda	#BANK_TAKEBACK
    707  7a7c		       85 3e		      sta	SET_BANK_RAM
    708  7a7e
    709  7a7e		       a6 b7		      ldx	takebackIndex
    710  7a80		       bd 00 10 	      lda	TakeBackPreviousX,x
    711  7a83		       85 89		      sta	POS_X_NEW
    712  7a85		       85 9d		      sta	ManX
    713  7a87		       bd 40 10 	      lda	TakeBackPreviousY,x
    714  7a8a		       85 8a		      sta	POS_Y_NEW
    715  7a8c		       85 9e		      sta	ManY
    716  7a8e
    717  7a8e							; Grab the character from the board at man's location and use as "restore character" for man
    718  7a8e							; POS_VAR = board[takebackx,takebacky]
    719  7a8e
    720  7a8e		       a9 0a		      lda	#BANK_GetBoardAddressR
    721  7a90		       85 3f		      sta	SET_BANK
    722  7a92		       a4 8a		      ldy	POS_Y_NEW
    723  7a94		       20 dd f0 	      jsr	GetBoardAddressR
    724  7a97		       85 3e		      sta	SET_BANK_RAM
    725  7a99
    726  7a99		       a4 89		      ldy	POS_X_NEW
    727  7a9b		       b1 ba		      lda	(Board_AddressR),y
    728  7a9d							;pha
    729  7a9d							;lda #CHARACTER_MANOCCUPIED
    730  7a9d							;sta POS_VAR
    731  7a9d							;jsr PutCharacterAtXY		 ????
    732  7a9d							;pla
    733  7a9d		       85 8c		      sta	POS_VAR
    734  7a9f
    735  7a9f		       a5 be		      lda	ROM_Bank
    736  7aa1		       85 3f		      sta	SET_BANK
    737  7aa3
    738  7aa3		       60	   timeExit   rts
    739  7aa4
    740  7aa4							;---------------------------------------------------------------------------
    741  7aa4
      0  7aa4					      DEFINE_SUBROUTINE	StealCharDraw	; in FIXED_BANK
      1  7aa4		       00 0f	   BANK_StealCharDraw =	_CURRENT_BANK
      2  7aa4					      SUBROUTINE
      3  7aa4				   StealCharDraw
    743  7aa4
    744  7aa4		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    745  7aa6		       85 3e		      sta	SET_BANK_RAM	; 3
    746  7aa8		       a4 81		      ldy	DrawStackPointer	; 3	     MUST have been set by BuildDrawStack!
    747  7aaa		       10 35		      bpl	EnterStealCharDraw	; 2(3) = 10(11)
    748  7aac
    749  7aac				   ExitStealCharDraw
    750  7aac
    751  7aac							; fall through...
    752  7aac
    753  7aac							;---------------------------------------------------------------------------
    754  7aac
      0  7aac					      DEFINE_SUBROUTINE	TimeSlice
      1  7aac		       00 0f	   BANK_TimeSlice =	_CURRENT_BANK
      2  7aac					      SUBROUTINE
      3  7aac				   TimeSlice
    756  7aac
    757  7aac							; FIRST check the time is sufficient for the smallest of the timeslices. Not much point
    758  7aac							; going ahead if there's insufficient time. This allows the previous character drawing to
    759  7aac							; be much smaller in time, as they don't have to include the timeslice code overhead.
    760  7aac
    761  7aac		       ad 84 02 	      lda	INTIM	; 4
    762  7aaf		       c9 03		      cmp	#SEGTIME_MINIMUM_TIMESLICE	; 2
    763  7ab1		       90 f0		      bcc	timeExit	; 2(3)
    764  7ab3							; @0✅
    765  7ab3
    766  7ab3							; Uses the phase variable to vector to the correct processing code for the given timeslice
    767  7ab3							; Code may be in any bank. Avoid the fixed bank at all costs!	Once a section is complete
    768  7ab3							; it should increment ScreenDrawPhase.
    769  7ab3
    770  7ab3							; Switched-in bank(s) are undefined after this function is called!
    771  7ab3
    772  7ab3		       a9 03		      lda	#BANK_TS_PhaseVectorLO	; 2
    773  7ab5		       85 3f		      sta	SET_BANK	; 3 = 5
    774  7ab7
    775  7ab7		       a6 86		      ldx	ScreenDrawPhase	; 3		 current phase of drawing
    776  7ab9		       bd 1e f3 	      lda	TS_PhaseVectorLO,x	; 4
    777  7abc		       85 db		      sta	TS_Vector	; 3
    778  7abe		       bd 23 f3 	      lda	TS_PhaseVectorHI,x	; 4
    779  7ac1		       85 dc		      sta	TS_Vector+1	; 3 = 17
    780  7ac3
    781  7ac3		       bd 28 f3 	      lda	TS_PhaseBank,x	; 4
    782  7ac6		       85 3f		      sta	SET_BANK	; 3 = 7	 switch bank
    783  7ac8
    784  7ac8		       6c db 00 	      jmp	(TS_Vector)	; 5 = 31✅	  vector to timeslice handler
    785  7acb
    786  7acb							;---------------------------------------------------------------------------
    787  7acb
    788  7acb
    789  7acb				   DrawAnother		;344✅SCD_QUICK
    790  7acb							;676✅SCD_SLOW
    791  7acb
    792  7acb
    793  7acb							; add 44✅ cycles for the following in the case where there is something to draw
    794  7acb							; but no time to do it. As this is executed after EVERY type of draw, then this
    795  7acb							; is the base "extra" cost to add to each draw
    796  7acb
    797  7acb		       00 35	   CYCLES_DRAWANOTHER =	53	;✅
    798  7acb
    799  7acb		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2	     A = SCREEN_LINES
    800  7acd		       85 3e		      sta	SET_BANK_RAM	; 3 =	5
    801  7acf
    802  7acf		       a4 81		      ldy	DrawStackPointer	; 3 =	3    MUST have been set by BuildDrawStack!
    803  7ad1
    804  7ad1		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    805  7ad4		       bd a0 f0 	      lda	ScreenBuffer,x	; 4	     new character to draw
    806  7ad7		       29 7f		      and	#~128	; 2
    807  7ad9		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 4 = 14    clear hint bit
    808  7adc
    809  7adc		       88		      dey		; 2
    810  7add		       84 81		      sty	DrawStackPointer	; 3	     one less to draw
    811  7adf		       30 cb		      bmi	ExitStealCharDraw	; 2(3)=7    NOTE1: (3)+(15exit) -->45✅ <CYCLES_DRAWANOTHER)
    812  7ae1							; => 29
    813  7ae1
    814  7ae1				   EnterStealCharDraw		; @11✅ from initial StealCharDraw call
    815  7ae1							; RAM bank MUST be at BANK_DRAW_BUFFERS
    816  7ae1
    817  7ae1		       ad 84 02 	      lda	INTIM	; 4
    818  7ae4		       c9 04		      cmp	#SEGTIME_SCD_MIN	; 2
    819  7ae6		       90 c4		      bcc	ExitStealCharDraw	; 2(3) = 8    ((9)+(15exit) IF EXITING HERE, from DrawAnother... 53✅)
    820  7ae8							;		else exit from StealCharDraw ... 26✅
    821  7ae8							; @0✅
    822  7ae8
    823  7ae8		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    824  7aeb		       bc a0 f0 	      ldy	ScreenBuffer,x	; 4 =	8✅  new character to draw
    825  7aee
    826  7aee		       bd 00 f2 	      lda	ROW_BankChar,x	; 4	     A = 0..SCREEN_LINES-1
    827  7af1		       85 3e		      sta	SET_BANK_RAM	; 3
    828  7af3		       4c 29 f1 	      jmp	StealPart3	; 3 = 10✅  --> 18✅ cycles after check for SEGTIME_SCD_MIN
    829  7af6
    830  7af6							;---------------------------------------------------------------------------
    831  7af6
    832  7af6
      0  7af6					      DEFINE_SUBROUTINE	writePlayerFrame
      1  7af6		       00 0f	   BANK_writePlayerFrame =	_CURRENT_BANK
      2  7af6					      SUBROUTINE
      3  7af6				   writePlayerFrame
    834  7af6
    835  7af6		       a5 80		      lda	Platform
    836  7af8		       29 02		      and	#%10
    837  7afa		       0a		      asl
    838  7afb		       0a		      asl
    839  7afc		       65 c4		      adc	ethnic
    840  7afe		       85 e0		      sta	ethnicity
    841  7b00
    842  7b00
    843  7b00							; todo - compare with last + frame and skip if same
    844  7b00
    845  7b00		       a9 06		      lda	#PLAYER_FRAMES
    846  7b02		       85 3f		      sta	SET_BANK
    847  7b04
    848  7b04		       a5 9c		      lda	animation_delay
    849  7b06		       f0 0f		      beq	getDelay	; FIRST usage
    850  7b08		       c6 9c		      dec	animation_delay
    851  7b0a		       d0 11		      bne	nextAnimation2	; just get shape
    852  7b0c
    853  7b0c		       18	   nextAptr   clc
    854  7b0d		       a5 9a		      lda	animation
    855  7b0f		       69 02		      adc	#2
    856  7b11		       85 9a		      sta	animation
    857  7b13		       90 02		      bcc	ahiok
    858  7b15		       e6 9b		      inc	animation+1
    859  7b17				   ahiok
    860  7b17		       a0 01	   getDelay   ldy	#1
    861  7b19		       b1 9a		      lda	(animation),y
    862  7b1b		       85 9c		      sta	animation_delay
    863  7b1d		       a0 00	   nextAnimation2 ldy	#0
    864  7b1f		       b1 9a		      lda	(animation),y
    865  7b21		       c9 ff		      cmp	#JUMP
    866  7b23		       f0 0d		      beq	aJump
    867  7b25		       c9 fe		      cmp	#FLIP
    868  7b27		       d0 18		      bne	notFlip
    869  7b29
    870  7b29		       a5 a2		      lda	ManLastDirection
    871  7b2b		       49 08		      eor	#%1000
    872  7b2d		       85 a2		      sta	ManLastDirection
    873  7b2f		       4c 0c fb 	      jmp	nextAptr
    874  7b32
    875  7b32							; it's a jump
    876  7b32		       a4 9c	   aJump      ldy	animation_delay	; actually animation ID :)
    877  7b34		       b9 00 f0 	      lda	ANIM_TABLE,y
    878  7b37		       85 9a		      sta	animation
    879  7b39		       b9 01 f0 	      lda	ANIM_TABLE+1,y
    880  7b3c		       85 9b		      sta	animation+1
    881  7b3e		       4c 17 fb 	      jmp	getDelay
    882  7b41
    883  7b41		       a8	   notFlip    tay
    884  7b42
    885  7b42		       a5 a0		      lda	ManDrawY
    886  7b44		       30 44		      bmi	SkipFrameCopy
    887  7b46		       85 df		      sta	bank	; character line (and hence bank) of player position
    888  7b48		       85 3e		      sta	SET_BANK_RAM
    889  7b4a
    890  7b4a							; Now we have the frame #, we can see if that frame has already been drawn into
    891  7b4a							; the frame buffer of the relevant bank. If it has, then we don't need to repeat
    892  7b4a							; and can save the enormous cost of frame copying...
    893  7b4a
    894  7b4a		       cc f9 f3 	      cpy	ExistingFrame	; optimize - don't draw if same frame
    895  7b4d		       f0 3b		      beq	SkipFrameCopy
    896  7b4f		       8c f9 f7 	      sty	ExistingFrame + RAM_WRITE
    897  7b52
    898  7b52		       a9 06		      lda	#PLAYER_FRAMES
    899  7b54		       85 3f		      sta	SET_BANK
    900  7b56		       b9 38 f5 	      lda	FRAME_PTR_LO,y
    901  7b59		       85 db		      sta	frame_ptr
    902  7b5b		       b9 4f f5 	      lda	FRAME_PTR_HI,y
    903  7b5e		       85 dc		      sta	frame_ptr+1
    904  7b60
    905  7b60		       b9 66 f5 	      lda	COLOUR_PTR_LO,y
    906  7b63		       85 dd		      sta	colour_ptr
    907  7b65		       b9 7d f5 	      lda	COLOUR_PTR_HI,y
    908  7b68		       85 de		      sta	colour_ptr+1
    909  7b6a
    910  7b6a
    911  7b6a
    912  7b6a		       a0 17		      ldy	#LINES_PER_CHAR-1
    913  7b6c		       18		      clc
    914  7b6d				   CopySpriteToBank		; 408
    915  7b6d
    916  7b6d							; The colours for the sprites are copied to the row bank's colour data. The frames contain
    917  7b6d							; colour *indexes*. These indexes are modified by the *base* which indicates both the
    918  7b6d							; system NTSC/PAL along with the "visual identity" (i.e., colour/race). That is used to
    919  7b6d							; lookup a colour conversion which FINALLY gives us the correct colour to use for the line.
    920  7b6d
    921  7b6d							; ethnicity * 16 + PALNTSC * 8
    922  7b6d
    923  7b6d		       a9 06		      lda	#PLAYER_FRAMES
    924  7b6f		       85 3f		      sta	SET_BANK
    925  7b71
    926  7b71		       b1 dd		      lda	(colour_ptr),y
    927  7b73		       65 e0		      adc	ethnicity	; colour base
    928  7b75		       aa		      tax
    929  7b76		       b1 db		      lda	(frame_ptr),y
    930  7b78		       48		      pha
    931  7b79		       a5 df		      lda	bank
    932  7b7b		       85 3e		      sta	SET_BANK_RAM
    933  7b7d		       bd d5 f2 	      lda	EthnicityColourPalette,x
    934  7b80		       99 65 f7 	      sta	PLAYER0_COLOUR+RAM_WRITE,y
    935  7b83		       68		      pla
    936  7b84		       99 4d f7 	      sta	PLAYER0_SHAPE+RAM_WRITE,y
    937  7b87		       88		      dey
    938  7b88		       10 e3		      bpl	CopySpriteToBank
    939  7b8a
    940  7b8a				   skipOffscreen
    941  7b8a		       60	   SkipFrameCopy rts
    942  7b8b
    943  7b8b							;---------------------------------------------------------------------------
    944  7b8b
    945  7b8b							;    DEFINE_SUBROUTINE DrawFullScreenMain ;=2484[-89]
    946  7b8b
    947  7b8b							; Check the screen for all those characters that need to be redrawn
    948  7b8b							; Just copies the mxn grid from the board to a DrawFlags array.  If the entry in
    949  7b8b							; the drawflags array is different to the ScreenBuffer array entry, then the
    950  7b8b							; screenbuffer will need redrawing.
    951  7b8b
    952  7b8b							; @59✅
    953  7b8b
    954  7b8b				   CopyRow2
    955  7b8b
    956  7b8b							;    IF MULTI_BANK_BOARD = YES
    957  7b8b							;		  lda BDF_BoardBank		  ; 3
    958  7b8b							;    ELSE
    959  7b8b		       a9 0d		      lda	#BANK_BOARD	; 2	 saves 5*8 = 40 cyles
    960  7b8d							;    ENDIF
    961  7b8d		       85 3e		      sta	SET_BANK_RAM	; 3
    962  7b8f		       b3 df		      lax	(BDF_BoardAddress),y	; 5
    963  7b91		       9a		      txs		; 2
    964  7b92		       b3 e1		      lax	(BDF_BoardAddress2),y	; 5 = 17✅
    965  7b94
    966  7b94		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    967  7b96		       85 3e		      sta	SET_BANK_RAM	; 3
    968  7b98		       bd dc f1 	      lda	CharReplacement,x	; 4
    969  7b9b		       91 dd		      sta	(BDF_DrawFlagAddress2),y	; 6
    970  7b9d		       ba		      tsx		; 2
    971  7b9e		       bd dc f1 	      lda	CharReplacement,x	; 4
    972  7ba1		       91 db		      sta	(BDF_DrawFlagAddress),y	; 6 = 27 @44✅
    973  7ba3
    974  7ba3		       88		      dey		; 2
    975  7ba4		       10 e5		      bpl	CopyRow2	; 2/3 @48 (-1)
    976  7ba6
      0  7ba6					      CHECKPAGEX	CopyRow2, "CopyRow2 in BANK_FIXED"
      9  7ba6					      LIST	ON
    978  7ba6
    979  7ba6							; cost = 5 (rows) x 48 - 1 = 239
    980  7ba6							; @ (59) + 239 = @298✅
    981  7ba6
    982  7ba6		       a7 e4		      lax	DHS_Line	; 3
    983  7ba8		       f0 07		      beq	.exitCopy	; 2/3= 5/6
    984  7baa
    985  7baa		       a0 0a		      ldy	#BANK_DrawScreenRowPreparation	; 2
    986  7bac		       84 3f		      sty	SET_BANK	; 3
    987  7bae		       4c 73 f3 	      jmp	DrawScreenRowPreparation	; 3 = 8
    988  7bb1							; @298+8+5 = @311✅
    989  7bb1
    990  7bb1
    991  7bb1							; total: (244[-5]+5)*8 + 60[-7]*7 + 1 + 11 = 2424[-89]
    992  7bb1
    993  7bb1
      0  7bb1					      CHECKPAGEX	CopyRow2, "CopyRow2 in BANK_FIXED.asm"
      9  7bb1					      LIST	ON
    995  7bb1
    996  7bb1		       a6 e5	   .exitCopy  ldx	DHS_Stack	; 3
    997  7bb3		       9a		      txs		; 2
    998  7bb4
    999  7bb4							; fall through
   1000  7bb4
      0  7bb4					      DEFINE_SUBROUTINE	BuildDrawStack	; @31✅
      1  7bb4		       00 0f	   BANK_BuildDrawStack =	_CURRENT_BANK
      2  7bb4					      SUBROUTINE
      3  7bb4				   BuildDrawStack
   1002  7bb4
   1003  7bb4		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
   1004  7bb6		       85 3e		      sta	SET_BANK_RAM	; 3
   1005  7bb8		       4c f1 f0 	      jmp	DrawStackUpdate	; 3
   1006  7bbb
   1007  7bbb							; => @39 at DrawStackUpdate
   1008  7bbb
   1009  7bbb							;---------------------------------------------------------------------------
   1010  7bbb
      0  7bbb					      DEFINE_SUBROUTINE	DrawAIntoStack	; @31✅
      1  7bbb		       00 0f	   BANK_DrawAIntoStack =	_CURRENT_BANK
      2  7bbb					      SUBROUTINE
      3  7bbb				   DrawAIntoStack
   1012  7bbb
   1013  7bbb		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
   1014  7bbd		       85 3e		      sta	SET_BANK_RAM	; 3
   1015  7bbf		       4c 29 f1 	      jmp	DrawIntoStack	; 3
   1016  7bc2
   1017  7bc2							; ==>39✅ @DrawIntoStack
   1018  7bc2
   1019  7bc2							;---------------------------------------------------------------------------
   1020  7bc2
   1021  7bc2
      0  7bc2					      DEFINE_SUBROUTINE	Reset
      1  7bc2		       00 0f	   BANK_Reset =	_CURRENT_BANK
      2  7bc2					      SUBROUTINE
      3  7bc2				   Reset
   1023  7bc2
      0  7bc2					      CLEAN_START
      1  7bc2		       78		      sei
      2  7bc3		       d8		      cld
      3  7bc4
      4  7bc4		       a2 00		      ldx	#0
      5  7bc6		       8a		      txa
      6  7bc7		       a8		      tay
      7  7bc8		       ca	   .CLEAR_STACK dex
      8  7bc9		       9a		      txs
      9  7bca		       48		      pha
     10  7bcb		       d0 fb		      bne	.CLEAR_STACK
     11  7bcd
   1025  7bcd
   1026  7bcd							;lda #2
   1027  7bcd							;sta VSYNC
   1028  7bcd							;lda #%01000010		  ; bit6 is not required
   1029  7bcd							;sta VBLANK			  ; end of screen - enter blanking
   1030  7bcd
   1031  7bcd							; Scoring bank is copied once (not per game, not per level...)
   1032  7bcd							; otherwise non-SaveKey high score gets zapped
   1033  7bcd
   1034  7bcd		       a2 02		      ldx	#ROM_SHADOW_OF_BANK_SCORING
   1035  7bcf		       a0 09		      ldy	#BANK_SCORING
   1036  7bd1		       20 35 fd 	      jsr	CopyROM2RAM_F000
   1037  7bd4
   1038  7bd4				   Restart		; go here on RESET + SELECT
   1039  7bd4
   1040  7bd4							; breakpoint was not hit/detected!!!
   1041  7bd4
      0  7bd4					      DEFINE_SUBROUTINE	Title
      1  7bd4		       00 0f	   BANK_Title =	_CURRENT_BANK
      2  7bd4					      SUBROUTINE
      3  7bd4				   Title
   1043  7bd4		       a2 ff		      ldx	#$ff	; adjust stack pointer after RESET + SELECT
   1044  7bd6		       9a		      txs
   1045  7bd7
   1046  7bd7							; temporary vars from title screen are used to init level
   1047  7bd7		       a9 03		      lda	#BANK_Cart_Init	; 2
   1048  7bd9		       85 3f		      sta	SET_BANK	; 3
   1049  7bdb		       20 02 f2 	      jsr	Cart_Init	; 6+x
   1050  7bde
   1051  7bde
   1052  7bde							;---------------------------------------------------------------------------
   1053  7bde
   1054  7bde
   1055  7bde		       f0 00	   SEGMENT_DECODE_LEVEL_SHADOW =	$F000	; if not = $F000, this will cause an assertion failure
   1056  7bde
   1057  7bde		       a2 03		      ldx	#BANK_DECODE_LEVEL_SHADOW
   1058  7be0		       a0 0a		      ldy	#BANK_DECODE_LEVEL
   1059  7be2		       20 35 fd 	      jsr	CopyROM2RAM_F000
   1060  7be5
   1061  7be5
   1062  7be5							;---------------------------------------------------------------------------
   1063  7be5							; Once-only game initialisation goes here...
   1064  7be5							; now we have two players so things get a bit tricky
   1065  7be5
   1066  7be5		       a9 09		      lda	#BANK_SCORING
   1067  7be7		       85 3e		      sta	SET_BANK_RAM
   1068  7be9		       20 63 f3 	      jsr	GameInitialise
   1069  7bec
   1070  7bec
   1071  7bec							;---------------------------------------------------------------------------
   1072  7bec
------- FILE sound/intro1_init.asm LEVEL 3 PASS 3
      0  7bec					      include	"sound/intro1_init.asm"
      1  7bec							; TIATracker music player
      2  7bec							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7bec							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7bec							; Email: andre.wichmann@gmx.de
      5  7bec							;
      6  7bec							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7bec							; you may not use this file except in compliance with the License.
      8  7bec							; You may obtain a copy of the License at
      9  7bec							;
     10  7bec							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7bec							;
     12  7bec							; Unless required by applicable law or agreed to in writing, software
     13  7bec							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7bec							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7bec							; See the License for the specific language governing permissions and
     16  7bec							; limitations under the License.
     17  7bec
     18  7bec							; Song author: 
     19  7bec							; Song name: 
     20  7bec
     21  7bec							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7bec
     23  7bec							; =====================================================================
     24  7bec							; Initialize music.
     25  7bec							; Set tt_cur_pat_index_c0/1 to the indexes of the first patterns from
     26  7bec							; tt_SequenceTable for each channel.
     27  7bec							; Set tt_timer and tt_cur_note_index_c0/1 to 0.
     28  7bec							; All other variables can start with any value.
     29  7bec							; =====================================================================
     30  7bec		       a9 00		      lda	#0
     31  7bee		       85 d1		      sta	tt_cur_pat_index_c0
     32  7bf0		       a9 05		      lda	#5
     33  7bf2		       85 d2		      sta	tt_cur_pat_index_c1
     34  7bf4							; the rest should be 0 already from startup code. If not,
     35  7bf4							; set the following variables to 0 manually:
     36  7bf4							; - tt_timer
     37  7bf4							; - tt_cur_pat_index_c0
     38  7bf4							; - tt_cur_pat_index_c1
     39  7bf4							; - tt_cur_note_index_c0
     40  7bf4							; - tt_cur_note_index_c1
     41  7bf4
------- FILE BANK_FIXED.asm
   1074  7bf4
      0  7bf4					      SET_PLATFORM
      1  7bf4
      2  7bf4
      3  7bf4
      4  7bf4
      5  7bf4		       ad 82 02 	      lda	SWCHB
      6  7bf7		       2a		      rol
      7  7bf8		       2a		      rol
      8  7bf9		       2a		      rol
      9  7bfa		       29 03		      and	#%11
     10  7bfc		       49 02		      eor	#PAL
     11  7bfe		       85 80		      sta	Platform
   1076  7c00
   1077  7c00		       a9 07		      lda	#BANK_TitleScreen
   1078  7c02		       85 3f		      sta	SET_BANK
   1079  7c04		       20 08 f0 	      jsr	TitleSequence
   1080  7c07
   1081  7c07		       4c 27 fc 	      jmp	FirstLevel
   1082  7c0a
   1083  7c0a				   RestartLevelNextPlayer
   1084  7c0a
   1085  7c0a		       a9 03		      lda	#BANK_SwapPlayersGeneric
   1086  7c0c		       85 3f		      sta	SET_BANK
   1087  7c0e		       20 47 f2 	      jsr	SwapPlayersGeneric
   1088  7c11
   1089  7c11
   1090  7c11		       a2 08		      ldx	#BANK_LevelScreen
   1091  7c13		       86 3f		      stx	SET_BANK
   1092  7c15
   1093  7c15		       a9 01		      lda	#1
   1094  7c17		       d0 14		      bne	selectLeveler
   1095  7c19
      0  7c19					      DEFINE_SUBROUTINE	NextLevelLevel
      1  7c19		       00 0f	   BANK_NextLevelLevel =	_CURRENT_BANK
      2  7c19					      SUBROUTINE
      3  7c19				   NextLevelLevel
   1097  7c19
   1098  7c19		       a2 03		      ldx	#BANK_GenerateHighScoreCode
   1099  7c1b		       86 3f		      stx	SET_BANK
   1100  7c1d		       20 3b f4 	      jsr	GenerateHighScoreCode
   1101  7c20
   1102  7c20		       a2 09		      ldx	#BANK_xLevelScreen
   1103  7c22		       86 3f		      stx	SET_BANK
   1104  7c24		       20 3b f1 	      jsr	xLevelScreen
   1105  7c27
   1106  7c27				   FirstLevel
   1107  7c27		       a2 08		      ldx	#BANK_LevelScreen
   1108  7c29		       86 3f		      stx	SET_BANK
   1109  7c2b
   1110  7c2b		       a9 00		      lda	#0
   1111  7c2d		       20 53 f0    selectLeveler jsr	LevelScreen
   1112  7c30
   1113  7c30							; Initialise all in-game variables; those that must be re-initialised at the start of each level,
   1114  7c30							; including those for general systems function. But NOT those which do not need re-initialising between
   1115  7c30							; levels.
   1116  7c30		       a9 03		      lda	#BANK_LevelInit	; 2
   1117  7c32		       85 3f		      sta	SET_BANK	; 3
   1118  7c34		       20 8f f2 	      jsr	LevelInit	; 6+x
   1119  7c37
   1120  7c37
   1121  7c37							; Setup the various digit and display pointers
   1122  7c37							; Grab current player's score/level from backup
   1123  7c37
   1124  7c37		       a9 09		      lda	#BANK_SCORING
   1125  7c39		       85 3e		      sta	SET_BANK_RAM
   1126  7c3b		       20 83 f2 	      jsr	GeneralScoringSetups
   1127  7c3e
   1128  7c3e							; copy the screen draw ROM shadow to RAM
   1129  7c3e
   1130  7c3e		       a0 07		      ldy	#SCREEN_LINES-1
   1131  7c40		       a2 00	   CopyScreenBanks ldx	#ROM_SHADOW_OF_RAMBANK_CODE
   1132  7c42		       20 35 fd 	      jsr	CopyROM2RAM_F000	; copy draw ROMShadow to RAM
   1133  7c45		       20 95 f0 	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
   1134  7c48		       88		      dey
   1135  7c49		       10 f5		      bpl	CopyScreenBanks
   1136  7c4b
   1137  7c4b		       a2 01		      ldx	#ROM_SHADOW_OF_BANK_DRAW_BUFFERS
   1138  7c4d		       a0 08		      ldy	#BANK_DRAW_BUFFERS
   1139  7c4f		       20 61 f0 	      jsr	CopyROMShadowToRAM_F000
   1140  7c52
   1141  7c52
   1142  7c52		       a9 04		      lda	#BANK_LevelInfoLO
   1143  7c54		       85 3f		      sta	SET_BANK
   1144  7c56		       20 26 f2 	      jsr	GetLevelAddress
   1145  7c59
   1146  7c59		       a9 0a		      lda	#BANK_DECODE_LEVEL
   1147  7c5b		       85 3e		      sta	SET_BANK_RAM
   1148  7c5d		       20 95 f0 	      jsr	UnpackLevel
   1149  7c60
   1150  7c60		       a9 20		      lda	#SIZE_BOARD_X
   1151  7c62		       85 94		      sta	BoardLimit_Width
   1152  7c64		       a9 20		      lda	#SIZE_BOARD_Y
   1153  7c66		       85 95		      sta	BoardLimit_Height
   1154  7c68
   1155  7c68							; Setup player animation and scroll limits.
   1156  7c68							; Mangle the board colours based on level
   1157  7c68
   1158  7c68		       a9 03		      lda	#BANK_CreateCreatures	; 2
   1159  7c6a		       85 3f		      sta	SET_BANK	; 3
   1160  7c6c		       20 50 f2 	      jsr	CreateCreatures	; 6+x
   1161  7c6f
   1162  7c6f							;---------------------------------------------------------------------------
   1163  7c6f
   1164  7c6f					      IF	WAIT_FOR_INITIAL_DRAW
   1165  7c6f		       a9 02		      lda	#%10
   1166  7c71		       85 ae		      sta	blankState
   1167  7c73					      ENDIF
   1168  7c73
   1169  7c73		       a9 03		      lda	#BANK_Resync	; 2
   1170  7c75		       85 3f		      sta	SET_BANK	; 3
   1171  7c77		       20 bf f2 	      jsr	Resync	; 6+x
   1172  7c7a
   1173  7c7a				   NewFrameStart
   1174  7c7a
   1175  7c7a		       24 c1		      bit	NextLevelTrigger
   1176  7c7c		       70 8c		      bvs	RestartLevelNextPlayer	; loss of life (=SELECT)
   1177  7c7e		       10 99		      bpl	NextLevelLevel	; game-triggered next level (=RESET/COMPLETED)
   1178  7c80
   1179  7c80							; Note: VSYNC must NOT be on when starting a new level! Else you get annoying TV signals.
   1180  7c80
   1181  7c80		       a9 0e		      lda	#%1110	; VSYNC ON
   1182  7c82		       85 42	   .loopVSync sta	WSYNC
   1183  7c84		       85 40		      sta	VSYNC
   1184  7c86		       4a		      lsr
   1185  7c87		       d0 f9		      bne	.loopVSync	; branch until VYSNC has been reset
   1186  7c89
   1187  7c89							; moved *after* the loop since this allows to *increase* timer values by 1!
   1188  7c89
   1189  7c89		       a6 80		      ldx	Platform
   1190  7c8b		       bc f6 fc 	      ldy	VBlankTime,x
   1191  7c8e		       8c 96 02 	      sty	TIM64T
   1192  7c91
   1193  7c91		       a9 0a		      lda	#BANK_SoundFX
   1194  7c93		       85 3f		      sta	SET_BANK
   1195  7c95		       20 13 f4 	      jsr	SoundFX
   1196  7c98
   1197  7c98		       20 a4 fa 	      jsr	StealCharDraw	; 6 NOTE THIS IS THE *ONLY* AREA BIG ENOUGH FOR > 30 INTIM NEEDS
   1198  7c9b
   1199  7c9b							;---------------------------------------------------------------------------
   1200  7c9b
   1201  7c9b		       a9 09		      lda	#BANK_SCORING	; 2
   1202  7c9d		       85 3e		      sta	SET_BANK_RAM	; 3
   1203  7c9f		       20 e8 f1 	      jsr	DrawDigits	; 6 = 11
   1204  7ca2
   1205  7ca2							;---------------------------------------------------------------------------
   1206  7ca2							; A 42-cycle timing window in the screen draw code.  Perform any general
   1207  7ca2							; per-frame code here, provided it takes exactly 42 cycles to execute.
   1208  7ca2							; TJ: Well, not exactly 42 cycles, but it works! :)
   1209  7ca2
   1210  7ca2		       a9 00		      lda	#BANK_SCREENMARKII1	; 2
   1211  7ca4		       85 3f		      sta	SET_BANK	; testing
   1212  7ca6		       85 3e		      sta	SET_BANK_RAM	; 3
   1213  7ca8		       20 00 f0 	      jsr	DrawTheScreen	; 6	 @57 from RAM, no less!!
   1214  7cab							;	 @66
   1215  7cab		       a9 03		      lda	#BANK_PostScreenCleanup	; 2
   1216  7cad		       85 3f		      sta	SET_BANK	; 3
   1217  7caf		       20 35 f3 	      jsr	PostScreenCleanup	; 6+x
   1218  7cb2
   1219  7cb2		       a9 00		      lda	#BANK_SelfModDrawPlayers	; 2
   1220  7cb4		       85 3f		      sta	SET_BANK	; 3
   1221  7cb6		       20 84 f2 	      jsr	SelfModDrawPlayers	; 6+x
   1222  7cb9
   1223  7cb9				   SkipSc
   1224  7cb9
   1225  7cb9
   1226  7cb9		       a5 cc		      lda	FadeOutComplete
   1227  7cbb		       30 0e		      bmi	FadeInPossible
   1228  7cbd		       c6 cd		      dec	fadeslow
   1229  7cbf		       10 20		      bpl	FadeNotRequired
   1230  7cc1		       a9 02		      lda	#2
   1231  7cc3		       85 cd		      sta	fadeslow
   1232  7cc5		       20 5e fd 	      jsr	FadeOut
   1233  7cc8		       4c e1 fc 	      jmp	FadeNotRequired
   1234  7ccb				   FadeInPossible
   1235  7ccb
   1236  7ccb		       a9 00		      lda	#0
   1237  7ccd		       85 3e		      sta	SET_BANK_RAM
   1238  7ccf		       20 bd f3 	      jsr	FixColours
   1239  7cd2
   1240  7cd2		       a5 cb		      lda	FadeComplete
   1241  7cd4		       f0 0b		      beq	FadeNotRequired
   1242  7cd6
   1243  7cd6		       c6 cd		      dec	fadeslow
   1244  7cd8		       10 07		      bpl	FadeNotRequired
   1245  7cda		       a9 03		      lda	#3
   1246  7cdc		       85 cd		      sta	fadeslow
   1247  7cde		       20 8a fd 	      jsr	FadeIn
   1248  7ce1				   FadeNotRequired
   1249  7ce1
   1250  7ce1		       20 f6 fa 	      jsr	writePlayerFrame
   1251  7ce4
   1252  7ce4		       a9 09		      lda	#BANK_SCORING
   1253  7ce6		       85 3e		      sta	SET_BANK_RAM
   1254  7ce8		       20 a3 f3 	      jsr	NotchTime
   1255  7ceb
   1256  7ceb		       20 a4 fa 	      jsr	StealCharDraw	; 6
   1257  7cee
   1258  7cee		       ad 84 02    OverscanBD lda	INTIM	;4
   1259  7cf1		       d0 fb		      bne	OverscanBD	;2/3
   1260  7cf3
   1261  7cf3		       4c 7a fc 	      jmp	NewFrameStart
   1262  7cf6				   VBlankTime
   1263  7cf6		       30 30		      .byte.b	VBLANK_TIM_NTSC, VBLANK_TIM_NTSC
   1264  7cf8		       55 55		      .byte.b	VBLANK_TIM_PAL, VBLANK_TIM_PAL
   1265  7cfa
   1266  7cfa							;---------------------------------------------------------------------------
   1267  7cfa
      0  7cfa					      DEFINE_SUBROUTINE	nextLevelMan
      1  7cfa		       00 0f	   BANK_nextLevelMan =	_CURRENT_BANK
      2  7cfa					      SUBROUTINE
      3  7cfa				   nextLevelMan
   1269  7cfa
   1270  7cfa		       a9 0a		      lda	#BANK_EndOfLevel
   1271  7cfc		       85 3f		      sta	SET_BANK
   1272  7cfe		       4c 99 f3 	      jmp	EndOfLevel
   1273  7d01
   1274  7d01
      0  7d01					      DEFINE_SUBROUTINE	switchLevels2
      1  7d01		       00 0f	   BANK_switchLevels2 =	_CURRENT_BANK
      2  7d01					      SUBROUTINE
      3  7d01				   switchLevels2
   1276  7d01
   1277  7d01							; SELECT used, so we want to get back to selection
   1278  7d01
   1279  7d01		       a5 c1		      lda	NextLevelTrigger
   1280  7d03		       09 40		      ora	#$40	; #<(~BIT_NEXTLEVEL)
   1281  7d05		       85 c1		      sta	NextLevelTrigger
   1282  7d07		       60		      rts
   1283  7d08
      0  7d08					      DEFINE_SUBROUTINE	nextLevelMan2
      1  7d08		       00 0f	   BANK_nextLevelMan2 =	_CURRENT_BANK
      2  7d08					      SUBROUTINE
      3  7d08				   nextLevelMan2
   1285  7d08
   1286  7d08		       c6 a9		      dec	DelayEndOfLevel
   1287  7d0a		       d0 3b		      bne	genericRTS
   1288  7d0c
   1289  7d0c		       a9 00		      lda	#0
   1290  7d0e		       85 cc		      sta	FadeOutComplete	; start fading OUT
   1291  7d10		       a9 00		      lda	#0
   1292  7d12		       85 cb		      sta	FadeComplete	; stop fade IN
   1293  7d14
   1294  7d14		       a9 05		      lda	#5
   1295  7d16		       85 a9		      sta	DelayEndOfLevel
   1296  7d18
   1297  7d18		       a9 0d		      lda	#MANMODE_NEXTLEVEL3
   1298  7d1a		       85 a1		      sta	ManMode
   1299  7d1c							;		  jmp nextLevelMan3
   1300  7d1c							;		  rts
   1301  7d1c
   1302  7d1c
      0  7d1c					      DEFINE_SUBROUTINE	nextLevelMan3
      1  7d1c		       00 0f	   BANK_nextLevelMan3 =	_CURRENT_BANK
      2  7d1c					      SUBROUTINE
      3  7d1c				   nextLevelMan3
   1304  7d1c
   1305  7d1c		       c6 a9		      dec	DelayEndOfLevel
   1306  7d1e		       d0 27		      bne	genericRTS
   1307  7d20
   1308  7d20		       a9 09		      lda	#MANMODE_SWITCH
   1309  7d22		       85 a1		      sta	ManMode
   1310  7d24
      0  7d24					      DEFINE_SUBROUTINE	switchLevels
      1  7d24		       00 0f	   BANK_switchLevels =	_CURRENT_BANK
      2  7d24					      SUBROUTINE
      3  7d24				   switchLevels
   1312  7d24
   1313  7d24							; Now do the actual switching
   1314  7d24
   1315  7d24							;		 lda NextLevelTrigger
   1316  7d24							;		 and #<(~BIT_NEXTLEVEL)
   1317  7d24		       a9 00		      lda	#$00
   1318  7d26		       85 c1		      sta	NextLevelTrigger
   1319  7d28
   1320  7d28							; Next level is due. Point to the next level, but if we're at the end of playable levels,
   1321  7d28							; then increment the level number. This is completely circular, so we eventually wrap
   1322  7d28							; the level back to 0 and start afresh.
   1323  7d28
   1324  7d28		       e6 b1		      inc	levelX
   1325  7d2a							;		  bne noHiLev
   1326  7d2a							;		  inc levelX+1
   1327  7d2a							;noHiLev
   1328  7d2a							;		  lda levelX+1
   1329  7d2a							;		  cmp #>MAX_LEVEL_NUMBER
   1330  7d2a							;		  bcc .level_ok
   1331  7d2a
   1332  7d2a		       a5 b1		      lda	levelX
   1333  7d2c		       c9 26		      cmp	#<MAX_LEVEL_NUMBER
   1334  7d2e		       90 04		      bcc	.level_ok
   1335  7d30
   1336  7d30		       a9 00		      lda	#0
   1337  7d32		       85 b1		      sta	levelX
   1338  7d34							;		  sta levelX+1
   1339  7d34				   .level_ok
   1340  7d34		       60		      rts
   1341  7d35
   1342  7d35							;---------------------------------------------------------------------------
   1343  7d35
   1344  7d35
      0  7d35					      DEFINE_SUBROUTINE	CopyROM2RAM_F000
      1  7d35		       00 0f	   BANK_CopyROM2RAM_F000 =	_CURRENT_BANK
      2  7d35					      SUBROUTINE
      3  7d35				   CopyROM2RAM_F000
   1346  7d35
   1347  7d35		       a9 0a		      lda	#BANK_CopyROMShadowToRAM
   1348  7d37		       85 3f		      sta	SET_BANK
   1349  7d39		       85 be		      sta	ROM_Bank
   1350  7d3b		       4c 61 f0 	      jmp	CopyROMShadowToRAM_F000
   1351  7d3e
   1352  7d3e
   1353  7d3e							;---------------------------------------------------------------------------
   1354  7d3e
      0  7d3e					      DEFINE_SUBROUTINE	RegisterTarget
      1  7d3e		       00 0f	   BANK_RegisterTarget =	_CURRENT_BANK
      2  7d3e					      SUBROUTINE
      3  7d3e				   RegisterTarget
   1356  7d3e
   1357  7d3e		       f8		      sed
   1358  7d3f		       18		      clc
   1359  7d40		       a5 b4		      lda	BCD_targetsRequired
   1360  7d42		       69 01		      adc	#1
   1361  7d44		       85 b4		      sta	BCD_targetsRequired
   1362  7d46		       d8		      cld
   1363  7d47		       60	   genericRTS rts
   1364  7d48
      0  7d48					      DEFINE_SUBROUTINE	DeRegisterTarget
      1  7d48		       00 0f	   BANK_DeRegisterTarget =	_CURRENT_BANK
      2  7d48					      SUBROUTINE
      3  7d48				   DeRegisterTarget
   1366  7d48
   1367  7d48		       f8		      sed
   1368  7d49		       38		      sec
   1369  7d4a		       a5 b4		      lda	BCD_targetsRequired
   1370  7d4c		       e9 01		      sbc	#1
   1371  7d4e		       85 b4		      sta	BCD_targetsRequired
   1372  7d50		       d8		      cld
   1373  7d51		       60		      rts
   1374  7d52
   1375  7d52
      0  7d52					      DEFINE_SUBROUTINE	Random
      1  7d52		       00 0f	   BANK_Random =	_CURRENT_BANK
      2  7d52					      SUBROUTINE
      3  7d52				   Random
      0  7d52					      NEXT_RANDOM
      1  7d52
      2  7d52		       a5 c7		      lda	rnd
      3  7d54		       4a		      lsr
      4  7d55					      IFCONST	rndHi
      5  7d55		       66 c6		      ror	rndHi
      6  7d57					      ENDIF
      7  7d57		       90 02		      bcc	.skipEOR
      8  7d59		       49 b4		      eor	#RND_EOR_VAL
      9  7d5b				   .skipEOR
     10  7d5b		       85 c7		      sta	rnd
   1378  7d5d		       60		      rts
   1379  7d5e
   1380  7d5e
      0  7d5e					      DEFINE_SUBROUTINE	FadeOut
      1  7d5e		       00 0f	   BANK_FadeOut =	_CURRENT_BANK
      2  7d5e					      SUBROUTINE
      3  7d5e				   FadeOut
   1382  7d5e
   1383  7d5e		       a0 07		      ldy	#SCREEN_LINES-1
   1384  7d60		       84 3e	   ZeroColours sty	SET_BANK_RAM
   1385  7d62
   1386  7d62		       af 1d f0 	      lax	Colour_A_Actual
   1387  7d65		       29 0f		      and	#$F
   1388  7d67		       f0 02		      beq	AisZero
   1389  7d69		       ca		      dex
   1390  7d6a		       8a		      txa
   1391  7d6b		       8d 1d f4    AisZero    sta	Colour_A_Actual+RAM_WRITE
   1392  7d6e
   1393  7d6e		       af 86 f0 	      lax	Colour_B_Actual
   1394  7d71		       29 0f		      and	#$F
   1395  7d73		       f0 02		      beq	BisZero
   1396  7d75		       ca		      dex
   1397  7d76		       8a		      txa
   1398  7d77		       8d 86 f4    BisZero    sta	Colour_B_Actual+RAM_WRITE
   1399  7d7a
   1400  7d7a		       af 53 f0 	      lax	Colour_C_Actual
   1401  7d7d		       29 0f		      and	#$F
   1402  7d7f		       f0 02		      beq	CisZero
   1403  7d81		       ca		      dex
   1404  7d82		       8a		      txa
   1405  7d83		       8d 53 f4    CisZero    sta	Colour_C_Actual+RAM_WRITE
   1406  7d86
   1407  7d86		       88		      dey
   1408  7d87		       10 d7		      bpl	ZeroColours
   1409  7d89		       60		      rts
   1410  7d8a
   1411  7d8a
   1412  7d8a
   1413  7d8a
      0  7d8a					      DEFINE_SUBROUTINE	FadeIn
      1  7d8a		       00 0f	   BANK_FadeIn =	_CURRENT_BANK
      2  7d8a					      SUBROUTINE
      3  7d8a				   FadeIn
   1415  7d8a
   1416  7d8a		       a9 00		      lda	#0
   1417  7d8c		       85 cb		      sta	FadeComplete
   1418  7d8e
   1419  7d8e		       a0 07		      ldy	#SCREEN_LINES-1
   1420  7d90		       84 3e	   CopyAcols  sty	SET_BANK_RAM
   1421  7d92
   1422  7d92		       af 1d f0 	      lax	Colour_A_Actual
   1423  7d95		       d0 0a		      bne	notFirstA
   1424  7d97		       ad fb f3 	      lda	Colour_A
   1425  7d9a		       29 f0		      and	#$F0
   1426  7d9c		       aa		      tax
   1427  7d9d		       e8		      inx
   1428  7d9e		       4c a7 fd 	      jmp	FirstA
   1429  7da1		       ec fb f3    notFirstA  cpx	Colour_A
   1430  7da4		       f0 06		      beq	AOK
   1431  7da6		       e8		      inx
   1432  7da7		       8e 1d f4    FirstA     stx	Colour_A_Actual+RAM_WRITE
   1433  7daa		       e6 cb		      inc	FadeComplete	; NOT complete
   1434  7dac				   AOK
   1435  7dac		       af 86 f0 	      lax	Colour_B_Actual
   1436  7daf		       d0 0a		      bne	notFirstB
   1437  7db1		       ad fc f3 	      lda	Colour_B
   1438  7db4		       29 f0		      and	#$F0
   1439  7db6		       aa		      tax
   1440  7db7		       e8		      inx
   1441  7db8		       4c c1 fd 	      jmp	FirstB
   1442  7dbb		       ec fc f3    notFirstB  cpx	Colour_B
   1443  7dbe		       f0 06		      beq	BOK
   1444  7dc0		       e8		      inx
   1445  7dc1		       8e 86 f4    FirstB     stx	Colour_B_Actual+RAM_WRITE
   1446  7dc4		       e6 cb		      inc	FadeComplete	; NOT complete
   1447  7dc6				   BOK
   1448  7dc6		       af 53 f0 	      lax	Colour_C_Actual
   1449  7dc9		       d0 0a		      bne	notFirstC
   1450  7dcb		       ad fd f3 	      lda	Colour_C
   1451  7dce		       29 f0		      and	#$F0
   1452  7dd0		       aa		      tax
   1453  7dd1		       e8		      inx
   1454  7dd2		       4c db fd 	      jmp	FirstC
   1455  7dd5		       ec fd f3    notFirstC  cpx	Colour_C
   1456  7dd8		       f0 06		      beq	COK
   1457  7dda		       e8		      inx
   1458  7ddb		       8e 53 f4    FirstC     stx	Colour_C_Actual+RAM_WRITE
   1459  7dde		       e6 cb		      inc	FadeComplete	; NOT complete
   1460  7de0				   COK
   1461  7de0
   1462  7de0		       88		      dey
   1463  7de1		       10 ad		      bpl	CopyAcols
   1464  7de3		       60		      rts
   1465  7de4
------- FILE charset/CHARACTERSHAPE_STEEL.asm LEVEL 3 PASS 3
      0  7de4					      include	"charset/CHARACTERSHAPE_STEEL.asm"
      0  7de4					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL", LINES_PER_CHAR
     10  7de4					      LIST	ON
      2  7de4				   CHARACTERSHAPE_STEEL
      3  7de4		       00 88 00 88*	      .byte.b	0,136,0,136,0,34,0,34
      4  7dec		       ff 77 77 ff*	      .byte.b	255,119,119,255,255,221,221,255
      5  7df4		       ff 77 77 ff*	      .byte.b	255,119,119,255,255,221,221,255
      0  7dfc					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL_MIRRORED", LINES_PER_CHAR
 PAGE BREAK INSERTED FOR  CHARACTERSHAPE_STEEL_MIRRORED
 REQUESTED SIZE =  $18
 WASTED SPACE =  $4
 PAGEBREAK LOCATION =  $fe00
     10  7e00					      LIST	ON
      7  7e00				   CHARACTERSHAPE_STEEL_MIRRORED
      8  7e00		       00 11 00 11*	      .byte.b	0,17,0,17,0,68,0,68
      9  7e08		       ff ee ee ff*	      .byte.b	255,238,238,255,255,187,187,255
     10  7e10		       ff ee ee ff*	      .byte.b	255,238,238,255,255,187,187,255
------- FILE BANK_FIXED.asm
   1467  7e18
   1468  7e18
      0  7e18					      DEFINE_SUBROUTINE	CopyColoursToScreenLines
      1  7e18		       00 0f	   BANK_CopyColoursToScreenLines =	_CURRENT_BANK
      2  7e18					      SUBROUTINE
      3  7e18				   CopyColoursToScreenLines
   1470  7e18
   1471  7e18		       a2 07		      ldx	#SCREEN_LINES-1
   1472  7e1a		       86 3e	   setPlat    stx	SET_BANK_RAM
   1473  7e1c		       20 74 f2 	      jsr	DoColours
   1474  7e1f		       ca		      dex
   1475  7e20		       10 f8		      bpl	setPlat
   1476  7e22
   1477  7e22		       a5 be		      lda	ROM_Bank
   1478  7e24		       85 3f		      sta	SET_BANK
   1479  7e26		       60		      rts
   1480  7e27
   1481  7e27							;---------------------------------------------------------------------------
   1482  7e27
   1483  7e27							;include "charset/CHARACTERSHAPE_TARGET.asm"
------- FILE charset/CHARACTERSHAPE_TARGET1.asm LEVEL 3 PASS 3
      0  7e27					      include	"charset/CHARACTERSHAPE_TARGET1.asm"
      0  7e27					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET1", LINES_PER_CHAR
     10  7e27					      LIST	ON
      2  7e27				   CHARACTERSHAPE_TARGET1
      3  7e27		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      4  7e2f		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      5  7e37		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      0  7e3f					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET1_MIRRORED", LINES_PER_CHAR
     10  7e3f					      LIST	ON
      7  7e3f				   CHARACTERSHAPE_TARGET1_MIRRORED
      8  7e3f		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      9  7e47		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
     10  7e4f		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_TARGET3.asm LEVEL 3 PASS 3
      0  7e57					      include	"charset/CHARACTERSHAPE_TARGET3.asm"
      0  7e57					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET3", LINES_PER_CHAR
     10  7e57					      LIST	ON
      2  7e57				   CHARACTERSHAPE_TARGET3
      3  7e57		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      4  7e5f		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      5  7e67		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      0  7e6f					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET3_MIRRORED", LINES_PER_CHAR
     10  7e6f					      LIST	ON
      7  7e6f				   CHARACTERSHAPE_TARGET3_MIRRORED
      8  7e6f		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      9  7e77		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
     10  7e7f		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_TARGET5.asm LEVEL 3 PASS 3
      0  7e87					      include	"charset/CHARACTERSHAPE_TARGET5.asm"
      0  7e87					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET5", LINES_PER_CHAR
     10  7e87					      LIST	ON
      2  7e87				   CHARACTERSHAPE_TARGET5
      3  7e87		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      4  7e8f		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      5  7e97		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      0  7e9f					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET5_MIRRORED", LINES_PER_CHAR
     10  7e9f					      LIST	ON
      7  7e9f				   CHARACTERSHAPE_TARGET5_MIRRORED
      8  7e9f		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      9  7ea7		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
     10  7eaf		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_TARGET7.asm LEVEL 3 PASS 3
      0  7eb7					      include	"charset/CHARACTERSHAPE_TARGET7.asm"
      0  7eb7					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET7", LINES_PER_CHAR
     10  7eb7					      LIST	ON
      2  7eb7				   CHARACTERSHAPE_TARGET7
      3  7eb7		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      4  7ebf		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      5  7ec7		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      0  7ecf					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET7_MIRRORED", LINES_PER_CHAR
     10  7ecf					      LIST	ON
      7  7ecf				   CHARACTERSHAPE_TARGET7_MIRRORED
      8  7ecf		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      9  7ed7		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
     10  7edf		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_RIVET.asm LEVEL 3 PASS 3
      0  7ee7					      include	"charset/CHARACTERSHAPE_RIVET.asm"
      0  7ee7					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_RIVET", LINES_PER_CHAR
     10  7ee7					      LIST	ON
      2  7ee7				   CHARACTERSHAPE_RIVET
      3  7ee7		       00 00 00 00*	      .byte.b	0,0,0,0,51,85,136,102
      4  7eef		       99 ee ff ee*	      .byte.b	153,238,255,238,221,187,119,255
      5  7ef7		       66 77 ff ff*	      .byte.b	102,119,255,255,221,187,102,102
      0  7eff					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_RIVET_MIRRORED", LINES_PER_CHAR
 PAGE BREAK INSERTED FOR  CHARACTERSHAPE_RIVET_MIRRORED
 REQUESTED SIZE =  $18
 WASTED SPACE =  $1
 PAGEBREAK LOCATION =  $ff00
     10  7f00					      LIST	ON
      7  7f00				   CHARACTERSHAPE_RIVET_MIRRORED
      8  7f00		       00 00 00 00*	      .byte.b	0,0,0,0,204,170,17,102
      9  7f08		       99 77 ff 77*	      .byte.b	153,119,255,119,187,221,238,255
     10  7f10		       66 ee ff ff*	      .byte.b	102,238,255,255,187,221,102,102
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_STRIPE.asm LEVEL 3 PASS 3
      0  7f18					      include	"charset/CHARACTERSHAPE_STRIPE.asm"
      0  7f18					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STRIPE", LINES_PER_CHAR
     10  7f18					      LIST	ON
      2  7f18				   CHARACTERSHAPE_STRIPE
      3  7f18		       44 cc 88 99*	      .byte.b	68,204,136,153,17,51,34,102
      4  7f20		       77 ff ee ff*	      .byte.b	119,255,238,255,221,255,187,255
      5  7f28		       44 cc 88 99*	      .byte.b	68,204,136,153,17,51,34,102
      0  7f30					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STRIPE_MIRRORED", LINES_PER_CHAR
     10  7f30					      LIST	ON
      7  7f30				   CHARACTERSHAPE_STRIPE_MIRRORED
      8  7f30		       22 33 11 99*	      .byte.b	34,51,17,153,136,204,68,102
      9  7f38		       ee ff 77 ff*	      .byte.b	238,255,119,255,187,255,221,255
     10  7f40		       22 33 11 99*	      .byte.b	34,51,17,153,136,204,68,102
------- FILE BANK_FIXED.asm
   1490  7f48							;include "charset/CHARACTERSHAPE_SOIL.asm"
------- FILE characterset/character_SOIL.asm LEVEL 3 PASS 3
      0  7f48					      include	"characterset/character_SOIL.asm"
      1  7f48							;    Sokoboo - a Sokoban implementation
      2  7f48							;    using a generic tile-based display engine for the Atari 2600
      3  7f48							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7f48							;
      5  7f48							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7f48							;
      7  7f48							;    Code related to the generic tile-based display engine was developed by
      8  7f48							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7f48							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7f48							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7f48							;
     12  7f48							;    Code related to music and sound effects uses the TIATracker music player
     13  7f48							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7f48							;    directory for Apache licensing details.
     15  7f48							;
     16  7f48							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7f48							;    See the copyright notices in the License directory for a list of level
     18  7f48							;    contributors.
     19  7f48							;
     20  7f48							;    Except where otherwise indicated, this software is released under the
     21  7f48							;    following licensing arrangement...
     22  7f48							;
     23  7f48							;    This program is free software: you can redistribute it and/or modify
     24  7f48							;    it under the terms of the GNU General Public License as published by
     25  7f48							;    the Free Software Foundation, either version 3 of the License, or
     26  7f48							;    (at your option) any later version.
     27  7f48							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7f48
     29  7f48							;    This program is distributed in the hope that it will be useful,
     30  7f48							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7f48							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7f48							;    GNU General Public License for more details.
     33  7f48
      0  7f48					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     10  7f48					      LIST	ON
     35  7f48				   CHARACTERSHAPE_SOIL
     36  7f48				   CHARACTERSHAPE_SOIL_MIRRORED
     37  7f48		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
     38  7f50		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
     39  7f58		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_BOX.asm LEVEL 3 PASS 3
      0  7f60					      include	"charset/CHARACTERSHAPE_BOX.asm"
      0  7f60					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX", LINES_PER_CHAR
     10  7f60					      LIST	ON
      2  7f60				   CHARACTERSHAPE_BOX
      3  7f60		       ff ff 99 99*	      .byte.b	255,255,153,153,153,153,0,0
      4  7f68		       ff ff 99 99*	      .byte.b	255,255,153,153,153,153,0,0
      5  7f70		       00 00 00 00*	      .byte.b	0,0,0,0,0,255,255,0
      0  7f78					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_MIRRORED", LINES_PER_CHAR
     10  7f78					      LIST	ON
      7  7f78				   CHARACTERSHAPE_BOX_MIRRORED
      8  7f78		       ff ff 99 99*	      .byte.b	255,255,153,153,153,153,0,0
      9  7f80		       ff ff 99 99*	      .byte.b	255,255,153,153,153,153,0,0
     10  7f88		       00 00 00 00*	      .byte.b	0,0,0,0,0,255,255,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_BOX_ON_TARGET.asm LEVEL 3 PASS 3
      0  7f90					      include	"charset/CHARACTERSHAPE_BOX_ON_TARGET.asm"
      0  7f90					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET", LINES_PER_CHAR
     10  7f90					      LIST	ON
      2  7f90				   CHARACTERSHAPE_BOX_ON_TARGET
      3  7f90		       ff ff 99 99*	      .byte.b	255,255,153,153,153,153,0,0
      4  7f98		       ff ff ff ff*	      .byte.b	255,255,255,255,255,153,0,0
      5  7fa0		       00 00 66 66*	      .byte.b	0,0,102,102,102,255,255,0
      0  7fa8					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED", LINES_PER_CHAR
     10  7fa8					      LIST	ON
      7  7fa8				   CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
      8  7fa8		       ff ff 99 99*	      .byte.b	255,255,153,153,153,153,0,0
      9  7fb0		       ff ff ff ff*	      .byte.b	255,255,255,255,255,153,0,0
     10  7fb8		       00 00 66 66*	      .byte.b	0,0,102,102,102,255,255,0
------- FILE BANK_FIXED.asm
   1494  7fc0							;include "charset/CHARACTERSHAPE_BOX_ON_TARGET2.asm"
------- FILE charset/CHARACTERSHAPE_WALL.asm LEVEL 3 PASS 3
      0  7fc0					      include	"charset/CHARACTERSHAPE_WALL.asm"
      0  7fc0					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL", LINES_PER_CHAR
     10  7fc0					      LIST	ON
      2  7fc0				   CHARACTERSHAPE_WALL
      3  7fc0		       77 77 77 00*	      .byte.b	119,119,119,0,221,221,221,0
      4  7fc8		       77 77 77 00*	      .byte.b	119,119,119,0,221,221,221,0
      5  7fd0		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,255
      0  7fd8					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL_MIRRORED", LINES_PER_CHAR
     10  7fd8					      LIST	ON
      7  7fd8				   CHARACTERSHAPE_WALL_MIRRORED
      8  7fd8		       ee ee ee 00*	      .byte.b	238,238,238,0,187,187,187,0
      9  7fe0		       ee ee ee 00*	      .byte.b	238,238,238,0,187,187,187,0
     10  7fe8		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,255
------- FILE BANK_FIXED.asm
   1496  7ff0
   1497  7ff0				  -	      if	DIGITS
   1498  7ff0				  -	      include	"characterset/character_9.asm"
   1499  7ff0				  -	      include	"characterset/character_8.asm"
   1500  7ff0				  -	      include	"characterset/character_7.asm"
   1501  7ff0				  -	      include	"characterset/character_6.asm"
   1502  7ff0				  -	      include	"characterset/character_5.asm"
   1503  7ff0				  -	      include	"characterset/character_4.asm"
   1504  7ff0				  -	      include	"characterset/character_3.asm"
   1505  7ff0				  -	      include	"characterset/character_2.asm"
   1506  7ff0				  -	      include	"characterset/character_1.asm"
   1507  7ff0				  -	      include	"characterset/character_0.asm"
   1508  7ff0					      endif
   1509  7ff0
   1510  7ff0
   1511  7ff0
   1512  7ff0					      if	1
   1513  7ff0					      MAC	usex
   1514  7ff0				   .LY	      SET	0
   1515  7ff0					      .byte	1
   1516  7ff0					      .byte	{1}
   1517  7ff0					      REPEAT	10
   1518  7ff0					      IF	{1}=.LY
   1519  7ff0					      .byte	.LY
   1520  7ff0					      ENDIF
   1521  7ff0				   .LY	      SET	.LY+1
   1522  7ff0					      REPEND
   1523  7ff0					      ENDM
   1524  7ff0
   1525  7ff0
   1526  7ff0				   .LX	      SET	0
   1527  7ff0		       00		      .byte.b	0
   1528  7ff1				  -	      REPEAT
   1529  7ff1				  -	      USEX	0
   1530  7ff1				  -.LX	      SET	.LX+1
   1531  7ff1					      REPEND
   1532  7ff1					      endif
   1533  7ff1
   1534  7ff1
   1535  7ff1					      MAC	test
   1536  7ff1					      .byte	0
   1537  7ff1					      ENDM
   1538  7ff1
   1539  7ff1					      MAC	test
   1540  7ff1					      .byte	1
   1541  7ff1					      ENDM
   1542  7ff1
   1543  7ff1					      MAC	test
   1544  7ff1					      .byte	2
   1545  7ff1					      ENDM
   1546  7ff1
      0  7ff1					      TEST
      1  7ff1		       00		      .byte.b	0
   1548  7ff2
   1549  7ff2
   1550  7ff2
 FREE BYTES IN FIXED BANK =  $9
   1551  7ff2					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFB - *
   1552  7ff2
   1553  7ff2							;---------------------------------------------------------------------------
   1554  7ff2							; The reset vectors
   1555  7ff2							; these must live in the fixed bank (last 2K of any ROM image in TigerVision)
   1556  7ff2
   1557  8000 ????				      SEG	InterruptVectors
   1558  7ffc					      ORG	FIXED_BANK + $7FC
   1559  7ffc					      RORG	$7ffC
   1560  7ffc
   1561  7ffc							;		 .word Reset	       ; NMI	    (not used)
   1562  7ffc		       c2 fb		      .word.w	Reset	; RESET
   1563  7ffe		       c2 fb		      .word.w	Reset	; IRQ	      (not used)
   1564  8000
   1565  8000							;---------------------------------------------------------------------------
------- FILE ./sokoboo.asm
    847  8000
    848  8000							;END
